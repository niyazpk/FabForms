
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>/usr/local/lib/node_modules/grunt-cli/node_modules/lodash/lodash.js -- cover.io</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="bootstrap.css" rel="stylesheet">
    <link href="prettify.css" type="text/css" rel="stylesheet" />
    <style type="text/css">
      html, body {
        font-family: georgia, serif;
      }
      
      .content {
      }
      table#files-table {
        table-layout: fixed;
        width: 94%;
      }

      table#files-table td, table#files-table th {
        width: 11%;
        padding-left: 5px;
        padding-right: 5px;
      }
      
      table#files-table td:first-child, table#files-table th:first-child {
        width: 33%;
      }
      
      .partialuncovered { 
        background: #EE9; 
      }
      
      pre.prettyprint {
        padding-top: 0em;
        border: 5px;
        padding-left: 0em;
        padding-bottom: 0em;
        font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;

      }
       
      span.covered {
        border-left: 2px solid lime; 
      }
      
      span.uncovered {
        background: #FDD;
        border-left: 2px solid red; 
      }
      
      span.partial {
        border-left: 2px solid #EE9; 
        background: #FFA;
      }
      
      div.header {
        width: 100%;
        padding: 0;
        margin: 0;
        border-bottom: 1px solid #EEE;
        height: 90px;
        background: #F8F8F8;
      }
      
      div.header-content {
        padding: 1em 3em;
      }
      
      a.index {
        text-decoration: none;
        color: inherit;
        font-size: 11px;
      }
      
      a.coverio {
        text-decoration: none;
        color: inherit;
        font-size: 11px;
      }
      
      div.content > a.index {
        padding-left: 1.5em;
        padding-bottom: 2em;
      }
      
      div.header-content h3 {
        font-weight: normal;
      }
      
      span.filename {
        font-weight: bold;
      }
      
      span.percentage {
        font-weight: bold;
      }
      
      div.stats {
        font-size: 13px;
      }
      
      div.stats span.separator {
        margin-left: 10px;
        margin-right: 10px;
      }
      
      div.stats span.stat-descriptor {
        color: gray;
      }
      
      table.code td.text {
        padding-left: 0px;
        padding-right: 0px;
      }

      .linenos p {
        text-align: left;
        margin: 0;
        padding-right: 0.5em;
        color: #999999;
        font-family: verdana, sans-serif;
        font-size: 0.8em;   /* 12/16 */
        line-height: 16px;  /* 16/12 */
      }

      td.text {
        width: 100%;
        height: 16px;
      }
      
      td.text pre > span {
        padding-top: 3px;
        line-height: 16px;
      }
    
    </style>
    <script src="jquery.min.js"></script>
    <script type="text/javascript" src="prettify.js"></script>
    <script >
    
      $(function() {
        $(".linenos p").css("text-align", "right");
        setTimeout(function() {
          prettyPrint();
        });
      });
    </script>

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  </head>

  <body>

      <div class="content">
        <div class="header">
          <div class="header-content">
            <a class="index" href="index.html">Â« index</a>
            <h3>Coverage for <span class="filename">/usr/local/lib/node_modules/grunt-cli/node_modules/lodash/lodash.js</span> : <span class="percentage">85%</span></h3>
            <div class="stats">
              4258  <span class="stat-descriptor">lines</span>     <span class="separator">| </span> 
              3641  <span class="stat-descriptor">run</span>        <span class="separator">| </span> 
              617  <span class="stat-descriptor">missing</span>    <span class="separator">| </span> 
              15  <span class="stat-descriptor">partial</span>      <span class="separator">| </span> 
              341  <span class="stat-descriptor">blocks</span>     <span class="separator">| </span> 
              49  <span class="stat-descriptor">blocks run</span>  <span class="separator">| </span> 
              292  <span class="stat-descriptor">blocks missing</span>
            </div>
          </div>
        </div>
        <table class="code" cellspacing="0" cellpadding="0">
          <tbody>
            <tr>
              <td class='linenos' valign='top'><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p><p>84</p><p>85</p><p>86</p><p>87</p><p>88</p><p>89</p><p>90</p><p>91</p><p>92</p><p>93</p><p>94</p><p>95</p><p>96</p><p>97</p><p>98</p><p>99</p><p>100</p><p>101</p><p>102</p><p>103</p><p>104</p><p>105</p><p>106</p><p>107</p><p>108</p><p>109</p><p>110</p><p>111</p><p>112</p><p>113</p><p>114</p><p>115</p><p>116</p><p>117</p><p>118</p><p>119</p><p>120</p><p>121</p><p>122</p><p>123</p><p>124</p><p>125</p><p>126</p><p>127</p><p>128</p><p>129</p><p>130</p><p>131</p><p>132</p><p>133</p><p>134</p><p>135</p><p>136</p><p>137</p><p>138</p><p>139</p><p>140</p><p>141</p><p>142</p><p>143</p><p>144</p><p>145</p><p>146</p><p>147</p><p>148</p><p>149</p><p>150</p><p>151</p><p>152</p><p>153</p><p>154</p><p>155</p><p>156</p><p>157</p><p>158</p><p>159</p><p>160</p><p>161</p><p>162</p><p>163</p><p>164</p><p>165</p><p>166</p><p>167</p><p>168</p><p>169</p><p>170</p><p>171</p><p>172</p><p>173</p><p>174</p><p>175</p><p>176</p><p>177</p><p>178</p><p>179</p><p>180</p><p>181</p><p>182</p><p>183</p><p>184</p><p>185</p><p>186</p><p>187</p><p>188</p><p>189</p><p>190</p><p>191</p><p>192</p><p>193</p><p>194</p><p>195</p><p>196</p><p>197</p><p>198</p><p>199</p><p>200</p><p>201</p><p>202</p><p>203</p><p>204</p><p>205</p><p>206</p><p>207</p><p>208</p><p>209</p><p>210</p><p>211</p><p>212</p><p>213</p><p>214</p><p>215</p><p>216</p><p>217</p><p>218</p><p>219</p><p>220</p><p>221</p><p>222</p><p>223</p><p>224</p><p>225</p><p>226</p><p>227</p><p>228</p><p>229</p><p>230</p><p>231</p><p>232</p><p>233</p><p>234</p><p>235</p><p>236</p><p>237</p><p>238</p><p>239</p><p>240</p><p>241</p><p>242</p><p>243</p><p>244</p><p>245</p><p>246</p><p>247</p><p>248</p><p>249</p><p>250</p><p>251</p><p>252</p><p>253</p><p>254</p><p>255</p><p>256</p><p>257</p><p>258</p><p>259</p><p>260</p><p>261</p><p>262</p><p>263</p><p>264</p><p>265</p><p>266</p><p>267</p><p>268</p><p>269</p><p>270</p><p>271</p><p>272</p><p>273</p><p>274</p><p>275</p><p>276</p><p>277</p><p>278</p><p>279</p><p>280</p><p>281</p><p>282</p><p>283</p><p>284</p><p>285</p><p>286</p><p>287</p><p>288</p><p>289</p><p>290</p><p>291</p><p>292</p><p>293</p><p>294</p><p>295</p><p>296</p><p>297</p><p>298</p><p>299</p><p>300</p><p>301</p><p>302</p><p>303</p><p>304</p><p>305</p><p>306</p><p>307</p><p>308</p><p>309</p><p>310</p><p>311</p><p>312</p><p>313</p><p>314</p><p>315</p><p>316</p><p>317</p><p>318</p><p>319</p><p>320</p><p>321</p><p>322</p><p>323</p><p>324</p><p>325</p><p>326</p><p>327</p><p>328</p><p>329</p><p>330</p><p>331</p><p>332</p><p>333</p><p>334</p><p>335</p><p>336</p><p>337</p><p>338</p><p>339</p><p>340</p><p>341</p><p>342</p><p>343</p><p>344</p><p>345</p><p>346</p><p>347</p><p>348</p><p>349</p><p>350</p><p>351</p><p>352</p><p>353</p><p>354</p><p>355</p><p>356</p><p>357</p><p>358</p><p>359</p><p>360</p><p>361</p><p>362</p><p>363</p><p>364</p><p>365</p><p>366</p><p>367</p><p>368</p><p>369</p><p>370</p><p>371</p><p>372</p><p>373</p><p>374</p><p>375</p><p>376</p><p>377</p><p>378</p><p>379</p><p>380</p><p>381</p><p>382</p><p>383</p><p>384</p><p>385</p><p>386</p><p>387</p><p>388</p><p>389</p><p>390</p><p>391</p><p>392</p><p>393</p><p>394</p><p>395</p><p>396</p><p>397</p><p>398</p><p>399</p><p>400</p><p>401</p><p>402</p><p>403</p><p>404</p><p>405</p><p>406</p><p>407</p><p>408</p><p>409</p><p>410</p><p>411</p><p>412</p><p>413</p><p>414</p><p>415</p><p>416</p><p>417</p><p>418</p><p>419</p><p>420</p><p>421</p><p>422</p><p>423</p><p>424</p><p>425</p><p>426</p><p>427</p><p>428</p><p>429</p><p>430</p><p>431</p><p>432</p><p>433</p><p>434</p><p>435</p><p>436</p><p>437</p><p>438</p><p>439</p><p>440</p><p>441</p><p>442</p><p>443</p><p>444</p><p>445</p><p>446</p><p>447</p><p>448</p><p>449</p><p>450</p><p>451</p><p>452</p><p>453</p><p>454</p><p>455</p><p>456</p><p>457</p><p>458</p><p>459</p><p>460</p><p>461</p><p>462</p><p>463</p><p>464</p><p>465</p><p>466</p><p>467</p><p>468</p><p>469</p><p>470</p><p>471</p><p>472</p><p>473</p><p>474</p><p>475</p><p>476</p><p>477</p><p>478</p><p>479</p><p>480</p><p>481</p><p>482</p><p>483</p><p>484</p><p>485</p><p>486</p><p>487</p><p>488</p><p>489</p><p>490</p><p>491</p><p>492</p><p>493</p><p>494</p><p>495</p><p>496</p><p>497</p><p>498</p><p>499</p><p>500</p><p>501</p><p>502</p><p>503</p><p>504</p><p>505</p><p>506</p><p>507</p><p>508</p><p>509</p><p>510</p><p>511</p><p>512</p><p>513</p><p>514</p><p>515</p><p>516</p><p>517</p><p>518</p><p>519</p><p>520</p><p>521</p><p>522</p><p>523</p><p>524</p><p>525</p><p>526</p><p>527</p><p>528</p><p>529</p><p>530</p><p>531</p><p>532</p><p>533</p><p>534</p><p>535</p><p>536</p><p>537</p><p>538</p><p>539</p><p>540</p><p>541</p><p>542</p><p>543</p><p>544</p><p>545</p><p>546</p><p>547</p><p>548</p><p>549</p><p>550</p><p>551</p><p>552</p><p>553</p><p>554</p><p>555</p><p>556</p><p>557</p><p>558</p><p>559</p><p>560</p><p>561</p><p>562</p><p>563</p><p>564</p><p>565</p><p>566</p><p>567</p><p>568</p><p>569</p><p>570</p><p>571</p><p>572</p><p>573</p><p>574</p><p>575</p><p>576</p><p>577</p><p>578</p><p>579</p><p>580</p><p>581</p><p>582</p><p>583</p><p>584</p><p>585</p><p>586</p><p>587</p><p>588</p><p>589</p><p>590</p><p>591</p><p>592</p><p>593</p><p>594</p><p>595</p><p>596</p><p>597</p><p>598</p><p>599</p><p>600</p><p>601</p><p>602</p><p>603</p><p>604</p><p>605</p><p>606</p><p>607</p><p>608</p><p>609</p><p>610</p><p>611</p><p>612</p><p>613</p><p>614</p><p>615</p><p>616</p><p>617</p><p>618</p><p>619</p><p>620</p><p>621</p><p>622</p><p>623</p><p>624</p><p>625</p><p>626</p><p>627</p><p>628</p><p>629</p><p>630</p><p>631</p><p>632</p><p>633</p><p>634</p><p>635</p><p>636</p><p>637</p><p>638</p><p>639</p><p>640</p><p>641</p><p>642</p><p>643</p><p>644</p><p>645</p><p>646</p><p>647</p><p>648</p><p>649</p><p>650</p><p>651</p><p>652</p><p>653</p><p>654</p><p>655</p><p>656</p><p>657</p><p>658</p><p>659</p><p>660</p><p>661</p><p>662</p><p>663</p><p>664</p><p>665</p><p>666</p><p>667</p><p>668</p><p>669</p><p>670</p><p>671</p><p>672</p><p>673</p><p>674</p><p>675</p><p>676</p><p>677</p><p>678</p><p>679</p><p>680</p><p>681</p><p>682</p><p>683</p><p>684</p><p>685</p><p>686</p><p>687</p><p>688</p><p>689</p><p>690</p><p>691</p><p>692</p><p>693</p><p>694</p><p>695</p><p>696</p><p>697</p><p>698</p><p>699</p><p>700</p><p>701</p><p>702</p><p>703</p><p>704</p><p>705</p><p>706</p><p>707</p><p>708</p><p>709</p><p>710</p><p>711</p><p>712</p><p>713</p><p>714</p><p>715</p><p>716</p><p>717</p><p>718</p><p>719</p><p>720</p><p>721</p><p>722</p><p>723</p><p>724</p><p>725</p><p>726</p><p>727</p><p>728</p><p>729</p><p>730</p><p>731</p><p>732</p><p>733</p><p>734</p><p>735</p><p>736</p><p>737</p><p>738</p><p>739</p><p>740</p><p>741</p><p>742</p><p>743</p><p>744</p><p>745</p><p>746</p><p>747</p><p>748</p><p>749</p><p>750</p><p>751</p><p>752</p><p>753</p><p>754</p><p>755</p><p>756</p><p>757</p><p>758</p><p>759</p><p>760</p><p>761</p><p>762</p><p>763</p><p>764</p><p>765</p><p>766</p><p>767</p><p>768</p><p>769</p><p>770</p><p>771</p><p>772</p><p>773</p><p>774</p><p>775</p><p>776</p><p>777</p><p>778</p><p>779</p><p>780</p><p>781</p><p>782</p><p>783</p><p>784</p><p>785</p><p>786</p><p>787</p><p>788</p><p>789</p><p>790</p><p>791</p><p>792</p><p>793</p><p>794</p><p>795</p><p>796</p><p>797</p><p>798</p><p>799</p><p>800</p><p>801</p><p>802</p><p>803</p><p>804</p><p>805</p><p>806</p><p>807</p><p>808</p><p>809</p><p>810</p><p>811</p><p>812</p><p>813</p><p>814</p><p>815</p><p>816</p><p>817</p><p>818</p><p>819</p><p>820</p><p>821</p><p>822</p><p>823</p><p>824</p><p>825</p><p>826</p><p>827</p><p>828</p><p>829</p><p>830</p><p>831</p><p>832</p><p>833</p><p>834</p><p>835</p><p>836</p><p>837</p><p>838</p><p>839</p><p>840</p><p>841</p><p>842</p><p>843</p><p>844</p><p>845</p><p>846</p><p>847</p><p>848</p><p>849</p><p>850</p><p>851</p><p>852</p><p>853</p><p>854</p><p>855</p><p>856</p><p>857</p><p>858</p><p>859</p><p>860</p><p>861</p><p>862</p><p>863</p><p>864</p><p>865</p><p>866</p><p>867</p><p>868</p><p>869</p><p>870</p><p>871</p><p>872</p><p>873</p><p>874</p><p>875</p><p>876</p><p>877</p><p>878</p><p>879</p><p>880</p><p>881</p><p>882</p><p>883</p><p>884</p><p>885</p><p>886</p><p>887</p><p>888</p><p>889</p><p>890</p><p>891</p><p>892</p><p>893</p><p>894</p><p>895</p><p>896</p><p>897</p><p>898</p><p>899</p><p>900</p><p>901</p><p>902</p><p>903</p><p>904</p><p>905</p><p>906</p><p>907</p><p>908</p><p>909</p><p>910</p><p>911</p><p>912</p><p>913</p><p>914</p><p>915</p><p>916</p><p>917</p><p>918</p><p>919</p><p>920</p><p>921</p><p>922</p><p>923</p><p>924</p><p>925</p><p>926</p><p>927</p><p>928</p><p>929</p><p>930</p><p>931</p><p>932</p><p>933</p><p>934</p><p>935</p><p>936</p><p>937</p><p>938</p><p>939</p><p>940</p><p>941</p><p>942</p><p>943</p><p>944</p><p>945</p><p>946</p><p>947</p><p>948</p><p>949</p><p>950</p><p>951</p><p>952</p><p>953</p><p>954</p><p>955</p><p>956</p><p>957</p><p>958</p><p>959</p><p>960</p><p>961</p><p>962</p><p>963</p><p>964</p><p>965</p><p>966</p><p>967</p><p>968</p><p>969</p><p>970</p><p>971</p><p>972</p><p>973</p><p>974</p><p>975</p><p>976</p><p>977</p><p>978</p><p>979</p><p>980</p><p>981</p><p>982</p><p>983</p><p>984</p><p>985</p><p>986</p><p>987</p><p>988</p><p>989</p><p>990</p><p>991</p><p>992</p><p>993</p><p>994</p><p>995</p><p>996</p><p>997</p><p>998</p><p>999</p><p>1000</p><p>1001</p><p>1002</p><p>1003</p><p>1004</p><p>1005</p><p>1006</p><p>1007</p><p>1008</p><p>1009</p><p>1010</p><p>1011</p><p>1012</p><p>1013</p><p>1014</p><p>1015</p><p>1016</p><p>1017</p><p>1018</p><p>1019</p><p>1020</p><p>1021</p><p>1022</p><p>1023</p><p>1024</p><p>1025</p><p>1026</p><p>1027</p><p>1028</p><p>1029</p><p>1030</p><p>1031</p><p>1032</p><p>1033</p><p>1034</p><p>1035</p><p>1036</p><p>1037</p><p>1038</p><p>1039</p><p>1040</p><p>1041</p><p>1042</p><p>1043</p><p>1044</p><p>1045</p><p>1046</p><p>1047</p><p>1048</p><p>1049</p><p>1050</p><p>1051</p><p>1052</p><p>1053</p><p>1054</p><p>1055</p><p>1056</p><p>1057</p><p>1058</p><p>1059</p><p>1060</p><p>1061</p><p>1062</p><p>1063</p><p>1064</p><p>1065</p><p>1066</p><p>1067</p><p>1068</p><p>1069</p><p>1070</p><p>1071</p><p>1072</p><p>1073</p><p>1074</p><p>1075</p><p>1076</p><p>1077</p><p>1078</p><p>1079</p><p>1080</p><p>1081</p><p>1082</p><p>1083</p><p>1084</p><p>1085</p><p>1086</p><p>1087</p><p>1088</p><p>1089</p><p>1090</p><p>1091</p><p>1092</p><p>1093</p><p>1094</p><p>1095</p><p>1096</p><p>1097</p><p>1098</p><p>1099</p><p>1100</p><p>1101</p><p>1102</p><p>1103</p><p>1104</p><p>1105</p><p>1106</p><p>1107</p><p>1108</p><p>1109</p><p>1110</p><p>1111</p><p>1112</p><p>1113</p><p>1114</p><p>1115</p><p>1116</p><p>1117</p><p>1118</p><p>1119</p><p>1120</p><p>1121</p><p>1122</p><p>1123</p><p>1124</p><p>1125</p><p>1126</p><p>1127</p><p>1128</p><p>1129</p><p>1130</p><p>1131</p><p>1132</p><p>1133</p><p>1134</p><p>1135</p><p>1136</p><p>1137</p><p>1138</p><p>1139</p><p>1140</p><p>1141</p><p>1142</p><p>1143</p><p>1144</p><p>1145</p><p>1146</p><p>1147</p><p>1148</p><p>1149</p><p>1150</p><p>1151</p><p>1152</p><p>1153</p><p>1154</p><p>1155</p><p>1156</p><p>1157</p><p>1158</p><p>1159</p><p>1160</p><p>1161</p><p>1162</p><p>1163</p><p>1164</p><p>1165</p><p>1166</p><p>1167</p><p>1168</p><p>1169</p><p>1170</p><p>1171</p><p>1172</p><p>1173</p><p>1174</p><p>1175</p><p>1176</p><p>1177</p><p>1178</p><p>1179</p><p>1180</p><p>1181</p><p>1182</p><p>1183</p><p>1184</p><p>1185</p><p>1186</p><p>1187</p><p>1188</p><p>1189</p><p>1190</p><p>1191</p><p>1192</p><p>1193</p><p>1194</p><p>1195</p><p>1196</p><p>1197</p><p>1198</p><p>1199</p><p>1200</p><p>1201</p><p>1202</p><p>1203</p><p>1204</p><p>1205</p><p>1206</p><p>1207</p><p>1208</p><p>1209</p><p>1210</p><p>1211</p><p>1212</p><p>1213</p><p>1214</p><p>1215</p><p>1216</p><p>1217</p><p>1218</p><p>1219</p><p>1220</p><p>1221</p><p>1222</p><p>1223</p><p>1224</p><p>1225</p><p>1226</p><p>1227</p><p>1228</p><p>1229</p><p>1230</p><p>1231</p><p>1232</p><p>1233</p><p>1234</p><p>1235</p><p>1236</p><p>1237</p><p>1238</p><p>1239</p><p>1240</p><p>1241</p><p>1242</p><p>1243</p><p>1244</p><p>1245</p><p>1246</p><p>1247</p><p>1248</p><p>1249</p><p>1250</p><p>1251</p><p>1252</p><p>1253</p><p>1254</p><p>1255</p><p>1256</p><p>1257</p><p>1258</p><p>1259</p><p>1260</p><p>1261</p><p>1262</p><p>1263</p><p>1264</p><p>1265</p><p>1266</p><p>1267</p><p>1268</p><p>1269</p><p>1270</p><p>1271</p><p>1272</p><p>1273</p><p>1274</p><p>1275</p><p>1276</p><p>1277</p><p>1278</p><p>1279</p><p>1280</p><p>1281</p><p>1282</p><p>1283</p><p>1284</p><p>1285</p><p>1286</p><p>1287</p><p>1288</p><p>1289</p><p>1290</p><p>1291</p><p>1292</p><p>1293</p><p>1294</p><p>1295</p><p>1296</p><p>1297</p><p>1298</p><p>1299</p><p>1300</p><p>1301</p><p>1302</p><p>1303</p><p>1304</p><p>1305</p><p>1306</p><p>1307</p><p>1308</p><p>1309</p><p>1310</p><p>1311</p><p>1312</p><p>1313</p><p>1314</p><p>1315</p><p>1316</p><p>1317</p><p>1318</p><p>1319</p><p>1320</p><p>1321</p><p>1322</p><p>1323</p><p>1324</p><p>1325</p><p>1326</p><p>1327</p><p>1328</p><p>1329</p><p>1330</p><p>1331</p><p>1332</p><p>1333</p><p>1334</p><p>1335</p><p>1336</p><p>1337</p><p>1338</p><p>1339</p><p>1340</p><p>1341</p><p>1342</p><p>1343</p><p>1344</p><p>1345</p><p>1346</p><p>1347</p><p>1348</p><p>1349</p><p>1350</p><p>1351</p><p>1352</p><p>1353</p><p>1354</p><p>1355</p><p>1356</p><p>1357</p><p>1358</p><p>1359</p><p>1360</p><p>1361</p><p>1362</p><p>1363</p><p>1364</p><p>1365</p><p>1366</p><p>1367</p><p>1368</p><p>1369</p><p>1370</p><p>1371</p><p>1372</p><p>1373</p><p>1374</p><p>1375</p><p>1376</p><p>1377</p><p>1378</p><p>1379</p><p>1380</p><p>1381</p><p>1382</p><p>1383</p><p>1384</p><p>1385</p><p>1386</p><p>1387</p><p>1388</p><p>1389</p><p>1390</p><p>1391</p><p>1392</p><p>1393</p><p>1394</p><p>1395</p><p>1396</p><p>1397</p><p>1398</p><p>1399</p><p>1400</p><p>1401</p><p>1402</p><p>1403</p><p>1404</p><p>1405</p><p>1406</p><p>1407</p><p>1408</p><p>1409</p><p>1410</p><p>1411</p><p>1412</p><p>1413</p><p>1414</p><p>1415</p><p>1416</p><p>1417</p><p>1418</p><p>1419</p><p>1420</p><p>1421</p><p>1422</p><p>1423</p><p>1424</p><p>1425</p><p>1426</p><p>1427</p><p>1428</p><p>1429</p><p>1430</p><p>1431</p><p>1432</p><p>1433</p><p>1434</p><p>1435</p><p>1436</p><p>1437</p><p>1438</p><p>1439</p><p>1440</p><p>1441</p><p>1442</p><p>1443</p><p>1444</p><p>1445</p><p>1446</p><p>1447</p><p>1448</p><p>1449</p><p>1450</p><p>1451</p><p>1452</p><p>1453</p><p>1454</p><p>1455</p><p>1456</p><p>1457</p><p>1458</p><p>1459</p><p>1460</p><p>1461</p><p>1462</p><p>1463</p><p>1464</p><p>1465</p><p>1466</p><p>1467</p><p>1468</p><p>1469</p><p>1470</p><p>1471</p><p>1472</p><p>1473</p><p>1474</p><p>1475</p><p>1476</p><p>1477</p><p>1478</p><p>1479</p><p>1480</p><p>1481</p><p>1482</p><p>1483</p><p>1484</p><p>1485</p><p>1486</p><p>1487</p><p>1488</p><p>1489</p><p>1490</p><p>1491</p><p>1492</p><p>1493</p><p>1494</p><p>1495</p><p>1496</p><p>1497</p><p>1498</p><p>1499</p><p>1500</p><p>1501</p><p>1502</p><p>1503</p><p>1504</p><p>1505</p><p>1506</p><p>1507</p><p>1508</p><p>1509</p><p>1510</p><p>1511</p><p>1512</p><p>1513</p><p>1514</p><p>1515</p><p>1516</p><p>1517</p><p>1518</p><p>1519</p><p>1520</p><p>1521</p><p>1522</p><p>1523</p><p>1524</p><p>1525</p><p>1526</p><p>1527</p><p>1528</p><p>1529</p><p>1530</p><p>1531</p><p>1532</p><p>1533</p><p>1534</p><p>1535</p><p>1536</p><p>1537</p><p>1538</p><p>1539</p><p>1540</p><p>1541</p><p>1542</p><p>1543</p><p>1544</p><p>1545</p><p>1546</p><p>1547</p><p>1548</p><p>1549</p><p>1550</p><p>1551</p><p>1552</p><p>1553</p><p>1554</p><p>1555</p><p>1556</p><p>1557</p><p>1558</p><p>1559</p><p>1560</p><p>1561</p><p>1562</p><p>1563</p><p>1564</p><p>1565</p><p>1566</p><p>1567</p><p>1568</p><p>1569</p><p>1570</p><p>1571</p><p>1572</p><p>1573</p><p>1574</p><p>1575</p><p>1576</p><p>1577</p><p>1578</p><p>1579</p><p>1580</p><p>1581</p><p>1582</p><p>1583</p><p>1584</p><p>1585</p><p>1586</p><p>1587</p><p>1588</p><p>1589</p><p>1590</p><p>1591</p><p>1592</p><p>1593</p><p>1594</p><p>1595</p><p>1596</p><p>1597</p><p>1598</p><p>1599</p><p>1600</p><p>1601</p><p>1602</p><p>1603</p><p>1604</p><p>1605</p><p>1606</p><p>1607</p><p>1608</p><p>1609</p><p>1610</p><p>1611</p><p>1612</p><p>1613</p><p>1614</p><p>1615</p><p>1616</p><p>1617</p><p>1618</p><p>1619</p><p>1620</p><p>1621</p><p>1622</p><p>1623</p><p>1624</p><p>1625</p><p>1626</p><p>1627</p><p>1628</p><p>1629</p><p>1630</p><p>1631</p><p>1632</p><p>1633</p><p>1634</p><p>1635</p><p>1636</p><p>1637</p><p>1638</p><p>1639</p><p>1640</p><p>1641</p><p>1642</p><p>1643</p><p>1644</p><p>1645</p><p>1646</p><p>1647</p><p>1648</p><p>1649</p><p>1650</p><p>1651</p><p>1652</p><p>1653</p><p>1654</p><p>1655</p><p>1656</p><p>1657</p><p>1658</p><p>1659</p><p>1660</p><p>1661</p><p>1662</p><p>1663</p><p>1664</p><p>1665</p><p>1666</p><p>1667</p><p>1668</p><p>1669</p><p>1670</p><p>1671</p><p>1672</p><p>1673</p><p>1674</p><p>1675</p><p>1676</p><p>1677</p><p>1678</p><p>1679</p><p>1680</p><p>1681</p><p>1682</p><p>1683</p><p>1684</p><p>1685</p><p>1686</p><p>1687</p><p>1688</p><p>1689</p><p>1690</p><p>1691</p><p>1692</p><p>1693</p><p>1694</p><p>1695</p><p>1696</p><p>1697</p><p>1698</p><p>1699</p><p>1700</p><p>1701</p><p>1702</p><p>1703</p><p>1704</p><p>1705</p><p>1706</p><p>1707</p><p>1708</p><p>1709</p><p>1710</p><p>1711</p><p>1712</p><p>1713</p><p>1714</p><p>1715</p><p>1716</p><p>1717</p><p>1718</p><p>1719</p><p>1720</p><p>1721</p><p>1722</p><p>1723</p><p>1724</p><p>1725</p><p>1726</p><p>1727</p><p>1728</p><p>1729</p><p>1730</p><p>1731</p><p>1732</p><p>1733</p><p>1734</p><p>1735</p><p>1736</p><p>1737</p><p>1738</p><p>1739</p><p>1740</p><p>1741</p><p>1742</p><p>1743</p><p>1744</p><p>1745</p><p>1746</p><p>1747</p><p>1748</p><p>1749</p><p>1750</p><p>1751</p><p>1752</p><p>1753</p><p>1754</p><p>1755</p><p>1756</p><p>1757</p><p>1758</p><p>1759</p><p>1760</p><p>1761</p><p>1762</p><p>1763</p><p>1764</p><p>1765</p><p>1766</p><p>1767</p><p>1768</p><p>1769</p><p>1770</p><p>1771</p><p>1772</p><p>1773</p><p>1774</p><p>1775</p><p>1776</p><p>1777</p><p>1778</p><p>1779</p><p>1780</p><p>1781</p><p>1782</p><p>1783</p><p>1784</p><p>1785</p><p>1786</p><p>1787</p><p>1788</p><p>1789</p><p>1790</p><p>1791</p><p>1792</p><p>1793</p><p>1794</p><p>1795</p><p>1796</p><p>1797</p><p>1798</p><p>1799</p><p>1800</p><p>1801</p><p>1802</p><p>1803</p><p>1804</p><p>1805</p><p>1806</p><p>1807</p><p>1808</p><p>1809</p><p>1810</p><p>1811</p><p>1812</p><p>1813</p><p>1814</p><p>1815</p><p>1816</p><p>1817</p><p>1818</p><p>1819</p><p>1820</p><p>1821</p><p>1822</p><p>1823</p><p>1824</p><p>1825</p><p>1826</p><p>1827</p><p>1828</p><p>1829</p><p>1830</p><p>1831</p><p>1832</p><p>1833</p><p>1834</p><p>1835</p><p>1836</p><p>1837</p><p>1838</p><p>1839</p><p>1840</p><p>1841</p><p>1842</p><p>1843</p><p>1844</p><p>1845</p><p>1846</p><p>1847</p><p>1848</p><p>1849</p><p>1850</p><p>1851</p><p>1852</p><p>1853</p><p>1854</p><p>1855</p><p>1856</p><p>1857</p><p>1858</p><p>1859</p><p>1860</p><p>1861</p><p>1862</p><p>1863</p><p>1864</p><p>1865</p><p>1866</p><p>1867</p><p>1868</p><p>1869</p><p>1870</p><p>1871</p><p>1872</p><p>1873</p><p>1874</p><p>1875</p><p>1876</p><p>1877</p><p>1878</p><p>1879</p><p>1880</p><p>1881</p><p>1882</p><p>1883</p><p>1884</p><p>1885</p><p>1886</p><p>1887</p><p>1888</p><p>1889</p><p>1890</p><p>1891</p><p>1892</p><p>1893</p><p>1894</p><p>1895</p><p>1896</p><p>1897</p><p>1898</p><p>1899</p><p>1900</p><p>1901</p><p>1902</p><p>1903</p><p>1904</p><p>1905</p><p>1906</p><p>1907</p><p>1908</p><p>1909</p><p>1910</p><p>1911</p><p>1912</p><p>1913</p><p>1914</p><p>1915</p><p>1916</p><p>1917</p><p>1918</p><p>1919</p><p>1920</p><p>1921</p><p>1922</p><p>1923</p><p>1924</p><p>1925</p><p>1926</p><p>1927</p><p>1928</p><p>1929</p><p>1930</p><p>1931</p><p>1932</p><p>1933</p><p>1934</p><p>1935</p><p>1936</p><p>1937</p><p>1938</p><p>1939</p><p>1940</p><p>1941</p><p>1942</p><p>1943</p><p>1944</p><p>1945</p><p>1946</p><p>1947</p><p>1948</p><p>1949</p><p>1950</p><p>1951</p><p>1952</p><p>1953</p><p>1954</p><p>1955</p><p>1956</p><p>1957</p><p>1958</p><p>1959</p><p>1960</p><p>1961</p><p>1962</p><p>1963</p><p>1964</p><p>1965</p><p>1966</p><p>1967</p><p>1968</p><p>1969</p><p>1970</p><p>1971</p><p>1972</p><p>1973</p><p>1974</p><p>1975</p><p>1976</p><p>1977</p><p>1978</p><p>1979</p><p>1980</p><p>1981</p><p>1982</p><p>1983</p><p>1984</p><p>1985</p><p>1986</p><p>1987</p><p>1988</p><p>1989</p><p>1990</p><p>1991</p><p>1992</p><p>1993</p><p>1994</p><p>1995</p><p>1996</p><p>1997</p><p>1998</p><p>1999</p><p>2000</p><p>2001</p><p>2002</p><p>2003</p><p>2004</p><p>2005</p><p>2006</p><p>2007</p><p>2008</p><p>2009</p><p>2010</p><p>2011</p><p>2012</p><p>2013</p><p>2014</p><p>2015</p><p>2016</p><p>2017</p><p>2018</p><p>2019</p><p>2020</p><p>2021</p><p>2022</p><p>2023</p><p>2024</p><p>2025</p><p>2026</p><p>2027</p><p>2028</p><p>2029</p><p>2030</p><p>2031</p><p>2032</p><p>2033</p><p>2034</p><p>2035</p><p>2036</p><p>2037</p><p>2038</p><p>2039</p><p>2040</p><p>2041</p><p>2042</p><p>2043</p><p>2044</p><p>2045</p><p>2046</p><p>2047</p><p>2048</p><p>2049</p><p>2050</p><p>2051</p><p>2052</p><p>2053</p><p>2054</p><p>2055</p><p>2056</p><p>2057</p><p>2058</p><p>2059</p><p>2060</p><p>2061</p><p>2062</p><p>2063</p><p>2064</p><p>2065</p><p>2066</p><p>2067</p><p>2068</p><p>2069</p><p>2070</p><p>2071</p><p>2072</p><p>2073</p><p>2074</p><p>2075</p><p>2076</p><p>2077</p><p>2078</p><p>2079</p><p>2080</p><p>2081</p><p>2082</p><p>2083</p><p>2084</p><p>2085</p><p>2086</p><p>2087</p><p>2088</p><p>2089</p><p>2090</p><p>2091</p><p>2092</p><p>2093</p><p>2094</p><p>2095</p><p>2096</p><p>2097</p><p>2098</p><p>2099</p><p>2100</p><p>2101</p><p>2102</p><p>2103</p><p>2104</p><p>2105</p><p>2106</p><p>2107</p><p>2108</p><p>2109</p><p>2110</p><p>2111</p><p>2112</p><p>2113</p><p>2114</p><p>2115</p><p>2116</p><p>2117</p><p>2118</p><p>2119</p><p>2120</p><p>2121</p><p>2122</p><p>2123</p><p>2124</p><p>2125</p><p>2126</p><p>2127</p><p>2128</p><p>2129</p><p>2130</p><p>2131</p><p>2132</p><p>2133</p><p>2134</p><p>2135</p><p>2136</p><p>2137</p><p>2138</p><p>2139</p><p>2140</p><p>2141</p><p>2142</p><p>2143</p><p>2144</p><p>2145</p><p>2146</p><p>2147</p><p>2148</p><p>2149</p><p>2150</p><p>2151</p><p>2152</p><p>2153</p><p>2154</p><p>2155</p><p>2156</p><p>2157</p><p>2158</p><p>2159</p><p>2160</p><p>2161</p><p>2162</p><p>2163</p><p>2164</p><p>2165</p><p>2166</p><p>2167</p><p>2168</p><p>2169</p><p>2170</p><p>2171</p><p>2172</p><p>2173</p><p>2174</p><p>2175</p><p>2176</p><p>2177</p><p>2178</p><p>2179</p><p>2180</p><p>2181</p><p>2182</p><p>2183</p><p>2184</p><p>2185</p><p>2186</p><p>2187</p><p>2188</p><p>2189</p><p>2190</p><p>2191</p><p>2192</p><p>2193</p><p>2194</p><p>2195</p><p>2196</p><p>2197</p><p>2198</p><p>2199</p><p>2200</p><p>2201</p><p>2202</p><p>2203</p><p>2204</p><p>2205</p><p>2206</p><p>2207</p><p>2208</p><p>2209</p><p>2210</p><p>2211</p><p>2212</p><p>2213</p><p>2214</p><p>2215</p><p>2216</p><p>2217</p><p>2218</p><p>2219</p><p>2220</p><p>2221</p><p>2222</p><p>2223</p><p>2224</p><p>2225</p><p>2226</p><p>2227</p><p>2228</p><p>2229</p><p>2230</p><p>2231</p><p>2232</p><p>2233</p><p>2234</p><p>2235</p><p>2236</p><p>2237</p><p>2238</p><p>2239</p><p>2240</p><p>2241</p><p>2242</p><p>2243</p><p>2244</p><p>2245</p><p>2246</p><p>2247</p><p>2248</p><p>2249</p><p>2250</p><p>2251</p><p>2252</p><p>2253</p><p>2254</p><p>2255</p><p>2256</p><p>2257</p><p>2258</p><p>2259</p><p>2260</p><p>2261</p><p>2262</p><p>2263</p><p>2264</p><p>2265</p><p>2266</p><p>2267</p><p>2268</p><p>2269</p><p>2270</p><p>2271</p><p>2272</p><p>2273</p><p>2274</p><p>2275</p><p>2276</p><p>2277</p><p>2278</p><p>2279</p><p>2280</p><p>2281</p><p>2282</p><p>2283</p><p>2284</p><p>2285</p><p>2286</p><p>2287</p><p>2288</p><p>2289</p><p>2290</p><p>2291</p><p>2292</p><p>2293</p><p>2294</p><p>2295</p><p>2296</p><p>2297</p><p>2298</p><p>2299</p><p>2300</p><p>2301</p><p>2302</p><p>2303</p><p>2304</p><p>2305</p><p>2306</p><p>2307</p><p>2308</p><p>2309</p><p>2310</p><p>2311</p><p>2312</p><p>2313</p><p>2314</p><p>2315</p><p>2316</p><p>2317</p><p>2318</p><p>2319</p><p>2320</p><p>2321</p><p>2322</p><p>2323</p><p>2324</p><p>2325</p><p>2326</p><p>2327</p><p>2328</p><p>2329</p><p>2330</p><p>2331</p><p>2332</p><p>2333</p><p>2334</p><p>2335</p><p>2336</p><p>2337</p><p>2338</p><p>2339</p><p>2340</p><p>2341</p><p>2342</p><p>2343</p><p>2344</p><p>2345</p><p>2346</p><p>2347</p><p>2348</p><p>2349</p><p>2350</p><p>2351</p><p>2352</p><p>2353</p><p>2354</p><p>2355</p><p>2356</p><p>2357</p><p>2358</p><p>2359</p><p>2360</p><p>2361</p><p>2362</p><p>2363</p><p>2364</p><p>2365</p><p>2366</p><p>2367</p><p>2368</p><p>2369</p><p>2370</p><p>2371</p><p>2372</p><p>2373</p><p>2374</p><p>2375</p><p>2376</p><p>2377</p><p>2378</p><p>2379</p><p>2380</p><p>2381</p><p>2382</p><p>2383</p><p>2384</p><p>2385</p><p>2386</p><p>2387</p><p>2388</p><p>2389</p><p>2390</p><p>2391</p><p>2392</p><p>2393</p><p>2394</p><p>2395</p><p>2396</p><p>2397</p><p>2398</p><p>2399</p><p>2400</p><p>2401</p><p>2402</p><p>2403</p><p>2404</p><p>2405</p><p>2406</p><p>2407</p><p>2408</p><p>2409</p><p>2410</p><p>2411</p><p>2412</p><p>2413</p><p>2414</p><p>2415</p><p>2416</p><p>2417</p><p>2418</p><p>2419</p><p>2420</p><p>2421</p><p>2422</p><p>2423</p><p>2424</p><p>2425</p><p>2426</p><p>2427</p><p>2428</p><p>2429</p><p>2430</p><p>2431</p><p>2432</p><p>2433</p><p>2434</p><p>2435</p><p>2436</p><p>2437</p><p>2438</p><p>2439</p><p>2440</p><p>2441</p><p>2442</p><p>2443</p><p>2444</p><p>2445</p><p>2446</p><p>2447</p><p>2448</p><p>2449</p><p>2450</p><p>2451</p><p>2452</p><p>2453</p><p>2454</p><p>2455</p><p>2456</p><p>2457</p><p>2458</p><p>2459</p><p>2460</p><p>2461</p><p>2462</p><p>2463</p><p>2464</p><p>2465</p><p>2466</p><p>2467</p><p>2468</p><p>2469</p><p>2470</p><p>2471</p><p>2472</p><p>2473</p><p>2474</p><p>2475</p><p>2476</p><p>2477</p><p>2478</p><p>2479</p><p>2480</p><p>2481</p><p>2482</p><p>2483</p><p>2484</p><p>2485</p><p>2486</p><p>2487</p><p>2488</p><p>2489</p><p>2490</p><p>2491</p><p>2492</p><p>2493</p><p>2494</p><p>2495</p><p>2496</p><p>2497</p><p>2498</p><p>2499</p><p>2500</p><p>2501</p><p>2502</p><p>2503</p><p>2504</p><p>2505</p><p>2506</p><p>2507</p><p>2508</p><p>2509</p><p>2510</p><p>2511</p><p>2512</p><p>2513</p><p>2514</p><p>2515</p><p>2516</p><p>2517</p><p>2518</p><p>2519</p><p>2520</p><p>2521</p><p>2522</p><p>2523</p><p>2524</p><p>2525</p><p>2526</p><p>2527</p><p>2528</p><p>2529</p><p>2530</p><p>2531</p><p>2532</p><p>2533</p><p>2534</p><p>2535</p><p>2536</p><p>2537</p><p>2538</p><p>2539</p><p>2540</p><p>2541</p><p>2542</p><p>2543</p><p>2544</p><p>2545</p><p>2546</p><p>2547</p><p>2548</p><p>2549</p><p>2550</p><p>2551</p><p>2552</p><p>2553</p><p>2554</p><p>2555</p><p>2556</p><p>2557</p><p>2558</p><p>2559</p><p>2560</p><p>2561</p><p>2562</p><p>2563</p><p>2564</p><p>2565</p><p>2566</p><p>2567</p><p>2568</p><p>2569</p><p>2570</p><p>2571</p><p>2572</p><p>2573</p><p>2574</p><p>2575</p><p>2576</p><p>2577</p><p>2578</p><p>2579</p><p>2580</p><p>2581</p><p>2582</p><p>2583</p><p>2584</p><p>2585</p><p>2586</p><p>2587</p><p>2588</p><p>2589</p><p>2590</p><p>2591</p><p>2592</p><p>2593</p><p>2594</p><p>2595</p><p>2596</p><p>2597</p><p>2598</p><p>2599</p><p>2600</p><p>2601</p><p>2602</p><p>2603</p><p>2604</p><p>2605</p><p>2606</p><p>2607</p><p>2608</p><p>2609</p><p>2610</p><p>2611</p><p>2612</p><p>2613</p><p>2614</p><p>2615</p><p>2616</p><p>2617</p><p>2618</p><p>2619</p><p>2620</p><p>2621</p><p>2622</p><p>2623</p><p>2624</p><p>2625</p><p>2626</p><p>2627</p><p>2628</p><p>2629</p><p>2630</p><p>2631</p><p>2632</p><p>2633</p><p>2634</p><p>2635</p><p>2636</p><p>2637</p><p>2638</p><p>2639</p><p>2640</p><p>2641</p><p>2642</p><p>2643</p><p>2644</p><p>2645</p><p>2646</p><p>2647</p><p>2648</p><p>2649</p><p>2650</p><p>2651</p><p>2652</p><p>2653</p><p>2654</p><p>2655</p><p>2656</p><p>2657</p><p>2658</p><p>2659</p><p>2660</p><p>2661</p><p>2662</p><p>2663</p><p>2664</p><p>2665</p><p>2666</p><p>2667</p><p>2668</p><p>2669</p><p>2670</p><p>2671</p><p>2672</p><p>2673</p><p>2674</p><p>2675</p><p>2676</p><p>2677</p><p>2678</p><p>2679</p><p>2680</p><p>2681</p><p>2682</p><p>2683</p><p>2684</p><p>2685</p><p>2686</p><p>2687</p><p>2688</p><p>2689</p><p>2690</p><p>2691</p><p>2692</p><p>2693</p><p>2694</p><p>2695</p><p>2696</p><p>2697</p><p>2698</p><p>2699</p><p>2700</p><p>2701</p><p>2702</p><p>2703</p><p>2704</p><p>2705</p><p>2706</p><p>2707</p><p>2708</p><p>2709</p><p>2710</p><p>2711</p><p>2712</p><p>2713</p><p>2714</p><p>2715</p><p>2716</p><p>2717</p><p>2718</p><p>2719</p><p>2720</p><p>2721</p><p>2722</p><p>2723</p><p>2724</p><p>2725</p><p>2726</p><p>2727</p><p>2728</p><p>2729</p><p>2730</p><p>2731</p><p>2732</p><p>2733</p><p>2734</p><p>2735</p><p>2736</p><p>2737</p><p>2738</p><p>2739</p><p>2740</p><p>2741</p><p>2742</p><p>2743</p><p>2744</p><p>2745</p><p>2746</p><p>2747</p><p>2748</p><p>2749</p><p>2750</p><p>2751</p><p>2752</p><p>2753</p><p>2754</p><p>2755</p><p>2756</p><p>2757</p><p>2758</p><p>2759</p><p>2760</p><p>2761</p><p>2762</p><p>2763</p><p>2764</p><p>2765</p><p>2766</p><p>2767</p><p>2768</p><p>2769</p><p>2770</p><p>2771</p><p>2772</p><p>2773</p><p>2774</p><p>2775</p><p>2776</p><p>2777</p><p>2778</p><p>2779</p><p>2780</p><p>2781</p><p>2782</p><p>2783</p><p>2784</p><p>2785</p><p>2786</p><p>2787</p><p>2788</p><p>2789</p><p>2790</p><p>2791</p><p>2792</p><p>2793</p><p>2794</p><p>2795</p><p>2796</p><p>2797</p><p>2798</p><p>2799</p><p>2800</p><p>2801</p><p>2802</p><p>2803</p><p>2804</p><p>2805</p><p>2806</p><p>2807</p><p>2808</p><p>2809</p><p>2810</p><p>2811</p><p>2812</p><p>2813</p><p>2814</p><p>2815</p><p>2816</p><p>2817</p><p>2818</p><p>2819</p><p>2820</p><p>2821</p><p>2822</p><p>2823</p><p>2824</p><p>2825</p><p>2826</p><p>2827</p><p>2828</p><p>2829</p><p>2830</p><p>2831</p><p>2832</p><p>2833</p><p>2834</p><p>2835</p><p>2836</p><p>2837</p><p>2838</p><p>2839</p><p>2840</p><p>2841</p><p>2842</p><p>2843</p><p>2844</p><p>2845</p><p>2846</p><p>2847</p><p>2848</p><p>2849</p><p>2850</p><p>2851</p><p>2852</p><p>2853</p><p>2854</p><p>2855</p><p>2856</p><p>2857</p><p>2858</p><p>2859</p><p>2860</p><p>2861</p><p>2862</p><p>2863</p><p>2864</p><p>2865</p><p>2866</p><p>2867</p><p>2868</p><p>2869</p><p>2870</p><p>2871</p><p>2872</p><p>2873</p><p>2874</p><p>2875</p><p>2876</p><p>2877</p><p>2878</p><p>2879</p><p>2880</p><p>2881</p><p>2882</p><p>2883</p><p>2884</p><p>2885</p><p>2886</p><p>2887</p><p>2888</p><p>2889</p><p>2890</p><p>2891</p><p>2892</p><p>2893</p><p>2894</p><p>2895</p><p>2896</p><p>2897</p><p>2898</p><p>2899</p><p>2900</p><p>2901</p><p>2902</p><p>2903</p><p>2904</p><p>2905</p><p>2906</p><p>2907</p><p>2908</p><p>2909</p><p>2910</p><p>2911</p><p>2912</p><p>2913</p><p>2914</p><p>2915</p><p>2916</p><p>2917</p><p>2918</p><p>2919</p><p>2920</p><p>2921</p><p>2922</p><p>2923</p><p>2924</p><p>2925</p><p>2926</p><p>2927</p><p>2928</p><p>2929</p><p>2930</p><p>2931</p><p>2932</p><p>2933</p><p>2934</p><p>2935</p><p>2936</p><p>2937</p><p>2938</p><p>2939</p><p>2940</p><p>2941</p><p>2942</p><p>2943</p><p>2944</p><p>2945</p><p>2946</p><p>2947</p><p>2948</p><p>2949</p><p>2950</p><p>2951</p><p>2952</p><p>2953</p><p>2954</p><p>2955</p><p>2956</p><p>2957</p><p>2958</p><p>2959</p><p>2960</p><p>2961</p><p>2962</p><p>2963</p><p>2964</p><p>2965</p><p>2966</p><p>2967</p><p>2968</p><p>2969</p><p>2970</p><p>2971</p><p>2972</p><p>2973</p><p>2974</p><p>2975</p><p>2976</p><p>2977</p><p>2978</p><p>2979</p><p>2980</p><p>2981</p><p>2982</p><p>2983</p><p>2984</p><p>2985</p><p>2986</p><p>2987</p><p>2988</p><p>2989</p><p>2990</p><p>2991</p><p>2992</p><p>2993</p><p>2994</p><p>2995</p><p>2996</p><p>2997</p><p>2998</p><p>2999</p><p>3000</p><p>3001</p><p>3002</p><p>3003</p><p>3004</p><p>3005</p><p>3006</p><p>3007</p><p>3008</p><p>3009</p><p>3010</p><p>3011</p><p>3012</p><p>3013</p><p>3014</p><p>3015</p><p>3016</p><p>3017</p><p>3018</p><p>3019</p><p>3020</p><p>3021</p><p>3022</p><p>3023</p><p>3024</p><p>3025</p><p>3026</p><p>3027</p><p>3028</p><p>3029</p><p>3030</p><p>3031</p><p>3032</p><p>3033</p><p>3034</p><p>3035</p><p>3036</p><p>3037</p><p>3038</p><p>3039</p><p>3040</p><p>3041</p><p>3042</p><p>3043</p><p>3044</p><p>3045</p><p>3046</p><p>3047</p><p>3048</p><p>3049</p><p>3050</p><p>3051</p><p>3052</p><p>3053</p><p>3054</p><p>3055</p><p>3056</p><p>3057</p><p>3058</p><p>3059</p><p>3060</p><p>3061</p><p>3062</p><p>3063</p><p>3064</p><p>3065</p><p>3066</p><p>3067</p><p>3068</p><p>3069</p><p>3070</p><p>3071</p><p>3072</p><p>3073</p><p>3074</p><p>3075</p><p>3076</p><p>3077</p><p>3078</p><p>3079</p><p>3080</p><p>3081</p><p>3082</p><p>3083</p><p>3084</p><p>3085</p><p>3086</p><p>3087</p><p>3088</p><p>3089</p><p>3090</p><p>3091</p><p>3092</p><p>3093</p><p>3094</p><p>3095</p><p>3096</p><p>3097</p><p>3098</p><p>3099</p><p>3100</p><p>3101</p><p>3102</p><p>3103</p><p>3104</p><p>3105</p><p>3106</p><p>3107</p><p>3108</p><p>3109</p><p>3110</p><p>3111</p><p>3112</p><p>3113</p><p>3114</p><p>3115</p><p>3116</p><p>3117</p><p>3118</p><p>3119</p><p>3120</p><p>3121</p><p>3122</p><p>3123</p><p>3124</p><p>3125</p><p>3126</p><p>3127</p><p>3128</p><p>3129</p><p>3130</p><p>3131</p><p>3132</p><p>3133</p><p>3134</p><p>3135</p><p>3136</p><p>3137</p><p>3138</p><p>3139</p><p>3140</p><p>3141</p><p>3142</p><p>3143</p><p>3144</p><p>3145</p><p>3146</p><p>3147</p><p>3148</p><p>3149</p><p>3150</p><p>3151</p><p>3152</p><p>3153</p><p>3154</p><p>3155</p><p>3156</p><p>3157</p><p>3158</p><p>3159</p><p>3160</p><p>3161</p><p>3162</p><p>3163</p><p>3164</p><p>3165</p><p>3166</p><p>3167</p><p>3168</p><p>3169</p><p>3170</p><p>3171</p><p>3172</p><p>3173</p><p>3174</p><p>3175</p><p>3176</p><p>3177</p><p>3178</p><p>3179</p><p>3180</p><p>3181</p><p>3182</p><p>3183</p><p>3184</p><p>3185</p><p>3186</p><p>3187</p><p>3188</p><p>3189</p><p>3190</p><p>3191</p><p>3192</p><p>3193</p><p>3194</p><p>3195</p><p>3196</p><p>3197</p><p>3198</p><p>3199</p><p>3200</p><p>3201</p><p>3202</p><p>3203</p><p>3204</p><p>3205</p><p>3206</p><p>3207</p><p>3208</p><p>3209</p><p>3210</p><p>3211</p><p>3212</p><p>3213</p><p>3214</p><p>3215</p><p>3216</p><p>3217</p><p>3218</p><p>3219</p><p>3220</p><p>3221</p><p>3222</p><p>3223</p><p>3224</p><p>3225</p><p>3226</p><p>3227</p><p>3228</p><p>3229</p><p>3230</p><p>3231</p><p>3232</p><p>3233</p><p>3234</p><p>3235</p><p>3236</p><p>3237</p><p>3238</p><p>3239</p><p>3240</p><p>3241</p><p>3242</p><p>3243</p><p>3244</p><p>3245</p><p>3246</p><p>3247</p><p>3248</p><p>3249</p><p>3250</p><p>3251</p><p>3252</p><p>3253</p><p>3254</p><p>3255</p><p>3256</p><p>3257</p><p>3258</p><p>3259</p><p>3260</p><p>3261</p><p>3262</p><p>3263</p><p>3264</p><p>3265</p><p>3266</p><p>3267</p><p>3268</p><p>3269</p><p>3270</p><p>3271</p><p>3272</p><p>3273</p><p>3274</p><p>3275</p><p>3276</p><p>3277</p><p>3278</p><p>3279</p><p>3280</p><p>3281</p><p>3282</p><p>3283</p><p>3284</p><p>3285</p><p>3286</p><p>3287</p><p>3288</p><p>3289</p><p>3290</p><p>3291</p><p>3292</p><p>3293</p><p>3294</p><p>3295</p><p>3296</p><p>3297</p><p>3298</p><p>3299</p><p>3300</p><p>3301</p><p>3302</p><p>3303</p><p>3304</p><p>3305</p><p>3306</p><p>3307</p><p>3308</p><p>3309</p><p>3310</p><p>3311</p><p>3312</p><p>3313</p><p>3314</p><p>3315</p><p>3316</p><p>3317</p><p>3318</p><p>3319</p><p>3320</p><p>3321</p><p>3322</p><p>3323</p><p>3324</p><p>3325</p><p>3326</p><p>3327</p><p>3328</p><p>3329</p><p>3330</p><p>3331</p><p>3332</p><p>3333</p><p>3334</p><p>3335</p><p>3336</p><p>3337</p><p>3338</p><p>3339</p><p>3340</p><p>3341</p><p>3342</p><p>3343</p><p>3344</p><p>3345</p><p>3346</p><p>3347</p><p>3348</p><p>3349</p><p>3350</p><p>3351</p><p>3352</p><p>3353</p><p>3354</p><p>3355</p><p>3356</p><p>3357</p><p>3358</p><p>3359</p><p>3360</p><p>3361</p><p>3362</p><p>3363</p><p>3364</p><p>3365</p><p>3366</p><p>3367</p><p>3368</p><p>3369</p><p>3370</p><p>3371</p><p>3372</p><p>3373</p><p>3374</p><p>3375</p><p>3376</p><p>3377</p><p>3378</p><p>3379</p><p>3380</p><p>3381</p><p>3382</p><p>3383</p><p>3384</p><p>3385</p><p>3386</p><p>3387</p><p>3388</p><p>3389</p><p>3390</p><p>3391</p><p>3392</p><p>3393</p><p>3394</p><p>3395</p><p>3396</p><p>3397</p><p>3398</p><p>3399</p><p>3400</p><p>3401</p><p>3402</p><p>3403</p><p>3404</p><p>3405</p><p>3406</p><p>3407</p><p>3408</p><p>3409</p><p>3410</p><p>3411</p><p>3412</p><p>3413</p><p>3414</p><p>3415</p><p>3416</p><p>3417</p><p>3418</p><p>3419</p><p>3420</p><p>3421</p><p>3422</p><p>3423</p><p>3424</p><p>3425</p><p>3426</p><p>3427</p><p>3428</p><p>3429</p><p>3430</p><p>3431</p><p>3432</p><p>3433</p><p>3434</p><p>3435</p><p>3436</p><p>3437</p><p>3438</p><p>3439</p><p>3440</p><p>3441</p><p>3442</p><p>3443</p><p>3444</p><p>3445</p><p>3446</p><p>3447</p><p>3448</p><p>3449</p><p>3450</p><p>3451</p><p>3452</p><p>3453</p><p>3454</p><p>3455</p><p>3456</p><p>3457</p><p>3458</p><p>3459</p><p>3460</p><p>3461</p><p>3462</p><p>3463</p><p>3464</p><p>3465</p><p>3466</p><p>3467</p><p>3468</p><p>3469</p><p>3470</p><p>3471</p><p>3472</p><p>3473</p><p>3474</p><p>3475</p><p>3476</p><p>3477</p><p>3478</p><p>3479</p><p>3480</p><p>3481</p><p>3482</p><p>3483</p><p>3484</p><p>3485</p><p>3486</p><p>3487</p><p>3488</p><p>3489</p><p>3490</p><p>3491</p><p>3492</p><p>3493</p><p>3494</p><p>3495</p><p>3496</p><p>3497</p><p>3498</p><p>3499</p><p>3500</p><p>3501</p><p>3502</p><p>3503</p><p>3504</p><p>3505</p><p>3506</p><p>3507</p><p>3508</p><p>3509</p><p>3510</p><p>3511</p><p>3512</p><p>3513</p><p>3514</p><p>3515</p><p>3516</p><p>3517</p><p>3518</p><p>3519</p><p>3520</p><p>3521</p><p>3522</p><p>3523</p><p>3524</p><p>3525</p><p>3526</p><p>3527</p><p>3528</p><p>3529</p><p>3530</p><p>3531</p><p>3532</p><p>3533</p><p>3534</p><p>3535</p><p>3536</p><p>3537</p><p>3538</p><p>3539</p><p>3540</p><p>3541</p><p>3542</p><p>3543</p><p>3544</p><p>3545</p><p>3546</p><p>3547</p><p>3548</p><p>3549</p><p>3550</p><p>3551</p><p>3552</p><p>3553</p><p>3554</p><p>3555</p><p>3556</p><p>3557</p><p>3558</p><p>3559</p><p>3560</p><p>3561</p><p>3562</p><p>3563</p><p>3564</p><p>3565</p><p>3566</p><p>3567</p><p>3568</p><p>3569</p><p>3570</p><p>3571</p><p>3572</p><p>3573</p><p>3574</p><p>3575</p><p>3576</p><p>3577</p><p>3578</p><p>3579</p><p>3580</p><p>3581</p><p>3582</p><p>3583</p><p>3584</p><p>3585</p><p>3586</p><p>3587</p><p>3588</p><p>3589</p><p>3590</p><p>3591</p><p>3592</p><p>3593</p><p>3594</p><p>3595</p><p>3596</p><p>3597</p><p>3598</p><p>3599</p><p>3600</p><p>3601</p><p>3602</p><p>3603</p><p>3604</p><p>3605</p><p>3606</p><p>3607</p><p>3608</p><p>3609</p><p>3610</p><p>3611</p><p>3612</p><p>3613</p><p>3614</p><p>3615</p><p>3616</p><p>3617</p><p>3618</p><p>3619</p><p>3620</p><p>3621</p><p>3622</p><p>3623</p><p>3624</p><p>3625</p><p>3626</p><p>3627</p><p>3628</p><p>3629</p><p>3630</p><p>3631</p><p>3632</p><p>3633</p><p>3634</p><p>3635</p><p>3636</p><p>3637</p><p>3638</p><p>3639</p><p>3640</p><p>3641</p><p>3642</p><p>3643</p><p>3644</p><p>3645</p><p>3646</p><p>3647</p><p>3648</p><p>3649</p><p>3650</p><p>3651</p><p>3652</p><p>3653</p><p>3654</p><p>3655</p><p>3656</p><p>3657</p><p>3658</p><p>3659</p><p>3660</p><p>3661</p><p>3662</p><p>3663</p><p>3664</p><p>3665</p><p>3666</p><p>3667</p><p>3668</p><p>3669</p><p>3670</p><p>3671</p><p>3672</p><p>3673</p><p>3674</p><p>3675</p><p>3676</p><p>3677</p><p>3678</p><p>3679</p><p>3680</p><p>3681</p><p>3682</p><p>3683</p><p>3684</p><p>3685</p><p>3686</p><p>3687</p><p>3688</p><p>3689</p><p>3690</p><p>3691</p><p>3692</p><p>3693</p><p>3694</p><p>3695</p><p>3696</p><p>3697</p><p>3698</p><p>3699</p><p>3700</p><p>3701</p><p>3702</p><p>3703</p><p>3704</p><p>3705</p><p>3706</p><p>3707</p><p>3708</p><p>3709</p><p>3710</p><p>3711</p><p>3712</p><p>3713</p><p>3714</p><p>3715</p><p>3716</p><p>3717</p><p>3718</p><p>3719</p><p>3720</p><p>3721</p><p>3722</p><p>3723</p><p>3724</p><p>3725</p><p>3726</p><p>3727</p><p>3728</p><p>3729</p><p>3730</p><p>3731</p><p>3732</p><p>3733</p><p>3734</p><p>3735</p><p>3736</p><p>3737</p><p>3738</p><p>3739</p><p>3740</p><p>3741</p><p>3742</p><p>3743</p><p>3744</p><p>3745</p><p>3746</p><p>3747</p><p>3748</p><p>3749</p><p>3750</p><p>3751</p><p>3752</p><p>3753</p><p>3754</p><p>3755</p><p>3756</p><p>3757</p><p>3758</p><p>3759</p><p>3760</p><p>3761</p><p>3762</p><p>3763</p><p>3764</p><p>3765</p><p>3766</p><p>3767</p><p>3768</p><p>3769</p><p>3770</p><p>3771</p><p>3772</p><p>3773</p><p>3774</p><p>3775</p><p>3776</p><p>3777</p><p>3778</p><p>3779</p><p>3780</p><p>3781</p><p>3782</p><p>3783</p><p>3784</p><p>3785</p><p>3786</p><p>3787</p><p>3788</p><p>3789</p><p>3790</p><p>3791</p><p>3792</p><p>3793</p><p>3794</p><p>3795</p><p>3796</p><p>3797</p><p>3798</p><p>3799</p><p>3800</p><p>3801</p><p>3802</p><p>3803</p><p>3804</p><p>3805</p><p>3806</p><p>3807</p><p>3808</p><p>3809</p><p>3810</p><p>3811</p><p>3812</p><p>3813</p><p>3814</p><p>3815</p><p>3816</p><p>3817</p><p>3818</p><p>3819</p><p>3820</p><p>3821</p><p>3822</p><p>3823</p><p>3824</p><p>3825</p><p>3826</p><p>3827</p><p>3828</p><p>3829</p><p>3830</p><p>3831</p><p>3832</p><p>3833</p><p>3834</p><p>3835</p><p>3836</p><p>3837</p><p>3838</p><p>3839</p><p>3840</p><p>3841</p><p>3842</p><p>3843</p><p>3844</p><p>3845</p><p>3846</p><p>3847</p><p>3848</p><p>3849</p><p>3850</p><p>3851</p><p>3852</p><p>3853</p><p>3854</p><p>3855</p><p>3856</p><p>3857</p><p>3858</p><p>3859</p><p>3860</p><p>3861</p><p>3862</p><p>3863</p><p>3864</p><p>3865</p><p>3866</p><p>3867</p><p>3868</p><p>3869</p><p>3870</p><p>3871</p><p>3872</p><p>3873</p><p>3874</p><p>3875</p><p>3876</p><p>3877</p><p>3878</p><p>3879</p><p>3880</p><p>3881</p><p>3882</p><p>3883</p><p>3884</p><p>3885</p><p>3886</p><p>3887</p><p>3888</p><p>3889</p><p>3890</p><p>3891</p><p>3892</p><p>3893</p><p>3894</p><p>3895</p><p>3896</p><p>3897</p><p>3898</p><p>3899</p><p>3900</p><p>3901</p><p>3902</p><p>3903</p><p>3904</p><p>3905</p><p>3906</p><p>3907</p><p>3908</p><p>3909</p><p>3910</p><p>3911</p><p>3912</p><p>3913</p><p>3914</p><p>3915</p><p>3916</p><p>3917</p><p>3918</p><p>3919</p><p>3920</p><p>3921</p><p>3922</p><p>3923</p><p>3924</p><p>3925</p><p>3926</p><p>3927</p><p>3928</p><p>3929</p><p>3930</p><p>3931</p><p>3932</p><p>3933</p><p>3934</p><p>3935</p><p>3936</p><p>3937</p><p>3938</p><p>3939</p><p>3940</p><p>3941</p><p>3942</p><p>3943</p><p>3944</p><p>3945</p><p>3946</p><p>3947</p><p>3948</p><p>3949</p><p>3950</p><p>3951</p><p>3952</p><p>3953</p><p>3954</p><p>3955</p><p>3956</p><p>3957</p><p>3958</p><p>3959</p><p>3960</p><p>3961</p><p>3962</p><p>3963</p><p>3964</p><p>3965</p><p>3966</p><p>3967</p><p>3968</p><p>3969</p><p>3970</p><p>3971</p><p>3972</p><p>3973</p><p>3974</p><p>3975</p><p>3976</p><p>3977</p><p>3978</p><p>3979</p><p>3980</p><p>3981</p><p>3982</p><p>3983</p><p>3984</p><p>3985</p><p>3986</p><p>3987</p><p>3988</p><p>3989</p><p>3990</p><p>3991</p><p>3992</p><p>3993</p><p>3994</p><p>3995</p><p>3996</p><p>3997</p><p>3998</p><p>3999</p><p>4000</p><p>4001</p><p>4002</p><p>4003</p><p>4004</p><p>4005</p><p>4006</p><p>4007</p><p>4008</p><p>4009</p><p>4010</p><p>4011</p><p>4012</p><p>4013</p><p>4014</p><p>4015</p><p>4016</p><p>4017</p><p>4018</p><p>4019</p><p>4020</p><p>4021</p><p>4022</p><p>4023</p><p>4024</p><p>4025</p><p>4026</p><p>4027</p><p>4028</p><p>4029</p><p>4030</p><p>4031</p><p>4032</p><p>4033</p><p>4034</p><p>4035</p><p>4036</p><p>4037</p><p>4038</p><p>4039</p><p>4040</p><p>4041</p><p>4042</p><p>4043</p><p>4044</p><p>4045</p><p>4046</p><p>4047</p><p>4048</p><p>4049</p><p>4050</p><p>4051</p><p>4052</p><p>4053</p><p>4054</p><p>4055</p><p>4056</p><p>4057</p><p>4058</p><p>4059</p><p>4060</p><p>4061</p><p>4062</p><p>4063</p><p>4064</p><p>4065</p><p>4066</p><p>4067</p><p>4068</p><p>4069</p><p>4070</p><p>4071</p><p>4072</p><p>4073</p><p>4074</p><p>4075</p><p>4076</p><p>4077</p><p>4078</p><p>4079</p><p>4080</p><p>4081</p><p>4082</p><p>4083</p><p>4084</p><p>4085</p><p>4086</p><p>4087</p><p>4088</p><p>4089</p><p>4090</p><p>4091</p><p>4092</p><p>4093</p><p>4094</p><p>4095</p><p>4096</p><p>4097</p><p>4098</p><p>4099</p><p>4100</p><p>4101</p><p>4102</p><p>4103</p><p>4104</p><p>4105</p><p>4106</p><p>4107</p><p>4108</p><p>4109</p><p>4110</p><p>4111</p><p>4112</p><p>4113</p><p>4114</p><p>4115</p><p>4116</p><p>4117</p><p>4118</p><p>4119</p><p>4120</p><p>4121</p><p>4122</p><p>4123</p><p>4124</p><p>4125</p><p>4126</p><p>4127</p><p>4128</p><p>4129</p><p>4130</p><p>4131</p><p>4132</p><p>4133</p><p>4134</p><p>4135</p><p>4136</p><p>4137</p><p>4138</p><p>4139</p><p>4140</p><p>4141</p><p>4142</p><p>4143</p><p>4144</p><p>4145</p><p>4146</p><p>4147</p><p>4148</p><p>4149</p><p>4150</p><p>4151</p><p>4152</p><p>4153</p><p>4154</p><p>4155</p><p>4156</p><p>4157</p><p>4158</p><p>4159</p><p>4160</p><p>4161</p><p>4162</p><p>4163</p><p>4164</p><p>4165</p><p>4166</p><p>4167</p><p>4168</p><p>4169</p><p>4170</p><p>4171</p><p>4172</p><p>4173</p><p>4174</p><p>4175</p><p>4176</p><p>4177</p><p>4178</p><p>4179</p><p>4180</p><p>4181</p><p>4182</p><p>4183</p><p>4184</p><p>4185</p><p>4186</p><p>4187</p><p>4188</p><p>4189</p><p>4190</p><p>4191</p><p>4192</p><p>4193</p><p>4194</p><p>4195</p><p>4196</p><p>4197</p><p>4198</p><p>4199</p><p>4200</p><p>4201</p><p>4202</p><p>4203</p><p>4204</p><p>4205</p><p>4206</p><p>4207</p><p>4208</p><p>4209</p><p>4210</p><p>4211</p><p>4212</p><p>4213</p><p>4214</p><p>4215</p><p>4216</p><p>4217</p><p>4218</p><p>4219</p><p>4220</p><p>4221</p><p>4222</p><p>4223</p><p>4224</p><p>4225</p><p>4226</p><p>4227</p><p>4228</p><p>4229</p><p>4230</p><p>4231</p><p>4232</p><p>4233</p><p>4234</p><p>4235</p><p>4236</p><p>4237</p><p>4238</p><p>4239</p><p>4240</p><p>4241</p><p>4242</p><p>4243</p><p>4244</p><p>4245</p><p>4246</p><p>4247</p><p>4248</p><p>4249</p><p>4250</p><p>4251</p><p>4252</p><p>4253</p><p>4254</p><p>4255</p><p>4256</p><p>4257</p><p>4258</p></td><td class='text' valign='top'><pre class='prettyprint lang-js'><span class='covered'>  /*!</span>
<span class='covered'>   * Lo-Dash v0.9.2 &lt;http://lodash.com&gt;</span>
<span class='covered'>   * (c) 2012 John-David Dalton &lt;http://allyoucanleet.com/&gt;</span>
<span class='covered'>   * Based on Underscore.js 1.4.2 &lt;http://underscorejs.org&gt;</span>
<span class='covered'>   * (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.</span>
<span class='covered'>   * Available under MIT license &lt;http://lodash.com/license&gt;</span>
<span class='covered'>   */</span>
<span class='covered'>  ;(function(window, undefined) {</span>
<span class='covered'>  </span>
<span class='covered'>    /** Detect free variable `exports` */</span>
<span class='covered'>    var freeExports = typeof exports == &#39;object&#39; &amp;&amp; exports;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Detect free variable `global` and use it as `window` */</span>
<span class='covered'>    var freeGlobal = typeof global == &#39;object&#39; &amp;&amp; global;</span>
<span class='covered'>    if (freeGlobal.global === freeGlobal) {</span>
<span class='covered'>      window = freeGlobal;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used for array and object method references */</span>
<span class='covered'>    var arrayRef = [],</span>
<span class='covered'>        // avoid a Closure Compiler bug by creatively creating an object</span>
<span class='covered'>        objectRef = new function(){};</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to generate unique IDs */</span>
<span class='covered'>    var idCounter = 0;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used internally to indicate various things */</span>
<span class='covered'>    var indicatorObject = objectRef;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used by `cachedContains` as the default size when optimizations are enabled for large arrays */</span>
<span class='covered'>    var largeArraySize = 30;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to restore the original `_` reference in `noConflict` */</span>
<span class='covered'>    var oldDash = window._;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to detect template delimiter values that require a with-statement */</span>
<span class='covered'>    var reComplexDelimiter = /[-?+=!~*%&amp;^&lt;&gt;|{(\/]|\[\D|\b(?:delete|in|instanceof|new|typeof|void)\b/;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to match HTML entities */</span>
<span class='covered'>    var reEscapedHtml = /&amp;(?:amp|lt|gt|quot|#x27);/g;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to match empty string literals in compiled template source */</span>
<span class='covered'>    var reEmptyStringLeading = /\b__p \+= &#39;&#39;;/g,</span>
<span class='covered'>        reEmptyStringMiddle = /\b(__p \+=) &#39;&#39; \+/g,</span>
<span class='covered'>        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n&#39;&#39;;/g;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to match regexp flags from their coerced string values */</span>
<span class='covered'>    var reFlags = /\w*$/;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to insert the data object variable into compiled template source */</span>
<span class='covered'>    var reInsertVariable = /(?:__e|__t = )\(\s*(?![\d\s&quot;&#39;]|this\.)/g;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to detect if a method is native */</span>
<span class='covered'>    var reNative = RegExp(&#39;^&#39; +</span>
<span class='covered'>      (objectRef.valueOf + &#39;&#39;)</span>
<span class='covered'>        .replace(/[.*+?^=!:${}()|[\]\/\\]/g, &#39;\\$&amp;&#39;)</span>
<span class='covered'>        .replace(/valueOf|for [^\]]+/g, &#39;.+?&#39;) + &#39;$&#39;</span>
<span class='covered'>    );</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Used to match ES6 template delimiters</span>
<span class='covered'>     * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6</span>
<span class='covered'>     */</span>
<span class='covered'>    var reEsTemplate = /\$\{((?:(?=\\?)\\?[\s\S])*?)}/g;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to match &quot;interpolate&quot; template delimiters */</span>
<span class='covered'>    var reInterpolate = /&lt;%=([\s\S]+?)%&gt;/g;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to ensure capturing order of template delimiters */</span>
<span class='covered'>    var reNoMatch = /($^)/;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to match HTML characters */</span>
<span class='covered'>    var reUnescapedHtml = /[&amp;&lt;&gt;&quot;&#39;]/g;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to match unescaped characters in compiled string literals */</span>
<span class='covered'>    var reUnescapedString = /[&#39;\n\r\t\u2028\u2029\\]/g;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to fix the JScript [[DontEnum]] bug */</span>
<span class='covered'>    var shadowed = [</span>
<span class='covered'>      &#39;constructor&#39;, &#39;hasOwnProperty&#39;, &#39;isPrototypeOf&#39;, &#39;propertyIsEnumerable&#39;,</span>
<span class='covered'>      &#39;toLocaleString&#39;, &#39;toString&#39;, &#39;valueOf&#39;</span>
<span class='covered'>    ];</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to make template sourceURLs easier to identify */</span>
<span class='covered'>    var templateCounter = 0;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Native method shortcuts */</span>
<span class='covered'>    var ceil = Math.ceil,</span>
<span class='covered'>        concat = arrayRef.concat,</span>
<span class='covered'>        floor = Math.floor,</span>
<span class='covered'>        getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) &amp;&amp; getPrototypeOf,</span>
<span class='covered'>        hasOwnProperty = objectRef.hasOwnProperty,</span>
<span class='covered'>        push = arrayRef.push,</span>
<span class='covered'>        propertyIsEnumerable = objectRef.propertyIsEnumerable,</span>
<span class='covered'>        slice = arrayRef.slice,</span>
<span class='covered'>        toString = objectRef.toString;</span>
<span class='covered'>  </span>
<span class='covered'>    /* Native method shortcuts for methods with the same name as other `lodash` methods */</span>
<span class='covered'>    var nativeBind = reNative.test(nativeBind = slice.bind) &amp;&amp; nativeBind,</span>
<span class='covered'>        nativeIsArray = reNative.test(nativeIsArray = Array.isArray) &amp;&amp; nativeIsArray,</span>
<span class='covered'>        nativeIsFinite = window.isFinite,</span>
<span class='covered'>        nativeIsNaN = window.isNaN,</span>
<span class='covered'>        nativeKeys = reNative.test(nativeKeys = Object.keys) &amp;&amp; nativeKeys,</span>
<span class='covered'>        nativeMax = Math.max,</span>
<span class='covered'>        nativeMin = Math.min,</span>
<span class='covered'>        nativeRandom = Math.random;</span>
<span class='covered'>  </span>
<span class='covered'>    /** `Object#toString` result shortcuts */</span>
<span class='covered'>    var argsClass = &#39;[object Arguments]&#39;,</span>
<span class='covered'>        arrayClass = &#39;[object Array]&#39;,</span>
<span class='covered'>        boolClass = &#39;[object Boolean]&#39;,</span>
<span class='covered'>        dateClass = &#39;[object Date]&#39;,</span>
<span class='covered'>        funcClass = &#39;[object Function]&#39;,</span>
<span class='covered'>        numberClass = &#39;[object Number]&#39;,</span>
<span class='covered'>        objectClass = &#39;[object Object]&#39;,</span>
<span class='covered'>        regexpClass = &#39;[object RegExp]&#39;,</span>
<span class='covered'>        stringClass = &#39;[object String]&#39;;</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Detect the JScript [[DontEnum]] bug:</span>
<span class='covered'>     *</span>
<span class='covered'>     * In IE &lt; 9 an objects own properties, shadowing non-enumerable ones, are</span>
<span class='covered'>     * made non-enumerable as well.</span>
<span class='covered'>     */</span>
<span class='covered'>    var hasDontEnumBug;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Detect if own properties are iterated after inherited properties (IE &lt; 9) */</span>
<span class='covered'>    var iteratesOwnLast;</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Detect if `Array#shift` and `Array#splice` augment array-like objects</span>
<span class='covered'>     * incorrectly:</span>
<span class='covered'>     *</span>
<span class='covered'>     * Firefox &lt; 10, IE compatibility mode, and IE &lt; 9 have buggy Array `shift()`</span>
<span class='covered'>     * and `splice()` functions that fail to remove the last element, `value[0]`,</span>
<span class='covered'>     * of array-like objects even though the `length` property is set to `0`.</span>
<span class='covered'>     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`</span>
<span class='covered'>     * is buggy regardless of mode in IE &lt; 9 and buggy in compatibility mode in IE 9.</span>
<span class='covered'>     */</span>
<span class='covered'>    var hasObjectSpliceBug = (hasObjectSpliceBug = { &#39;0&#39;: 1, &#39;length&#39;: 1 },</span>
<span class='covered'>      arrayRef.splice.call(hasObjectSpliceBug, 0, 1), hasObjectSpliceBug[0]);</span>
<span class='covered'>  </span>
<span class='covered'>    /** Detect if an `arguments` object&#39;s indexes are non-enumerable (IE &lt; 9) */</span>
<span class='covered'>    var noArgsEnum = true;</span>
<span class='covered'>  </span>
<span class='covered'>    (function() {</span>
<span class='covered'>      var props = [];</span>
<span class='covered'>      function ctor() { this.x = 1; }</span>
<span class='covered'>      ctor.prototype = { &#39;valueOf&#39;: 1, &#39;y&#39;: 1 };</span>
<span class='covered'>      for (var prop in new ctor) { props.push(prop); }</span>
<span class='covered'>      for (prop in arguments) { noArgsEnum = !prop; }</span>
<span class='covered'>  </span>
<span class='covered'>      hasDontEnumBug = !/valueOf/.test(props);</span>
<span class='covered'>      iteratesOwnLast = props[0] != &#39;x&#39;;</span>
<span class='covered'>    }(1));</span>
<span class='covered'>  </span>
<span class='covered'>    /** Detect if an `arguments` object&#39;s [[Class]] is unresolvable (Firefox &lt; 4, IE &lt; 9) */</span>
<span class='covered'>    var noArgsClass = !isArguments(arguments);</span>
<span class='covered'>  </span>
<span class='covered'>    /** Detect if `Array#slice` cannot be used to convert strings to arrays (Opera &lt; 10.52) */</span>
<span class='covered'>    var noArraySliceOnStrings = slice.call(&#39;x&#39;)[0] != &#39;x&#39;;</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Detect lack of support for accessing string characters by index:</span>
<span class='covered'>     *</span>
<span class='covered'>     * IE &lt; 8 can&#39;t access characters by index and IE 8 can only access</span>
<span class='covered'>     * characters by index on string literals.</span>
<span class='covered'>     */</span>
<span class='covered'>    var noCharByIndex = (&#39;x&#39;[0] + Object(&#39;x&#39;)[0]) != &#39;xx&#39;;</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Detect if a node&#39;s [[Class]] is unresolvable (IE &lt; 9)</span>
<span class='covered'>     * and that the JS engine won&#39;t error when attempting to coerce an object to</span>
<span class='covered'>     * a string without a `toString` property value of `typeof` &quot;function&quot;.</span>
<span class='covered'>     */</span>
<span class='covered'>    try {</span>
<span class='partial'>      var noNodeClass = ({ &#39;toString&#39;: 0 } + &#39;&#39;, <span class='partialuncovered'>toString.call(window.document || 0) </span><span class='partialuncovered'>window.document || 0)</span> == objectClass);</span>
<span class='covered'>    } catch(e) { }</span>
<span class='covered'>  </span>
<span class='covered'>    /* Detect if `Function#bind` exists and is inferred to be fast (all but V8) */</span>
<span class='covered'>    var isBindFast = nativeBind &amp;&amp; /\n|Opera/.test(nativeBind + toString.call(window.opera));</span>
<span class='covered'>  </span>
<span class='covered'>    /* Detect if `Object.keys` exists and is inferred to be fast (IE, Opera, V8) */</span>
<span class='covered'>    var isKeysFast = nativeKeys &amp;&amp; /^.+$|true/.test(nativeKeys + !!window.attachEvent);</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Detect if sourceURL syntax is usable without erroring:</span>
<span class='covered'>     *</span>
<span class='covered'>     * The JS engine in Adobe products, like InDesign, will throw a syntax error</span>
<span class='covered'>     * when it encounters a single line comment beginning with the `@` symbol.</span>
<span class='covered'>     *</span>
<span class='covered'>     * The JS engine in Narwhal will generate the function `function anonymous(){//}`</span>
<span class='covered'>     * and throw a syntax error.</span>
<span class='covered'>     *</span>
<span class='covered'>     * Avoid comments beginning `@` symbols in IE because they are part of its</span>
<span class='covered'>     * non-standard conditional compilation support.</span>
<span class='covered'>     * http://msdn.microsoft.com/en-us/library/121hztk3(v=vs.94).aspx</span>
<span class='covered'>     */</span>
<span class='covered'>    try {</span>
<span class='covered'>      var useSourceURL = (Function(&#39;//@&#39;)(), !window.attachEvent);</span>
<span class='covered'>    } catch(e) { }</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to identify object classifications that `_.clone` supports */</span>
<span class='covered'>    var cloneableClasses = {};</span>
<span class='covered'>    cloneableClasses[argsClass] = cloneableClasses[funcClass] = false;</span>
<span class='covered'>    cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] =</span>
<span class='covered'>    cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] =</span>
<span class='covered'>    cloneableClasses[stringClass] = true;</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to determine if values are of the language type Object */</span>
<span class='covered'>    var objectTypes = {</span>
<span class='covered'>      &#39;boolean&#39;: false,</span>
<span class='covered'>      &#39;function&#39;: true,</span>
<span class='covered'>      &#39;object&#39;: true,</span>
<span class='covered'>      &#39;number&#39;: false,</span>
<span class='covered'>      &#39;string&#39;: false,</span>
<span class='covered'>      &#39;undefined&#39;: false</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to escape characters for inclusion in compiled string literals */</span>
<span class='covered'>    var stringEscapes = {</span>
<span class='covered'>      &#39;\\&#39;: &#39;\\&#39;,</span>
<span class='covered'>      &quot;&#39;&quot;: &quot;&#39;&quot;,</span>
<span class='covered'>      &#39;\n&#39;: &#39;n&#39;,</span>
<span class='covered'>      &#39;\r&#39;: &#39;r&#39;,</span>
<span class='covered'>      &#39;\t&#39;: &#39;t&#39;,</span>
<span class='covered'>      &#39;\u2028&#39;: &#39;u2028&#39;,</span>
<span class='covered'>      &#39;\u2029&#39;: &#39;u2029&#39;</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * The `lodash` function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @name _</span>
<span class='covered'>     * @constructor</span>
<span class='covered'>     * @category Chaining</span>
<span class='covered'>     * @param {Mixed} value The value to wrap in a `lodash` instance.</span>
<span class='covered'>     * @returns {Object} Returns a `lodash` instance.</span>
<span class='covered'>     */</span>
<span class='covered'>    function lodash(value) {</span>
<span class='covered'>      // exit early if already wrapped</span>
<span class='covered'>      if (value &amp;&amp; value.__wrapped__) {</span>
<span class='uncovered'>        return value;</span>
<span class='covered'>      }</span>
<span class='covered'>      // allow invoking `lodash` without the `new` operator</span>
<span class='covered'>      if (!(this instanceof lodash)) {</span>
<span class='uncovered'>        return new lodash(value);</span>
<span class='covered'>      }</span>
<span class='covered'>      this.__wrapped__ = value;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * By default, the template delimiters used by Lo-Dash are similar to those in</span>
<span class='covered'>     * embedded Ruby (ERB). Change the following template settings to use alternative</span>
<span class='covered'>     * delimiters.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @type Object</span>
<span class='covered'>     */</span>
<span class='covered'>    lodash.templateSettings = {</span>
<span class='covered'>  </span>
<span class='covered'>      /**</span>
<span class='covered'>       * Used to detect `data` property values to be HTML-escaped.</span>
<span class='covered'>       *</span>
<span class='covered'>       * @static</span>
<span class='covered'>       * @memberOf _.templateSettings</span>
<span class='covered'>       * @type RegExp</span>
<span class='covered'>       */</span>
<span class='covered'>      &#39;escape&#39;: /&lt;%-([\s\S]+?)%&gt;/g,</span>
<span class='covered'>  </span>
<span class='covered'>      /**</span>
<span class='covered'>       * Used to detect code to be evaluated.</span>
<span class='covered'>       *</span>
<span class='covered'>       * @static</span>
<span class='covered'>       * @memberOf _.templateSettings</span>
<span class='covered'>       * @type RegExp</span>
<span class='covered'>       */</span>
<span class='covered'>      &#39;evaluate&#39;: /&lt;%([\s\S]+?)%&gt;/g,</span>
<span class='covered'>  </span>
<span class='covered'>      /**</span>
<span class='covered'>       * Used to detect `data` property values to inject.</span>
<span class='covered'>       *</span>
<span class='covered'>       * @static</span>
<span class='covered'>       * @memberOf _.templateSettings</span>
<span class='covered'>       * @type RegExp</span>
<span class='covered'>       */</span>
<span class='covered'>      &#39;interpolate&#39;: reInterpolate,</span>
<span class='covered'>  </span>
<span class='covered'>      /**</span>
<span class='covered'>       * Used to reference the data object in the template text.</span>
<span class='covered'>       *</span>
<span class='covered'>       * @static</span>
<span class='covered'>       * @memberOf _.templateSettings</span>
<span class='covered'>       * @type String</span>
<span class='covered'>       */</span>
<span class='covered'>      &#39;variable&#39;: &#39;&#39;</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * The template used to create iterator functions.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Obect} data The data object used to populate the text.</span>
<span class='covered'>     * @returns {String} Returns the interpolated text.</span>
<span class='covered'>     */</span>
<span class='covered'>    var iteratorTemplate = template(</span>
<span class='covered'>      // conditional strict mode</span>
<span class='covered'>      &#39;&lt;% if (obj.useStrict) { %&gt;\&#39;use strict\&#39;;\n&lt;% } %&gt;&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // the `iteratee` may be reassigned by the `top` snippet</span>
<span class='covered'>      &#39;var index, value, iteratee = &lt;%= firstArg %&gt;, &#39; +</span>
<span class='covered'>      // assign the `result` variable an initial value</span>
<span class='covered'>      &#39;result = &lt;%= firstArg %&gt;;\n&#39; +</span>
<span class='covered'>      // exit early if the first argument is falsey</span>
<span class='covered'>      &#39;if (!&lt;%= firstArg %&gt;) return result;\n&#39; +</span>
<span class='covered'>      // add code before the iteration branches</span>
<span class='covered'>      &#39;&lt;%= top %&gt;;\n&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // array-like iteration:</span>
<span class='covered'>      &#39;&lt;% if (arrayLoop) { %&gt;&#39; +</span>
<span class='covered'>      &#39;var length = iteratee.length; index = -1;\n&#39; +</span>
<span class='covered'>      &#39;if (typeof length == \&#39;number\&#39;) {&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // add support for accessing string characters by index if needed</span>
<span class='covered'>      &#39;  &lt;% if (noCharByIndex) { %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  if (isString(iteratee)) {\n&#39; +</span>
<span class='covered'>      &#39;    iteratee = iteratee.split(\&#39;\&#39;)\n&#39; +</span>
<span class='covered'>      &#39;  }&#39; +</span>
<span class='covered'>      &#39;  &lt;% } %&gt;\n&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // iterate over the array-like value</span>
<span class='covered'>      &#39;  while (++index &lt; length) {\n&#39; +</span>
<span class='covered'>      &#39;    value = iteratee[index];\n&#39; +</span>
<span class='covered'>      &#39;    &lt;%= arrayLoop %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  }\n&#39; +</span>
<span class='covered'>      &#39;}\n&#39; +</span>
<span class='covered'>      &#39;else {&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // object iteration:</span>
<span class='covered'>      // add support for iterating over `arguments` objects if needed</span>
<span class='covered'>      &#39;  &lt;%  } else if (noArgsEnum) { %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  var length = iteratee.length; index = -1;\n&#39; +</span>
<span class='covered'>      &#39;  if (length &amp;&amp; isArguments(iteratee)) {\n&#39; +</span>
<span class='covered'>      &#39;    while (++index &lt; length) {\n&#39; +</span>
<span class='covered'>      &#39;      value = iteratee[index += \&#39;\&#39;];\n&#39; +</span>
<span class='covered'>      &#39;      &lt;%= objectLoop %&gt;\n&#39; +</span>
<span class='covered'>      &#39;    }\n&#39; +</span>
<span class='covered'>      &#39;  } else {&#39; +</span>
<span class='covered'>      &#39;  &lt;% } %&gt;&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // Firefox &lt; 3.6, Opera &gt; 9.50 - Opera &lt; 11.60, and Safari &lt; 5.1</span>
<span class='covered'>      // (if the prototype or a property on the prototype has been set)</span>
<span class='covered'>      // incorrectly sets a function&#39;s `prototype` property [[Enumerable]]</span>
<span class='covered'>      // value to `true`. Because of this Lo-Dash standardizes on skipping</span>
<span class='covered'>      // the the `prototype` property of functions regardless of its</span>
<span class='covered'>      // [[Enumerable]] value.</span>
<span class='covered'>      &#39;  &lt;% if (!hasDontEnumBug) { %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  var skipProto = typeof iteratee == \&#39;function\&#39; &amp;&amp; \n&#39; +</span>
<span class='covered'>      &#39;    propertyIsEnumerable.call(iteratee, \&#39;prototype\&#39;);\n&#39; +</span>
<span class='covered'>      &#39;  &lt;% } %&gt;&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // iterate own properties using `Object.keys` if it&#39;s fast</span>
<span class='covered'>      &#39;  &lt;% if (isKeysFast &amp;&amp; useHas) { %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  var ownIndex = -1,\n&#39; +</span>
<span class='covered'>      &#39;      ownProps = objectTypes[typeof iteratee] ? nativeKeys(iteratee) : [],\n&#39; +</span>
<span class='covered'>      &#39;      length = ownProps.length;\n\n&#39; +</span>
<span class='covered'>      &#39;  while (++ownIndex &lt; length) {\n&#39; +</span>
<span class='covered'>      &#39;    index = ownProps[ownIndex];\n&#39; +</span>
<span class='covered'>      &#39;    &lt;% if (!hasDontEnumBug) { %&gt;if (!(skipProto &amp;&amp; index == \&#39;prototype\&#39;)) {\n  &lt;% } %&gt;&#39; +</span>
<span class='covered'>      &#39;    value = iteratee[index];\n&#39; +</span>
<span class='covered'>      &#39;    &lt;%= objectLoop %&gt;\n&#39; +</span>
<span class='covered'>      &#39;    &lt;% if (!hasDontEnumBug) { %&gt;}\n&lt;% } %&gt;&#39; +</span>
<span class='covered'>      &#39;  }&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // else using a for-in loop</span>
<span class='covered'>      &#39;  &lt;% } else { %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  for (index in iteratee) {&lt;%&#39; +</span>
<span class='covered'>      &#39;    if (!hasDontEnumBug || useHas) { %&gt;\n    if (&lt;%&#39; +</span>
<span class='covered'>      &#39;      if (!hasDontEnumBug) { %&gt;!(skipProto &amp;&amp; index == \&#39;prototype\&#39;)&lt;% }&#39; +</span>
<span class='covered'>      &#39;      if (!hasDontEnumBug &amp;&amp; useHas) { %&gt; &amp;&amp; &lt;% }&#39; +</span>
<span class='covered'>      &#39;      if (useHas) { %&gt;hasOwnProperty.call(iteratee, index)&lt;% }&#39; +</span>
<span class='covered'>      &#39;    %&gt;) {&#39; +</span>
<span class='covered'>      &#39;    &lt;% } %&gt;\n&#39; +</span>
<span class='covered'>      &#39;    value = iteratee[index];\n&#39; +</span>
<span class='covered'>      &#39;    &lt;%= objectLoop %&gt;;&#39; +</span>
<span class='covered'>      &#39;    &lt;% if (!hasDontEnumBug || useHas) { %&gt;\n    }&lt;% } %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  }&#39; +</span>
<span class='covered'>      &#39;  &lt;% } %&gt;&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // Because IE &lt; 9 can&#39;t set the `[[Enumerable]]` attribute of an</span>
<span class='covered'>      // existing property and the `constructor` property of a prototype</span>
<span class='covered'>      // defaults to non-enumerable, Lo-Dash skips the `constructor`</span>
<span class='covered'>      // property when it infers it&#39;s iterating over a `prototype` object.</span>
<span class='covered'>      &#39;  &lt;% if (hasDontEnumBug) { %&gt;\n\n&#39; +</span>
<span class='covered'>      &#39;  var ctor = iteratee.constructor;\n&#39; +</span>
<span class='covered'>      &#39;    &lt;% for (var k = 0; k &lt; 7; k++) { %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  index = \&#39;&lt;%= shadowed[k] %&gt;\&#39;;\n&#39; +</span>
<span class='covered'>      &#39;  if (&lt;%&#39; +</span>
<span class='covered'>      &#39;      if (shadowed[k] == \&#39;constructor\&#39;) {&#39; +</span>
<span class='covered'>      &#39;        %&gt;!(ctor &amp;&amp; ctor.prototype === iteratee) &amp;&amp; &lt;%&#39; +</span>
<span class='covered'>      &#39;      } %&gt;hasOwnProperty.call(iteratee, index)) {\n&#39; +</span>
<span class='covered'>      &#39;    value = iteratee[index];\n&#39; +</span>
<span class='covered'>      &#39;    &lt;%= objectLoop %&gt;\n&#39; +</span>
<span class='covered'>      &#39;  }&#39; +</span>
<span class='covered'>      &#39;    &lt;% } %&gt;&#39; +</span>
<span class='covered'>      &#39;  &lt;% } %&gt;&#39; +</span>
<span class='covered'>      &#39;  &lt;% if (arrayLoop || noArgsEnum) { %&gt;\n}&lt;% } %&gt;\n&#39; +</span>
<span class='covered'>  </span>
<span class='covered'>      // add code to the bottom of the iteration function</span>
<span class='covered'>      &#39;&lt;%= bottom %&gt;;\n&#39; +</span>
<span class='covered'>      // finally, return the `result`</span>
<span class='covered'>      &#39;return result&#39;</span>
<span class='covered'>    );</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Reusable iterator options shared by `forEach`, `forIn`, and `forOwn`.</span>
<span class='covered'>     */</span>
<span class='covered'>    var forEachIteratorOptions = {</span>
<span class='covered'>      &#39;args&#39;: &#39;collection, callback, thisArg&#39;,</span>
<span class='covered'>      &#39;top&#39;: &#39;callback = createCallback(callback, thisArg)&#39;,</span>
<span class='covered'>      &#39;arrayLoop&#39;: &#39;if (callback(value, index, collection) === false) return result&#39;,</span>
<span class='covered'>      &#39;objectLoop&#39;: &#39;if (callback(value, index, collection) === false) return result&#39;</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /** Reusable iterator options for `defaults`, and `extend` */</span>
<span class='covered'>    var extendIteratorOptions = {</span>
<span class='covered'>      &#39;useHas&#39;: false,</span>
<span class='covered'>      &#39;args&#39;: &#39;object&#39;,</span>
<span class='covered'>      &#39;top&#39;:</span>
<span class='covered'>        &#39;for (var argsIndex = 1, argsLength = arguments.length; argsIndex &lt; argsLength; argsIndex++) {\n&#39; +</span>
<span class='covered'>        &#39;  if (iteratee = arguments[argsIndex]) {&#39;,</span>
<span class='covered'>      &#39;objectLoop&#39;: &#39;result[index] = value&#39;,</span>
<span class='covered'>      &#39;bottom&#39;: &#39;  }\n}&#39;</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /** Reusable iterator options for `forIn` and `forOwn` */</span>
<span class='covered'>    var forOwnIteratorOptions = {</span>
<span class='covered'>      &#39;arrayLoop&#39;: null</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function optimized to search large arrays for a given `value`,</span>
<span class='covered'>     * starting at `fromIndex`, using strict equality for comparisons, i.e. `===`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Array} array The array to search.</span>
<span class='covered'>     * @param {Mixed} value The value to search for.</span>
<span class='covered'>     * @param {Number} [fromIndex=0] The index to search from.</span>
<span class='covered'>     * @param {Number} [largeSize=30] The length at which an array is considered large.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if `value` is found, else `false`.</span>
<span class='covered'>     */</span>
<span class='covered'>    function cachedContains(array, fromIndex, largeSize) {</span>
<span class='uncovered'>      fromIndex || (fromIndex = 0);</span>
<span class='covered'>  </span>
<span class='uncovered'>      var length = array.length,</span>
<span class='uncovered'>          isLarge = (length - fromIndex) &gt;= (largeSize || largeArraySize);</span>
<span class='covered'>  </span>
<span class='covered'>      if (isLarge) {</span>
<span class='uncovered'>        var cache = {},</span>
<span class='uncovered'>            index = fromIndex - 1;</span>
<span class='covered'>  </span>
<span class='uncovered'>        while (++index &lt; length) {</span>
<span class='covered'>          // manually coerce `value` to a string because `hasOwnProperty`, in some</span>
<span class='covered'>          // older versions of Firefox, coerces objects incorrectly</span>
<span class='uncovered'>          var key = array[index] + &#39;&#39;;</span>
<span class='uncovered'>          (hasOwnProperty.call(cache, key) ? cache[key] : (cache[key] = [])).push(array[index]);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return function(value) {</span>
<span class='uncovered'>        if (isLarge) {</span>
<span class='uncovered'>          var key = value + &#39;&#39;;</span>
<span class='uncovered'>          return hasOwnProperty.call(cache, key) &amp;&amp; indexOf(cache[key], value) &gt; -1;</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        return indexOf(array, value, fromIndex) &gt; -1;</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Used by `_.max` and `_.min` as the default `callback` when a given</span>
<span class='covered'>     * `collection` is a string value.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {String} value The character to inspect.</span>
<span class='covered'>     * @returns {Number} Returns the code unit of given character.</span>
<span class='covered'>     */</span>
<span class='covered'>    function charAtCallback(value) {</span>
<span class='uncovered'>      return value.charCodeAt(0);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Used by `sortBy` to compare transformed `collection` values, stable sorting</span>
<span class='covered'>     * them in ascending order.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Object} a The object to compare to `b`.</span>
<span class='covered'>     * @param {Object} b The object to compare to `a`.</span>
<span class='covered'>     * @returns {Number} Returns the sort order indicator of `1` or `-1`.</span>
<span class='covered'>     */</span>
<span class='covered'>    function compareAscending(a, b) {</span>
<span class='uncovered'>      var ai = a.index,</span>
<span class='uncovered'>          bi = b.index;</span>
<span class='covered'>  </span>
<span class='uncovered'>      a = a.criteria;</span>
<span class='uncovered'>      b = b.criteria;</span>
<span class='covered'>  </span>
<span class='covered'>      // ensure a stable sort in V8 and other engines</span>
<span class='covered'>      // http://code.google.com/p/v8/issues/detail?id=90</span>
<span class='uncovered'>      if (a !== b) {</span>
<span class='uncovered'>        if (a &gt; b || a === undefined) {</span>
<span class='uncovered'>          return 1;</span>
<span class='covered'>        }</span>
<span class='uncovered'>        if (a &lt; b || b === undefined) {</span>
<span class='uncovered'>          return -1;</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return ai &lt; bi ? -1 : 1;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that, when called, invokes `func` with the `this`</span>
<span class='covered'>     * binding of `thisArg` and prepends any `partailArgs` to the arguments passed</span>
<span class='covered'>     * to the bound function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Function|String} func The function to bind or the method name.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `func`.</span>
<span class='covered'>     * @param {Array} partialArgs An array of arguments to be partially applied.</span>
<span class='covered'>     * @returns {Function} Returns the new bound function.</span>
<span class='covered'>     */</span>
<span class='covered'>    function createBound(func, thisArg, partialArgs) {</span>
<span class='uncovered'>      var isFunc = isFunction(func),</span>
<span class='uncovered'>          isPartial = !partialArgs,</span>
<span class='uncovered'>          methodName = func;</span>
<span class='covered'>  </span>
<span class='covered'>      // juggle arguments</span>
<span class='covered'>      if (isPartial) {</span>
<span class='uncovered'>        partialArgs = thisArg;</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      function bound() {</span>
<span class='covered'>        // `Function#bind` spec</span>
<span class='covered'>        // http://es5.github.com/#x15.3.4.5</span>
<span class='uncovered'>        var args = arguments,</span>
<span class='uncovered'>            thisBinding = isPartial ? this : thisArg;</span>
<span class='covered'>  </span>
<span class='covered'>        if (!isFunc) {</span>
<span class='uncovered'>          func = thisArg[methodName];</span>
<span class='covered'>        }</span>
<span class='covered'>        if (partialArgs.length) {</span>
<span class='uncovered'>          args = args.length</span>
<span class='uncovered'>            ? partialArgs.concat(slice.call(args))</span>
<span class='uncovered'>            : partialArgs;</span>
<span class='covered'>        }</span>
<span class='uncovered'>        if (this instanceof bound) {</span>
<span class='covered'>          // get `func` instance if `bound` is invoked in a `new` expression</span>
<span class='uncovered'>          noop.prototype = func.prototype;</span>
<span class='uncovered'>          thisBinding = new noop;</span>
<span class='covered'>  </span>
<span class='covered'>          // mimic the constructor&#39;s `return` behavior</span>
<span class='covered'>          // http://es5.github.com/#x13.2.2</span>
<span class='uncovered'>          var result = func.apply(thisBinding, args);</span>
<span class='uncovered'>          return isObject(result)</span>
<span class='uncovered'>            ? result</span>
<span class='uncovered'>            : thisBinding</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        return func.apply(thisBinding, args);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return bound;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Produces an iteration callback bound to an optional `thisArg`. If `func` is</span>
<span class='covered'>     * a property name, the callback will return the property value for a given element.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Function|String} [func=identity|property] The function called per</span>
<span class='covered'>     * iteration or property name to query.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Function} Returns a callback function.</span>
<span class='covered'>     */</span>
<span class='covered'>    function createCallback(func, thisArg) {</span>
<span class='covered'>      if (!func) {</span>
<span class='uncovered'>        return identity;</span>
<span class='covered'>      }</span>
<span class='covered'>      if (typeof func != &#39;function&#39;) {</span>
<span class='uncovered'>        return function(object) {</span>
<span class='uncovered'>          return object[func];</span>
<span class='uncovered'>        };</span>
<span class='covered'>      }</span>
<span class='covered'>      if (thisArg !== undefined) {</span>
<span class='uncovered'>        return function(value, index, object) {</span>
<span class='uncovered'>          return func.call(thisArg, value, index, object);</span>
<span class='uncovered'>        };</span>
<span class='covered'>      }</span>
<span class='covered'>      return func;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates compiled iteration functions.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Object} [options1, options2, ...] The compile options object(s).</span>
<span class='covered'>     *  useHas - A boolean to specify using `hasOwnProperty` checks in the object loop.</span>
<span class='covered'>     *  args - A string of comma separated arguments the iteration function will accept.</span>
<span class='covered'>     *  top - A string of code to execute before the iteration branches.</span>
<span class='covered'>     *  arrayLoop - A string of code to execute in the array loop.</span>
<span class='covered'>     *  objectLoop - A string of code to execute in the object loop.</span>
<span class='covered'>     *  bottom - A string of code to execute after the iteration branches.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @returns {Function} Returns the compiled function.</span>
<span class='covered'>     */</span>
<span class='covered'>    function createIterator() {</span>
<span class='covered'>      var data = {</span>
<span class='covered'>        &#39;arrayLoop&#39;: &#39;&#39;,</span>
<span class='covered'>        &#39;bottom&#39;: &#39;&#39;,</span>
<span class='covered'>        &#39;hasDontEnumBug&#39;: hasDontEnumBug,</span>
<span class='covered'>        &#39;isKeysFast&#39;: isKeysFast,</span>
<span class='covered'>        &#39;objectLoop&#39;: &#39;&#39;,</span>
<span class='covered'>        &#39;noArgsEnum&#39;: noArgsEnum,</span>
<span class='covered'>        &#39;noCharByIndex&#39;: noCharByIndex,</span>
<span class='covered'>        &#39;shadowed&#39;: shadowed,</span>
<span class='covered'>        &#39;top&#39;: &#39;&#39;,</span>
<span class='covered'>        &#39;useHas&#39;: true</span>
<span class='covered'>      };</span>
<span class='covered'>  </span>
<span class='covered'>      // merge options into a template data object</span>
<span class='covered'>      for (var object, index = 0; object = arguments[index]; index++) {</span>
<span class='covered'>        for (var key in object) {</span>
<span class='covered'>          data[key] = object[key];</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      var args = data.args;</span>
<span class='covered'>      data.firstArg = /^[^,]+/.exec(args)[0];</span>
<span class='covered'>  </span>
<span class='covered'>      // create the function factory</span>
<span class='covered'>      var factory = Function(</span>
<span class='covered'>          &#39;createCallback, hasOwnProperty, isArguments, isString, objectTypes, &#39; +</span>
<span class='covered'>          &#39;nativeKeys, propertyIsEnumerable&#39;,</span>
<span class='covered'>        &#39;return function(&#39; + args + &#39;) {\n&#39; + iteratorTemplate(data) + &#39;\n}&#39;</span>
<span class='covered'>      );</span>
<span class='covered'>      // return the compiled function</span>
<span class='covered'>      return factory(</span>
<span class='covered'>        createCallback, hasOwnProperty, isArguments, isString, objectTypes,</span>
<span class='covered'>        nativeKeys, propertyIsEnumerable</span>
<span class='covered'>      );</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Used by `template` to escape characters for inclusion in compiled</span>
<span class='covered'>     * string literals.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {String} match The matched character to escape.</span>
<span class='covered'>     * @returns {String} Returns the escaped character.</span>
<span class='covered'>     */</span>
<span class='covered'>    function escapeStringChar(match) {</span>
<span class='covered'>      return &#39;\\&#39; + stringEscapes[match];</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Used by `escape` to convert characters to HTML entities.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {String} match The matched character to escape.</span>
<span class='covered'>     * @returns {String} Returns the escaped character.</span>
<span class='covered'>     */</span>
<span class='covered'>    function escapeHtmlChar(match) {</span>
<span class='uncovered'>      return htmlEscapes[match];</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * A no-operation function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     */</span>
<span class='covered'>    function noop() {</span>
<span class='covered'>      // no operation performed</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Used by `unescape` to convert HTML entities to characters.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {String} match The matched character to unescape.</span>
<span class='covered'>     * @returns {String} Returns the unescaped character.</span>
<span class='covered'>     */</span>
<span class='covered'>    function unescapeHtmlChar(match) {</span>
<span class='uncovered'>      return htmlUnescapes[match];</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is an `arguments` object.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is an `arguments` object, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * (function() { return _.isArguments(arguments); })(1, 2, 3);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isArguments([1, 2, 3]);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function isArguments(value) {</span>
<span class='covered'>      return toString.call(value) == argsClass;</span>
<span class='covered'>    }</span>
<span class='covered'>    // fallback for browsers that can&#39;t detect `arguments` objects by [[Class]]</span>
<span class='covered'>    if (noArgsClass) {</span>
<span class='uncovered'>      isArguments = function(value) {</span>
<span class='uncovered'>        return value ? hasOwnProperty.call(value, &#39;callee&#39;) : false;</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Iterates over `object`&#39;s own and inherited enumerable properties, executing</span>
<span class='covered'>     * the `callback` for each property. The `callback` is bound to `thisArg` and</span>
<span class='covered'>     * invoked with three arguments; (value, key, object). Callbacks may exit iteration</span>
<span class='covered'>     * early by explicitly returning `false`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to iterate over.</span>
<span class='covered'>     * @param {Function} callback The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Object} Returns `object`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * function Dog(name) {</span>
<span class='covered'>     *   this.name = name;</span>
<span class='covered'>     * }</span>
<span class='covered'>     *</span>
<span class='covered'>     * Dog.prototype.bark = function() {</span>
<span class='covered'>     *   alert(&#39;Woof, woof!&#39;);</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.forIn(new Dog(&#39;Dagny&#39;), function(value, key) {</span>
<span class='covered'>     *   alert(key);</span>
<span class='covered'>     * });</span>
<span class='covered'>     * // =&gt; alerts &#39;name&#39; and &#39;bark&#39; (order is not guaranteed)</span>
<span class='covered'>     */</span>
<span class='covered'>    var forIn = createIterator(forEachIteratorOptions, forOwnIteratorOptions, {</span>
<span class='covered'>      &#39;useHas&#39;: false</span>
<span class='covered'>    });</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Iterates over `object`&#39;s own enumerable properties, executing the `callback`</span>
<span class='covered'>     * for each property. The `callback` is bound to `thisArg` and invoked with three</span>
<span class='covered'>     * arguments; (value, key, object). Callbacks may exit iteration early by explicitly</span>
<span class='covered'>     * returning `false`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to iterate over.</span>
<span class='covered'>     * @param {Function} callback The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Object} Returns `object`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.forOwn({ &#39;0&#39;: &#39;zero&#39;, &#39;1&#39;: &#39;one&#39;, &#39;length&#39;: 2 }, function(num, key) {</span>
<span class='covered'>     *   alert(key);</span>
<span class='covered'>     * });</span>
<span class='covered'>     * // =&gt; alerts &#39;0&#39;, &#39;1&#39;, and &#39;length&#39; (order is not guaranteed)</span>
<span class='covered'>     */</span>
<span class='covered'>    var forOwn = createIterator(forEachIteratorOptions, forOwnIteratorOptions);</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * A fallback implementation of `isPlainObject` that checks if a given `value`</span>
<span class='covered'>     * is an object created by the `Object` constructor, assuming objects created</span>
<span class='covered'>     * by the `Object` constructor have no inherited enumerable properties and that</span>
<span class='covered'>     * there are no `Object.prototype` extensions.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.</span>
<span class='covered'>     */</span>
<span class='covered'>    function shimIsPlainObject(value) {</span>
<span class='covered'>      // avoid non-objects and false positives for `arguments` objects</span>
<span class='uncovered'>      var result = false;</span>
<span class='uncovered'>      if (!(value &amp;&amp; typeof value == &#39;object&#39;) || isArguments(value)) {</span>
<span class='uncovered'>        return result;</span>
<span class='covered'>      }</span>
<span class='covered'>      // IE &lt; 9 presents DOM nodes as `Object` objects except they have `toString`</span>
<span class='covered'>      // methods that are `typeof` &quot;string&quot; and still can coerce nodes to strings.</span>
<span class='covered'>      // Also check that the constructor is `Object` (i.e. `Object instanceof Object`)</span>
<span class='uncovered'>      var ctor = value.constructor;</span>
<span class='uncovered'>      if ((!noNodeClass || !(typeof value.toString != &#39;function&#39; &amp;&amp; typeof (value + &#39;&#39;) == &#39;string&#39;)) &amp;&amp;</span>
<span class='uncovered'>          (!isFunction(ctor) || ctor instanceof ctor)) {</span>
<span class='covered'>        // IE &lt; 9 iterates inherited properties before own properties. If the first</span>
<span class='covered'>        // iterated property is an object&#39;s own property then there are no inherited</span>
<span class='covered'>        // enumerable properties.</span>
<span class='covered'>        if (iteratesOwnLast) {</span>
<span class='uncovered'>          forIn(value, function(value, key, object) {</span>
<span class='uncovered'>            result = !hasOwnProperty.call(object, key);</span>
<span class='uncovered'>            return false;</span>
<span class='uncovered'>          });</span>
<span class='uncovered'>          return result === false;</span>
<span class='covered'>        }</span>
<span class='covered'>        // In most environments an object&#39;s own properties are iterated before</span>
<span class='covered'>        // its inherited properties. If the last iterated property is an object&#39;s</span>
<span class='covered'>        // own property then there are no inherited enumerable properties.</span>
<span class='uncovered'>        forIn(value, function(value, key) {</span>
<span class='uncovered'>          result = key;</span>
<span class='uncovered'>        });</span>
<span class='uncovered'>        return result === false || hasOwnProperty.call(value, result);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * A fallback implementation of `Object.keys` that produces an array of the</span>
<span class='covered'>     * given object&#39;s own enumerable property names.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @private</span>
<span class='covered'>     * @param {Object} object The object to inspect.</span>
<span class='covered'>     * @returns {Array} Returns a new array of property names.</span>
<span class='covered'>     */</span>
<span class='covered'>    function shimKeys(object) {</span>
<span class='uncovered'>      var result = [];</span>
<span class='uncovered'>      forOwn(object, function(value, key) {</span>
<span class='uncovered'>        result.push(key);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Used to convert characters to HTML entities:</span>
<span class='covered'>     *</span>
<span class='covered'>     * Though the `&gt;` character is escaped for symmetry, characters like `&gt;` and `/`</span>
<span class='covered'>     * don&#39;t require escaping in HTML and have no special meaning unless they&#39;re part</span>
<span class='covered'>     * of a tag or an unquoted attribute value.</span>
<span class='covered'>     * http://mathiasbynens.be/notes/ambiguous-ampersands (under &quot;semi-related fun fact&quot;)</span>
<span class='covered'>     */</span>
<span class='covered'>    var htmlEscapes = {</span>
<span class='covered'>      &#39;&amp;&#39;: &#39;&amp;amp;&#39;,</span>
<span class='covered'>      &#39;&lt;&#39;: &#39;&amp;lt;&#39;,</span>
<span class='covered'>      &#39;&gt;&#39;: &#39;&amp;gt;&#39;,</span>
<span class='covered'>      &#39;&quot;&#39;: &#39;&amp;quot;&#39;,</span>
<span class='covered'>      &quot;&#39;&quot;: &#39;&amp;#x27;&#39;</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /** Used to convert HTML entities to characters */</span>
<span class='covered'>    var htmlUnescapes = invert(htmlEscapes);</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a clone of `value`. If `deep` is `true`, all nested objects will</span>
<span class='covered'>     * also be cloned otherwise they will be assigned by reference. Functions, DOM</span>
<span class='covered'>     * nodes, `arguments` objects, and objects created by constructors other than</span>
<span class='covered'>     * `Object` are **not** cloned.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to clone.</span>
<span class='covered'>     * @param {Boolean} deep A flag to indicate a deep clone.</span>
<span class='covered'>     * @param- {Object} [guard] Internally used to allow this method to work with</span>
<span class='covered'>     *  others like `_.map` without using their callback `index` argument for `deep`.</span>
<span class='covered'>     * @param- {Array} [stackA=[]] Internally used to track traversed source objects.</span>
<span class='covered'>     * @param- {Array} [stackB=[]] Internally used to associate clones with their</span>
<span class='covered'>     *  source counterparts.</span>
<span class='covered'>     * @returns {Mixed} Returns the cloned `value`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var stooges = [</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60 }</span>
<span class='covered'>     * ];</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.clone({ &#39;name&#39;: &#39;moe&#39; });</span>
<span class='covered'>     * // =&gt; { &#39;name&#39;: &#39;moe&#39; }</span>
<span class='covered'>     *</span>
<span class='covered'>     * var shallow = _.clone(stooges);</span>
<span class='covered'>     * shallow[0] === stooges[0];</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * var deep = _.clone(stooges, true);</span>
<span class='covered'>     * shallow[0] === stooges[0];</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function clone(value, deep, guard, stackA, stackB) {</span>
<span class='uncovered'>      if (value == null) {</span>
<span class='uncovered'>        return value;</span>
<span class='covered'>      }</span>
<span class='covered'>      if (guard) {</span>
<span class='uncovered'>        deep = false;</span>
<span class='covered'>      }</span>
<span class='covered'>      // inspect [[Class]]</span>
<span class='uncovered'>      var isObj = isObject(value);</span>
<span class='covered'>      if (isObj) {</span>
<span class='covered'>        // don&#39;t clone `arguments` objects, functions, or non-object Objects</span>
<span class='uncovered'>        var className = toString.call(value);</span>
<span class='uncovered'>        if (!cloneableClasses[className] || (noArgsClass &amp;&amp; isArguments(value))) {</span>
<span class='uncovered'>          return value;</span>
<span class='covered'>        }</span>
<span class='uncovered'>        var isArr = className == arrayClass;</span>
<span class='uncovered'>        isObj = isArr || (className == objectClass ? isPlainObject(value) : isObj);</span>
<span class='covered'>      }</span>
<span class='covered'>      // shallow clone</span>
<span class='uncovered'>      if (!isObj || !deep) {</span>
<span class='covered'>        // don&#39;t clone functions</span>
<span class='uncovered'>        return isObj</span>
<span class='uncovered'>          ? (isArr ? slice.call(value) : extend({}, value))</span>
<span class='uncovered'>          : value;</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='uncovered'>      var ctor = value.constructor;</span>
<span class='covered'>      switch (className) {</span>
<span class='covered'>        case boolClass:</span>
<span class='covered'>        case dateClass:</span>
<span class='uncovered'>          return new ctor(+value);</span>
<span class='covered'>  </span>
<span class='covered'>        case numberClass:</span>
<span class='covered'>        case stringClass:</span>
<span class='uncovered'>          return new ctor(value);</span>
<span class='covered'>  </span>
<span class='covered'>        case regexpClass:</span>
<span class='uncovered'>          return ctor(value.source, reFlags.exec(value));</span>
<span class='covered'>      }</span>
<span class='covered'>      // check for circular references and return corresponding clone</span>
<span class='uncovered'>      stackA || (stackA = []);</span>
<span class='uncovered'>      stackB || (stackB = []);</span>
<span class='covered'>  </span>
<span class='uncovered'>      var length = stackA.length;</span>
<span class='uncovered'>      while (length--) {</span>
<span class='uncovered'>        if (stackA[length] == value) {</span>
<span class='uncovered'>          return stackB[length];</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      // init cloned object</span>
<span class='uncovered'>      var result = isArr ? ctor(value.length) : {};</span>
<span class='covered'>  </span>
<span class='covered'>      // add the source value to the stack of traversed objects</span>
<span class='covered'>      // and associate it with its clone</span>
<span class='uncovered'>      stackA.push(value);</span>
<span class='uncovered'>      stackB.push(result);</span>
<span class='covered'>  </span>
<span class='covered'>      // recursively populate clone (susceptible to call stack limits)</span>
<span class='uncovered'>      (isArr ? forEach : forOwn)(value, function(objValue, key) {</span>
<span class='uncovered'>        result[key] = clone(objValue, deep, null, stackA, stackB);</span>
<span class='uncovered'>      });</span>
<span class='covered'>  </span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Assigns enumerable properties of the default object(s) to the `destination`</span>
<span class='covered'>     * object for all `destination` properties that resolve to `null`/`undefined`.</span>
<span class='covered'>     * Once a property is set, additional defaults of the same property will be</span>
<span class='covered'>     * ignored.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The destination object.</span>
<span class='covered'>     * @param {Object} [default1, default2, ...] The default objects.</span>
<span class='covered'>     * @returns {Object} Returns the destination object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var iceCream = { &#39;flavor&#39;: &#39;chocolate&#39; };</span>
<span class='covered'>     * _.defaults(iceCream, { &#39;flavor&#39;: &#39;vanilla&#39;, &#39;sprinkles&#39;: &#39;rainbow&#39; });</span>
<span class='covered'>     * // =&gt; { &#39;flavor&#39;: &#39;chocolate&#39;, &#39;sprinkles&#39;: &#39;rainbow&#39; }</span>
<span class='covered'>     */</span>
<span class='covered'>    var defaults = createIterator(extendIteratorOptions, {</span>
<span class='covered'>      &#39;objectLoop&#39;: &#39;if (result[index] == null) &#39; + extendIteratorOptions.objectLoop</span>
<span class='covered'>    });</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Assigns enumerable properties of the source object(s) to the `destination`</span>
<span class='covered'>     * object. Subsequent sources will overwrite propery assignments of previous</span>
<span class='covered'>     * sources.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The destination object.</span>
<span class='covered'>     * @param {Object} [source1, source2, ...] The source objects.</span>
<span class='covered'>     * @returns {Object} Returns the destination object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.extend({ &#39;name&#39;: &#39;moe&#39; }, { &#39;age&#39;: 40 });</span>
<span class='covered'>     * // =&gt; { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 }</span>
<span class='covered'>     */</span>
<span class='covered'>    var extend = createIterator(extendIteratorOptions);</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a sorted array of all enumerable properties, own and inherited,</span>
<span class='covered'>     * of `object` that have function values.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias methods</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to inspect.</span>
<span class='covered'>     * @returns {Array} Returns a new array of property names that have function values.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.functions(_);</span>
<span class='covered'>     * // =&gt; [&#39;all&#39;, &#39;any&#39;, &#39;bind&#39;, &#39;bindAll&#39;, &#39;clone&#39;, &#39;compact&#39;, &#39;compose&#39;, ...]</span>
<span class='covered'>     */</span>
<span class='covered'>    function functions(object) {</span>
<span class='covered'>      var result = [];</span>
<span class='covered'>      forIn(object, function(value, key) {</span>
<span class='covered'>        if (isFunction(value)) {</span>
<span class='covered'>          result.push(key);</span>
<span class='covered'>        }</span>
<span class='covered'>      });</span>
<span class='covered'>      return result.sort();</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if the specified object `property` exists and is a direct property,</span>
<span class='covered'>     * instead of an inherited property.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to check.</span>
<span class='covered'>     * @param {String} property The property to check for.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if key is a direct property, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.has({ &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3 }, &#39;b&#39;);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function has(object, property) {</span>
<span class='uncovered'>      return object ? hasOwnProperty.call(object, property) : false;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an object composed of the inverted keys and values of the given `object`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to invert.</span>
<span class='covered'>     * @returns {Object} Returns the created inverted object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     *  _.invert({ &#39;first&#39;: &#39;Moe&#39;, &#39;second&#39;: &#39;Larry&#39;, &#39;third&#39;: &#39;Curly&#39; });</span>
<span class='covered'>     * // =&gt; { &#39;Moe&#39;: &#39;first&#39;, &#39;Larry&#39;: &#39;second&#39;, &#39;Curly&#39;: &#39;third&#39; } (order is not guaranteed)</span>
<span class='covered'>     */</span>
<span class='covered'>    function invert(object) {</span>
<span class='covered'>      var result = {};</span>
<span class='covered'>      forOwn(object, function(value, key) {</span>
<span class='covered'>        result[value] = key;</span>
<span class='covered'>      });</span>
<span class='covered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is an array.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is an array, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * (function() { return _.isArray(arguments); })();</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isArray([1, 2, 3]);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    var isArray = nativeIsArray || function(value) {</span>
<span class='uncovered'>      return toString.call(value) == arrayClass;</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is a boolean (`true` or `false`) value.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a boolean value, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isBoolean(null);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function isBoolean(value) {</span>
<span class='uncovered'>      return value === true || value === false || toString.call(value) == boolClass;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is a date.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a date, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isDate(new Date);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isDate(value) {</span>
<span class='uncovered'>      return toString.call(value) == dateClass;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is a DOM element.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a DOM element, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isElement(document.body);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isElement(value) {</span>
<span class='uncovered'>      return value ? value.nodeType === 1 : false;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a</span>
<span class='covered'>     * length of `0` and objects with no own enumerable properties are considered</span>
<span class='covered'>     * &quot;empty&quot;.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Array|Object|String} value The value to inspect.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is empty, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isEmpty([1, 2, 3]);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isEmpty({});</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isEmpty(&#39;&#39;);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isEmpty(value) {</span>
<span class='uncovered'>      var result = true;</span>
<span class='covered'>      if (!value) {</span>
<span class='uncovered'>        return result;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      var className = toString.call(value),</span>
<span class='uncovered'>          length = value.length;</span>
<span class='covered'>  </span>
<span class='uncovered'>      if ((className == arrayClass || className == stringClass ||</span>
<span class='uncovered'>          className == argsClass || (noArgsClass &amp;&amp; isArguments(value))) ||</span>
<span class='uncovered'>          (className == objectClass &amp;&amp; typeof length == &#39;number&#39; &amp;&amp; isFunction(value.splice))) {</span>
<span class='uncovered'>        return !length;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      forOwn(value, function() {</span>
<span class='uncovered'>        return (result = false);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Performs a deep comparison between two values to determine if they are</span>
<span class='covered'>     * equivalent to each other.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} a The value to compare.</span>
<span class='covered'>     * @param {Mixed} b The other value to compare.</span>
<span class='covered'>     * @param- {Object} [stackA=[]] Internally used track traversed `a` objects.</span>
<span class='covered'>     * @param- {Object} [stackB=[]] Internally used track traversed `b` objects.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the values are equvalent, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var moe = { &#39;name&#39;: &#39;moe&#39;, &#39;luckyNumbers&#39;: [13, 27, 34] };</span>
<span class='covered'>     * var clone = { &#39;name&#39;: &#39;moe&#39;, &#39;luckyNumbers&#39;: [13, 27, 34] };</span>
<span class='covered'>     *</span>
<span class='covered'>     * moe == clone;</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isEqual(moe, clone);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isEqual(a, b, stackA, stackB) {</span>
<span class='covered'>      // exit early for identical values</span>
<span class='uncovered'>      if (a === b) {</span>
<span class='covered'>        // treat `+0` vs. `-0` as not equal</span>
<span class='uncovered'>        return a !== 0 || (1 / a == 1 / b);</span>
<span class='covered'>      }</span>
<span class='covered'>      // a strict comparison is necessary because `null == undefined`</span>
<span class='uncovered'>      if (a == null || b == null) {</span>
<span class='uncovered'>        return a === b;</span>
<span class='covered'>      }</span>
<span class='covered'>      // compare [[Class]] names</span>
<span class='uncovered'>      var className = toString.call(a);</span>
<span class='uncovered'>      if (className != toString.call(b)) {</span>
<span class='uncovered'>        return false;</span>
<span class='covered'>      }</span>
<span class='covered'>      switch (className) {</span>
<span class='covered'>        case boolClass:</span>
<span class='covered'>        case dateClass:</span>
<span class='covered'>          // coerce dates and booleans to numbers, dates to milliseconds and booleans</span>
<span class='covered'>          // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal</span>
<span class='uncovered'>          return +a == +b;</span>
<span class='covered'>  </span>
<span class='covered'>        case numberClass:</span>
<span class='covered'>          // treat `NaN` vs. `NaN` as equal</span>
<span class='uncovered'>          return a != +a</span>
<span class='uncovered'>            ? b != +b</span>
<span class='uncovered'>            // but treat `+0` vs. `-0` as not equal</span>
<span class='uncovered'>            : (a == 0 ? (1 / a == 1 / b) : a == +b);</span>
<span class='covered'>  </span>
<span class='covered'>        case regexpClass:</span>
<span class='covered'>        case stringClass:</span>
<span class='covered'>          // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)</span>
<span class='covered'>          // treat string primitives and their corresponding object instances as equal</span>
<span class='uncovered'>          return a == b + &#39;&#39;;</span>
<span class='covered'>      }</span>
<span class='covered'>      // exit early, in older browsers, if `a` is array-like but not `b`</span>
<span class='uncovered'>      var isArr = className == arrayClass || className == argsClass;</span>
<span class='uncovered'>      if (noArgsClass &amp;&amp; !isArr &amp;&amp; (isArr = isArguments(a)) &amp;&amp; !isArguments(b)) {</span>
<span class='uncovered'>        return false;</span>
<span class='covered'>      }</span>
<span class='covered'>      if (!isArr) {</span>
<span class='covered'>        // unwrap any `lodash` wrapped values</span>
<span class='uncovered'>        if (a.__wrapped__ || b.__wrapped__) {</span>
<span class='uncovered'>          return isEqual(a.__wrapped__ || a, b.__wrapped__ || b);</span>
<span class='covered'>        }</span>
<span class='covered'>        // exit for functions and DOM nodes</span>
<span class='uncovered'>        if (className != objectClass || (noNodeClass &amp;&amp; (</span>
<span class='uncovered'>            (typeof a.toString != &#39;function&#39; &amp;&amp; typeof (a + &#39;&#39;) == &#39;string&#39;) ||</span>
<span class='uncovered'>            (typeof b.toString != &#39;function&#39; &amp;&amp; typeof (b + &#39;&#39;) == &#39;string&#39;)))) {</span>
<span class='uncovered'>          return false;</span>
<span class='covered'>        }</span>
<span class='uncovered'>        var ctorA = a.constructor,</span>
<span class='uncovered'>            ctorB = b.constructor;</span>
<span class='covered'>  </span>
<span class='covered'>        // non `Object` object instances with different constructors are not equal</span>
<span class='uncovered'>        if (ctorA != ctorB &amp;&amp; !(</span>
<span class='uncovered'>              isFunction(ctorA) &amp;&amp; ctorA instanceof ctorA &amp;&amp;</span>
<span class='uncovered'>              isFunction(ctorB) &amp;&amp; ctorB instanceof ctorB</span>
<span class='uncovered'>            )) {</span>
<span class='uncovered'>          return false;</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      // assume cyclic structures are equal</span>
<span class='covered'>      // the algorithm for detecting cyclic structures is adapted from ES 5.1</span>
<span class='covered'>      // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)</span>
<span class='uncovered'>      stackA || (stackA = []);</span>
<span class='uncovered'>      stackB || (stackB = []);</span>
<span class='covered'>  </span>
<span class='uncovered'>      var length = stackA.length;</span>
<span class='uncovered'>      while (length--) {</span>
<span class='uncovered'>        if (stackA[length] == a) {</span>
<span class='uncovered'>          return stackB[length] == b;</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          result = true,</span>
<span class='uncovered'>          size = 0;</span>
<span class='covered'>  </span>
<span class='covered'>      // add `a` and `b` to the stack of traversed objects</span>
<span class='uncovered'>      stackA.push(a);</span>
<span class='uncovered'>      stackB.push(b);</span>
<span class='covered'>  </span>
<span class='covered'>      // recursively compare objects and arrays (susceptible to call stack limits)</span>
<span class='covered'>      if (isArr) {</span>
<span class='covered'>        // compare lengths to determine if a deep comparison is necessary</span>
<span class='uncovered'>        size = a.length;</span>
<span class='uncovered'>        result = size == b.length;</span>
<span class='covered'>  </span>
<span class='covered'>        if (result) {</span>
<span class='covered'>          // deep compare the contents, ignoring non-numeric properties</span>
<span class='uncovered'>          while (size--) {</span>
<span class='uncovered'>            if (!(result = isEqual(a[size], b[size], stackA, stackB))) {</span>
<span class='covered'>              break;</span>
<span class='covered'>            }</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='uncovered'>        return result;</span>
<span class='covered'>      }</span>
<span class='covered'>      // deep compare objects</span>
<span class='covered'>      for (var key in a) {</span>
<span class='uncovered'>        if (hasOwnProperty.call(a, key)) {</span>
<span class='covered'>          // count the number of properties.</span>
<span class='uncovered'>          size++;</span>
<span class='covered'>          // deep compare each property value.</span>
<span class='uncovered'>          if (!(hasOwnProperty.call(b, key) &amp;&amp; isEqual(a[key], b[key], stackA, stackB))) {</span>
<span class='uncovered'>            return false;</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      // ensure both objects have the same number of properties</span>
<span class='covered'>      for (key in b) {</span>
<span class='covered'>        // The JS engine in Adobe products, like InDesign, has a bug that causes</span>
<span class='covered'>        // `!size--` to throw an error so it must be wrapped in parentheses.</span>
<span class='covered'>        // https://github.com/documentcloud/underscore/issues/355</span>
<span class='uncovered'>        if (hasOwnProperty.call(b, key) &amp;&amp; !(size--)) {</span>
<span class='covered'>          // `size` will be `-1` if `b` has more properties than `a`</span>
<span class='uncovered'>          return false;</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      // handle JScript [[DontEnum]] bug</span>
<span class='covered'>      if (hasDontEnumBug) {</span>
<span class='uncovered'>        while (++index &lt; 7) {</span>
<span class='uncovered'>          key = shadowed[index];</span>
<span class='uncovered'>          if (hasOwnProperty.call(a, key) &amp;&amp;</span>
<span class='uncovered'>              !(hasOwnProperty.call(b, key) &amp;&amp; isEqual(a[key], b[key], stackA, stackB))) {</span>
<span class='uncovered'>            return false;</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return true;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is, or can be coerced to, a finite number.</span>
<span class='covered'>     *</span>
<span class='covered'>     * Note: This is not the same as native `isFinite`, which will return true for</span>
<span class='covered'>     * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @deprecated</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a finite number, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isFinite(-101);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isFinite(&#39;10&#39;);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isFinite(true);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isFinite(&#39;&#39;);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isFinite(Infinity);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function isFinite(value) {</span>
<span class='uncovered'>      return nativeIsFinite(value) &amp;&amp; !nativeIsNaN(parseFloat(value));</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is a function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a function, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isFunction(_);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isFunction(value) {</span>
<span class='covered'>      return typeof value == &#39;function&#39;;</span>
<span class='covered'>    }</span>
<span class='covered'>    // fallback for older versions of Chrome and Safari</span>
<span class='covered'>    if (isFunction(/x/)) {</span>
<span class='uncovered'>      isFunction = function(value) {</span>
<span class='uncovered'>        return toString.call(value) == funcClass;</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is the language type of Object.</span>
<span class='covered'>     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String(&#39;&#39;)`)</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is an object, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isObject({});</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isObject([1, 2, 3]);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isObject(1);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function isObject(value) {</span>
<span class='covered'>      // check if the value is the ECMAScript language type of Object</span>
<span class='covered'>      // http://es5.github.com/#x8</span>
<span class='covered'>      // and avoid a V8 bug</span>
<span class='covered'>      // http://code.google.com/p/v8/issues/detail?id=2291</span>
<span class='uncovered'>      return value ? objectTypes[typeof value] : false;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is `NaN`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * Note: This is not the same as native `isNaN`, which will return true for</span>
<span class='covered'>     * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @deprecated</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is `NaN`, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isNaN(NaN);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isNaN(new Number(NaN));</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * isNaN(undefined);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isNaN(undefined);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function isNaN(value) {</span>
<span class='covered'>      // `NaN` as a primitive is the only value that is not equal to itself</span>
<span class='covered'>      // (perform the [[Class]] check first to avoid errors with some host objects in IE)</span>
<span class='uncovered'>      return toString.call(value) == numberClass &amp;&amp; value != +value</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is `null`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @deprecated</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is `null`, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isNull(null);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isNull(undefined);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function isNull(value) {</span>
<span class='uncovered'>      return value === null;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is a number.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a number, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isNumber(8.4 * 5);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isNumber(value) {</span>
<span class='uncovered'>      return toString.call(value) == numberClass;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if a given `value` is an object created by the `Object` constructor.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * function Stooge(name, age) {</span>
<span class='covered'>     *   this.name = name;</span>
<span class='covered'>     *   this.age = age;</span>
<span class='covered'>     * }</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isPlainObject(new Stooge(&#39;moe&#39;, 40));</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isPlainObject([1, 2, 3]);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isPlainObject({ &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 });</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='partial'>    var isPlainObject = !getPrototypeOf ? <span class='partialuncovered'>shimIsPlainObject </span>: function(value) {</span>
<span class='uncovered'>      if (!(value &amp;&amp; typeof value == &#39;object&#39;)) {</span>
<span class='uncovered'>        return false;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      var valueOf = value.valueOf,</span>
<span class='uncovered'>          objProto = typeof valueOf == &#39;function&#39; &amp;&amp; (objProto = getPrototypeOf(valueOf)) &amp;&amp; getPrototypeOf(objProto);</span>
<span class='covered'>  </span>
<span class='uncovered'>      return objProto</span>
<span class='uncovered'>        ? value == objProto || (getPrototypeOf(value) == objProto &amp;&amp; !isArguments(value))</span>
<span class='uncovered'>        : shimIsPlainObject(value);</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is a regular expression.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a regular expression, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isRegExp(/moe/);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isRegExp(value) {</span>
<span class='uncovered'>      return toString.call(value) == regexpClass;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is a string.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is a string, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isString(&#39;moe&#39;);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isString(value) {</span>
<span class='uncovered'>      return toString.call(value) == stringClass;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if `value` is `undefined`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @deprecated</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Mixed} value The value to check.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `value` is `undefined`, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.isUndefined(void 0);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function isUndefined(value) {</span>
<span class='uncovered'>      return value === undefined;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array composed of the own enumerable property names of `object`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to inspect.</span>
<span class='covered'>     * @returns {Array} Returns a new array of property names.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.keys({ &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3 });</span>
<span class='covered'>     * // =&gt; [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] (order is not guaranteed)</span>
<span class='covered'>     */</span>
<span class='partial'>    var keys = !nativeKeys ? <span class='partialuncovered'>shimKeys </span>: function(object) {</span>
<span class='covered'>      // avoid iterating over the `prototype` property</span>
<span class='uncovered'>      return typeof object == &#39;function&#39; &amp;&amp; propertyIsEnumerable.call(object, &#39;prototype&#39;)</span>
<span class='uncovered'>        ? shimKeys(object)</span>
<span class='uncovered'>        : (isObject(object) ? nativeKeys(object) : []);</span>
<span class='covered'>    };</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Merges enumerable properties of the source object(s) into the `destination`</span>
<span class='covered'>     * object. Subsequent sources will overwrite propery assignments of previous</span>
<span class='covered'>     * sources.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The destination object.</span>
<span class='covered'>     * @param {Object} [source1, source2, ...] The source objects.</span>
<span class='covered'>     * @param- {Object} [indicator] Internally used to indicate that the `stack`</span>
<span class='covered'>     *  argument is an array of traversed objects instead of another source object.</span>
<span class='covered'>     * @param- {Array} [stackA=[]] Internally used to track traversed source objects.</span>
<span class='covered'>     * @param- {Array} [stackB=[]] Internally used to associate values with their</span>
<span class='covered'>     *  source counterparts.</span>
<span class='covered'>     * @returns {Object} Returns the destination object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var stooges = [</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;moe&#39; },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;larry&#39; }</span>
<span class='covered'>     * ];</span>
<span class='covered'>     *</span>
<span class='covered'>     * var ages = [</span>
<span class='covered'>     *   { &#39;age&#39;: 40 },</span>
<span class='covered'>     *   { &#39;age&#39;: 50 }</span>
<span class='covered'>     * ];</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.merge(stooges, ages);</span>
<span class='covered'>     * // =&gt; [{ &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 }, { &#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50 }]</span>
<span class='covered'>     */</span>
<span class='covered'>    function merge(object, source, indicator) {</span>
<span class='uncovered'>      var args = arguments,</span>
<span class='uncovered'>          index = 0,</span>
<span class='uncovered'>          length = 2,</span>
<span class='uncovered'>          stackA = args[3],</span>
<span class='uncovered'>          stackB = args[4];</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (indicator !== objectRef) {</span>
<span class='uncovered'>        stackA = [];</span>
<span class='uncovered'>        stackB = [];</span>
<span class='uncovered'>        length = args.length;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        forOwn(args[index], function(source, key) {</span>
<span class='uncovered'>          var found, isArr, value;</span>
<span class='uncovered'>          if (source &amp;&amp; ((isArr = isArray(source)) || isPlainObject(source))) {</span>
<span class='uncovered'>            // avoid merging previously merged cyclic sources</span>
<span class='uncovered'>            var stackLength = stackA.length;</span>
<span class='uncovered'>            while (stackLength--) {</span>
<span class='uncovered'>              found = stackA[stackLength] == source;</span>
<span class='uncovered'>              if (found) {</span>
<span class='uncovered'>                break;</span>
<span class='uncovered'>              }</span>
<span class='uncovered'>            }</span>
<span class='uncovered'>            if (found) {</span>
<span class='uncovered'>              object[key] = stackB[stackLength];</span>
<span class='uncovered'>            }</span>
<span class='uncovered'>            else {</span>
<span class='uncovered'>              // add `source` and associated `value` to the stack of traversed objects</span>
<span class='uncovered'>              stackA.push(source);</span>
<span class='uncovered'>              stackB.push(value = (value = object[key], isArr)</span>
<span class='uncovered'>                ? (isArray(value) ? value : [])</span>
<span class='uncovered'>                : (isPlainObject(value) ? value : {})</span>
<span class='uncovered'>              );</span>
<span class='uncovered'>              // recursively merge objects and arrays (susceptible to call stack limits)</span>
<span class='uncovered'>              object[key] = merge(value, source, objectRef, stackA, stackB);</span>
<span class='uncovered'>            }</span>
<span class='uncovered'>          } else if (source != null) {</span>
<span class='uncovered'>            object[key] = source;</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>        });</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return object;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a shallow clone of `object` excluding the specified properties.</span>
<span class='covered'>     * Property names may be specified as individual arguments or as arrays of</span>
<span class='covered'>     * property names. If `callback` is passed, it will be executed for each property</span>
<span class='covered'>     * in the `object`, omitting the properties `callback` returns truthy for. The</span>
<span class='covered'>     * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The source object.</span>
<span class='covered'>     * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit</span>
<span class='covered'>     *  or the function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Object} Returns an object without the omitted properties.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.omit({ &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40, &#39;userid&#39;: &#39;moe1&#39; }, &#39;userid&#39;);</span>
<span class='covered'>     * // =&gt; { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 }</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.omit({ &#39;name&#39;: &#39;moe&#39;, &#39;_hint&#39;: &#39;knucklehead&#39;, &#39;_seed&#39;: &#39;96c4eb&#39; }, function(value, key) {</span>
<span class='covered'>     *   return key.charAt(0) == &#39;_&#39;;</span>
<span class='covered'>     * });</span>
<span class='covered'>     * // =&gt; { &#39;name&#39;: &#39;moe&#39; }</span>
<span class='covered'>     */</span>
<span class='covered'>    function omit(object, callback, thisArg) {</span>
<span class='uncovered'>      var isFunc = typeof callback == &#39;function&#39;,</span>
<span class='uncovered'>          result = {};</span>
<span class='covered'>  </span>
<span class='covered'>      if (isFunc) {</span>
<span class='uncovered'>        callback = createCallback(callback, thisArg);</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        var props = concat.apply(arrayRef, arguments);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      forIn(object, function(value, key, object) {</span>
<span class='uncovered'>        if (isFunc</span>
<span class='uncovered'>              ? !callback(value, key, object)</span>
<span class='uncovered'>              : indexOf(props, key, 1) &lt; 0</span>
<span class='uncovered'>            ) {</span>
<span class='uncovered'>          result[key] = value;</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a two dimensional array of the given object&#39;s key-value pairs,</span>
<span class='covered'>     * i.e. `[[key1, value1], [key2, value2]]`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to inspect.</span>
<span class='covered'>     * @returns {Array} Returns new array of key-value pairs.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.pairs({ &#39;moe&#39;: 30, &#39;larry&#39;: 40, &#39;curly&#39;: 50 });</span>
<span class='covered'>     * // =&gt; [[&#39;moe&#39;, 30], [&#39;larry&#39;, 40], [&#39;curly&#39;, 50]] (order is not guaranteed)</span>
<span class='covered'>     */</span>
<span class='covered'>    function pairs(object) {</span>
<span class='uncovered'>      var result = [];</span>
<span class='uncovered'>      forOwn(object, function(value, key) {</span>
<span class='uncovered'>        result.push([key, value]);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a shallow clone of `object` composed of the specified properties.</span>
<span class='covered'>     * Property names may be specified as individual arguments or as arrays of</span>
<span class='covered'>     * property names. If `callback` is passed, it will be executed for each property</span>
<span class='covered'>     * in the `object`, picking the properties `callback` returns truthy for. The</span>
<span class='covered'>     * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The source object.</span>
<span class='covered'>     * @param {Function|String} callback|[prop1, prop2, ...] The properties to pick</span>
<span class='covered'>     *  or the function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Object} Returns an object composed of the picked properties.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.pick({ &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40, &#39;userid&#39;: &#39;moe1&#39; }, &#39;name&#39;, &#39;age&#39;);</span>
<span class='covered'>     * // =&gt; { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 }</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.pick({ &#39;name&#39;: &#39;moe&#39;, &#39;_hint&#39;: &#39;knucklehead&#39;, &#39;_seed&#39;: &#39;96c4eb&#39; }, function(value, key) {</span>
<span class='covered'>     *   return key.charAt(0) != &#39;_&#39;;</span>
<span class='covered'>     * });</span>
<span class='covered'>     * // =&gt; { &#39;name&#39;: &#39;moe&#39; }</span>
<span class='covered'>     */</span>
<span class='covered'>    function pick(object, callback, thisArg) {</span>
<span class='uncovered'>      var result = {};</span>
<span class='uncovered'>      if (typeof callback != &#39;function&#39;) {</span>
<span class='uncovered'>        var index = 0,</span>
<span class='uncovered'>            props = concat.apply(arrayRef, arguments),</span>
<span class='uncovered'>            length = props.length;</span>
<span class='covered'>  </span>
<span class='uncovered'>        while (++index &lt; length) {</span>
<span class='uncovered'>          var key = props[index];</span>
<span class='uncovered'>          if (key in object) {</span>
<span class='uncovered'>            result[key] = object[key];</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>        forIn(object, function(value, key, object) {</span>
<span class='uncovered'>          if (callback(value, key, object)) {</span>
<span class='uncovered'>            result[key] = value;</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>        });</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array composed of the own enumerable property values of `object`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Objects</span>
<span class='covered'>     * @param {Object} object The object to inspect.</span>
<span class='covered'>     * @returns {Array} Returns a new array of property values.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.values({ &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3 });</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     */</span>
<span class='covered'>    function values(object) {</span>
<span class='uncovered'>      var result = [];</span>
<span class='uncovered'>      forOwn(object, function(value) {</span>
<span class='uncovered'>        result.push(value);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if a given `target` element is present in a `collection` using strict</span>
<span class='covered'>     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used</span>
<span class='covered'>     * as the offset from the end of the collection.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias include</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Mixed} target The value to check for.</span>
<span class='covered'>     * @param {Number} [fromIndex=0] The index to search from.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.contains([1, 2, 3], 1);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.contains([1, 2, 3], 1, 2);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.contains({ &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 }, &#39;moe&#39;);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.contains(&#39;curly&#39;, &#39;ur&#39;);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function contains(collection, target, fromIndex) {</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          length = collection ? collection.length : 0;</span>
<span class='covered'>  </span>
<span class='uncovered'>      fromIndex = (fromIndex &lt; 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;</span>
<span class='uncovered'>      if (typeof length == &#39;number&#39;) {</span>
<span class='uncovered'>        return (isString(collection)</span>
<span class='uncovered'>          ? collection.indexOf(target, fromIndex)</span>
<span class='uncovered'>          : indexOf(collection, target, fromIndex)</span>
<span class='uncovered'>        ) &gt; -1;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return some(collection, function(value) {</span>
<span class='uncovered'>        return ++index &gt;= fromIndex &amp;&amp; value === target;</span>
<span class='uncovered'>      });</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an object composed of keys returned from running each element of</span>
<span class='covered'>     * `collection` through a `callback`. The corresponding value of each key is</span>
<span class='covered'>     * the number of times the key was returned by `callback`. The `callback` is</span>
<span class='covered'>     * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).</span>
<span class='covered'>     * The `callback` argument may also be the name of a property to count by (e.g. &#39;length&#39;).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function|String} callback|property The function called per iteration</span>
<span class='covered'>     *  or property name to count by.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Object} Returns the composed aggregate object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });</span>
<span class='covered'>     * // =&gt; { &#39;4&#39;: 1, &#39;6&#39;: 2 }</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);</span>
<span class='covered'>     * // =&gt; { &#39;4&#39;: 1, &#39;6&#39;: 2 }</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.countBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;);</span>
<span class='covered'>     * // =&gt; { &#39;3&#39;: 2, &#39;5&#39;: 1 }</span>
<span class='covered'>     */</span>
<span class='covered'>    function countBy(collection, callback, thisArg) {</span>
<span class='uncovered'>      var result = {};</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>      forEach(collection, function(value, key, collection) {</span>
<span class='uncovered'>        key = callback(value, key, collection);</span>
<span class='uncovered'>        (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if the `callback` returns a truthy value for **all** elements of a</span>
<span class='covered'>     * `collection`. The `callback` is bound to `thisArg` and invoked with three</span>
<span class='covered'>     * arguments; (value, index|key, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias all</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} [callback=identity] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if all elements pass the callback check,</span>
<span class='covered'>     *  else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.every([true, 1, null, &#39;yes&#39;], Boolean);</span>
<span class='covered'>     * // =&gt; false</span>
<span class='covered'>     */</span>
<span class='covered'>    function every(collection, callback, thisArg) {</span>
<span class='uncovered'>      var result = true;</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (isArray(collection)) {</span>
<span class='uncovered'>        var index = -1,</span>
<span class='uncovered'>            length = collection.length;</span>
<span class='covered'>  </span>
<span class='uncovered'>        while (++index &lt; length) {</span>
<span class='uncovered'>          if (!(result = !!callback(collection[index], index, collection))) {</span>
<span class='covered'>            break;</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>          return (result = !!callback(value, index, collection));</span>
<span class='uncovered'>        });</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Examines each element in a `collection`, returning an array of all elements</span>
<span class='covered'>     * the `callback` returns truthy for. The `callback` is bound to `thisArg` and</span>
<span class='covered'>     * invoked with three arguments; (value, index|key, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias select</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} [callback=identity] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Array} Returns a new array of elements that passed the callback check.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });</span>
<span class='covered'>     * // =&gt; [2, 4, 6]</span>
<span class='covered'>     */</span>
<span class='covered'>    function filter(collection, callback, thisArg) {</span>
<span class='uncovered'>      var result = [];</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>      forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>        if (callback(value, index, collection)) {</span>
<span class='uncovered'>          result.push(value);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Examines each element in a `collection`, returning the first one the `callback`</span>
<span class='covered'>     * returns truthy for. The function returns as soon as it finds an acceptable</span>
<span class='covered'>     * element, and does not iterate over the entire `collection`. The `callback` is</span>
<span class='covered'>     * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias detect</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} callback The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Mixed} Returns the element that passed the callback check,</span>
<span class='covered'>     *  else `undefined`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var even = _.find([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     */</span>
<span class='covered'>    function find(collection, callback, thisArg) {</span>
<span class='uncovered'>      var result;</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>      forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>        if (callback(value, index, collection)) {</span>
<span class='uncovered'>          result = value;</span>
<span class='uncovered'>          return false;</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Iterates over a `collection`, executing the `callback` for each element in</span>
<span class='covered'>     * the `collection`. The `callback` is bound to `thisArg` and invoked with three</span>
<span class='covered'>     * arguments; (value, index|key, collection). Callbacks may exit iteration early</span>
<span class='covered'>     * by explicitly returning `false`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias each</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} callback The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Array|Object|String} Returns `collection`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _([1, 2, 3]).forEach(alert).join(&#39;,&#39;);</span>
<span class='covered'>     * // =&gt; alerts each number and returns &#39;1,2,3&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.forEach({ &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3 }, alert);</span>
<span class='covered'>     * // =&gt; alerts each number (order is not guaranteed)</span>
<span class='covered'>     */</span>
<span class='covered'>    var forEach = createIterator(forEachIteratorOptions);</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an object composed of keys returned from running each element of</span>
<span class='covered'>     * `collection` through a `callback`. The corresponding value of each key is an</span>
<span class='covered'>     * array of elements passed to `callback` that returned the key. The `callback`</span>
<span class='covered'>     * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).</span>
<span class='covered'>     * The `callback` argument may also be the name of a property to group by (e.g. &#39;length&#39;).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function|String} callback|property The function called per iteration</span>
<span class='covered'>     *  or property name to group by.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Object} Returns the composed aggregate object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });</span>
<span class='covered'>     * // =&gt; { &#39;4&#39;: [4.2], &#39;6&#39;: [6.1, 6.4] }</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);</span>
<span class='covered'>     * // =&gt; { &#39;4&#39;: [4.2], &#39;6&#39;: [6.1, 6.4] }</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.groupBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;);</span>
<span class='covered'>     * // =&gt; { &#39;3&#39;: [&#39;one&#39;, &#39;two&#39;], &#39;5&#39;: [&#39;three&#39;] }</span>
<span class='covered'>     */</span>
<span class='covered'>    function groupBy(collection, callback, thisArg) {</span>
<span class='uncovered'>      var result = {};</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>      forEach(collection, function(value, key, collection) {</span>
<span class='uncovered'>        key = callback(value, key, collection);</span>
<span class='uncovered'>        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Invokes the method named by `methodName` on each element in the `collection`,</span>
<span class='covered'>     * returning an array of the results of each invoked method. Additional arguments</span>
<span class='covered'>     * will be passed to each invoked method. If `methodName` is a function it will</span>
<span class='covered'>     * be invoked for, and `this` bound to, each element in the `collection`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function|String} methodName The name of the method to invoke or</span>
<span class='covered'>     *  the function invoked per iteration.</span>
<span class='covered'>     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.</span>
<span class='covered'>     * @returns {Array} Returns a new array of the results of each invoked method.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.invoke([[5, 1, 7], [3, 2, 1]], &#39;sort&#39;);</span>
<span class='covered'>     * // =&gt; [[1, 5, 7], [1, 2, 3]]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.invoke([123, 456], String.prototype.split, &#39;&#39;);</span>
<span class='covered'>     * // =&gt; [[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], [&#39;4&#39;, &#39;5&#39;, &#39;6&#39;]]</span>
<span class='covered'>     */</span>
<span class='covered'>    function invoke(collection, methodName) {</span>
<span class='uncovered'>      var args = slice.call(arguments, 2),</span>
<span class='uncovered'>          isFunc = typeof methodName == &#39;function&#39;,</span>
<span class='uncovered'>          result = [];</span>
<span class='covered'>  </span>
<span class='uncovered'>      forEach(collection, function(value) {</span>
<span class='uncovered'>        result.push((isFunc ? methodName : value[methodName]).apply(value, args));</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array of values by running each element in the `collection`</span>
<span class='covered'>     * through a `callback`. The `callback` is bound to `thisArg` and invoked with</span>
<span class='covered'>     * three arguments; (value, index|key, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias collect</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} [callback=identity] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Array} Returns a new array of the results of each `callback` execution.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.map([1, 2, 3], function(num) { return num * 3; });</span>
<span class='covered'>     * // =&gt; [3, 6, 9]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.map({ &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3 }, function(num) { return num * 3; });</span>
<span class='covered'>     * // =&gt; [3, 6, 9] (order is not guaranteed)</span>
<span class='covered'>     */</span>
<span class='covered'>    function map(collection, callback, thisArg) {</span>
<span class='covered'>      var index = -1,</span>
<span class='partial'>          length = collection ? collection.length : <span class='partialuncovered'>0,</span></span>
<span class='partial'>          result = Array(typeof length == &#39;number&#39; ? length : <span class='partialuncovered'>0)</span>;</span>
<span class='covered'>  </span>
<span class='covered'>      callback = createCallback(callback, thisArg);</span>
<span class='covered'>      if (isArray(collection)) {</span>
<span class='covered'>        while (++index &lt; length) {</span>
<span class='covered'>          result[index] = callback(collection[index], index, collection);</span>
<span class='covered'>        }</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        forEach(collection, function(value, key, collection) {</span>
<span class='uncovered'>          result[++index] = callback(value, key, collection);</span>
<span class='uncovered'>        });</span>
<span class='covered'>      }</span>
<span class='covered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Retrieves the maximum value of an `array`. If `callback` is passed,</span>
<span class='covered'>     * it will be executed for each value in the `array` to generate the</span>
<span class='covered'>     * criterion by which the value is ranked. The `callback` is bound to</span>
<span class='covered'>     * `thisArg` and invoked with three arguments; (value, index, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} [callback] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Mixed} Returns the maximum value.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var stooges = [</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60 }</span>
<span class='covered'>     * ];</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.max(stooges, function(stooge) { return stooge.age; });</span>
<span class='covered'>     * // =&gt; { &#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60 };</span>
<span class='covered'>     */</span>
<span class='covered'>    function max(collection, callback, thisArg) {</span>
<span class='uncovered'>      var computed = -Infinity,</span>
<span class='uncovered'>          index = -1,</span>
<span class='uncovered'>          length = collection ? collection.length : 0,</span>
<span class='uncovered'>          result = computed;</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (callback || !isArray(collection)) {</span>
<span class='uncovered'>        callback = !callback &amp;&amp; isString(collection)</span>
<span class='uncovered'>          ? charAtCallback</span>
<span class='uncovered'>          : createCallback(callback, thisArg);</span>
<span class='covered'>  </span>
<span class='uncovered'>        forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>          var current = callback(value, index, collection);</span>
<span class='uncovered'>          if (current &gt; computed) {</span>
<span class='uncovered'>            computed = current;</span>
<span class='uncovered'>            result = value;</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>        });</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        while (++index &lt; length) {</span>
<span class='uncovered'>          if (collection[index] &gt; result) {</span>
<span class='uncovered'>            result = collection[index];</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Retrieves the minimum value of an `array`. If `callback` is passed,</span>
<span class='covered'>     * it will be executed for each value in the `array` to generate the</span>
<span class='covered'>     * criterion by which the value is ranked. The `callback` is bound to `thisArg`</span>
<span class='covered'>     * and invoked with three arguments; (value, index, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} [callback] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Mixed} Returns the minimum value.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.min([10, 5, 100, 2, 1000]);</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     */</span>
<span class='covered'>    function min(collection, callback, thisArg) {</span>
<span class='uncovered'>      var computed = Infinity,</span>
<span class='uncovered'>          index = -1,</span>
<span class='uncovered'>          length = collection ? collection.length : 0,</span>
<span class='uncovered'>          result = computed;</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (callback || !isArray(collection)) {</span>
<span class='uncovered'>        callback = !callback &amp;&amp; isString(collection)</span>
<span class='uncovered'>          ? charAtCallback</span>
<span class='uncovered'>          : createCallback(callback, thisArg);</span>
<span class='covered'>  </span>
<span class='uncovered'>        forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>          var current = callback(value, index, collection);</span>
<span class='uncovered'>          if (current &lt; computed) {</span>
<span class='uncovered'>            computed = current;</span>
<span class='uncovered'>            result = value;</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>        });</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        while (++index &lt; length) {</span>
<span class='uncovered'>          if (collection[index] &lt; result) {</span>
<span class='uncovered'>            result = collection[index];</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Retrieves the value of a specified property from all elements in</span>
<span class='covered'>     * the `collection`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {String} property The property to pluck.</span>
<span class='covered'>     * @returns {Array} Returns a new array of property values.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var stooges = [</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60 }</span>
<span class='covered'>     * ];</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.pluck(stooges, &#39;name&#39;);</span>
<span class='covered'>     * // =&gt; [&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;]</span>
<span class='covered'>     */</span>
<span class='covered'>    function pluck(collection, property) {</span>
<span class='uncovered'>      var result = [];</span>
<span class='uncovered'>      forEach(collection, function(value) {</span>
<span class='uncovered'>        result.push(value[property]);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Boils down a `collection` to a single value. The initial state of the</span>
<span class='covered'>     * reduction is `accumulator` and each successive step of it should be returned</span>
<span class='covered'>     * by the `callback`. The `callback` is bound to `thisArg` and invoked with 4</span>
<span class='covered'>     * arguments; for arrays they are (accumulator, value, index|key, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias foldl, inject</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} callback The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [accumulator] Initial value of the accumulator.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Mixed} Returns the accumulated value.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var sum = _.reduce([1, 2, 3], function(memo, num) { return memo + num; });</span>
<span class='covered'>     * // =&gt; 6</span>
<span class='covered'>     */</span>
<span class='covered'>    function reduce(collection, callback, accumulator, thisArg) {</span>
<span class='uncovered'>      var noaccum = arguments.length &lt; 3;</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>      forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>        accumulator = noaccum</span>
<span class='uncovered'>          ? (noaccum = false, value)</span>
<span class='uncovered'>          : callback(accumulator, value, index, collection)</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return accumulator;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * The right-associative version of `_.reduce`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias foldr</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} callback The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [accumulator] Initial value of the accumulator.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Mixed} Returns the accumulated value.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var list = [[0, 1], [2, 3], [4, 5]];</span>
<span class='covered'>     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);</span>
<span class='covered'>     * // =&gt; [4, 5, 2, 3, 0, 1]</span>
<span class='covered'>     */</span>
<span class='covered'>    function reduceRight(collection, callback, accumulator, thisArg) {</span>
<span class='uncovered'>      var iteratee = collection,</span>
<span class='uncovered'>          length = collection ? collection.length : 0,</span>
<span class='uncovered'>          noaccum = arguments.length &lt; 3;</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (typeof length != &#39;number&#39;) {</span>
<span class='uncovered'>        var props = keys(collection);</span>
<span class='uncovered'>        length = props.length;</span>
<span class='uncovered'>      } else if (noCharByIndex &amp;&amp; isString(collection)) {</span>
<span class='uncovered'>        iteratee = collection.split(&#39;&#39;);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>        index = props ? props[--length] : --length;</span>
<span class='uncovered'>        accumulator = noaccum</span>
<span class='uncovered'>          ? (noaccum = false, iteratee[index])</span>
<span class='uncovered'>          : callback.call(thisArg, accumulator, iteratee[index], index, collection);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return accumulator;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * The opposite of `_.filter`, this method returns the values of a</span>
<span class='covered'>     * `collection` that `callback` does **not** return truthy for.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} [callback=identity] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Array} Returns a new array of elements that did **not** pass the</span>
<span class='covered'>     *  callback check.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });</span>
<span class='covered'>     * // =&gt; [1, 3, 5]</span>
<span class='covered'>     */</span>
<span class='covered'>    function reject(collection, callback, thisArg) {</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>      return filter(collection, function(value, index, collection) {</span>
<span class='uncovered'>        return !callback(value, index, collection);</span>
<span class='uncovered'>      });</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array of shuffled `array` values, using a version of the</span>
<span class='covered'>     * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to shuffle.</span>
<span class='covered'>     * @returns {Array} Returns a new shuffled collection.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.shuffle([1, 2, 3, 4, 5, 6]);</span>
<span class='covered'>     * // =&gt; [4, 1, 6, 3, 5, 2]</span>
<span class='covered'>     */</span>
<span class='covered'>    function shuffle(collection) {</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          result = Array(collection ? collection.length : 0);</span>
<span class='covered'>  </span>
<span class='uncovered'>      forEach(collection, function(value) {</span>
<span class='uncovered'>        var rand = floor(nativeRandom() * (++index + 1));</span>
<span class='uncovered'>        result[index] = result[rand];</span>
<span class='uncovered'>        result[rand] = value;</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Gets the size of the `collection` by returning `collection.length` for arrays</span>
<span class='covered'>     * and array-like objects or the number of own enumerable properties for objects.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to inspect.</span>
<span class='covered'>     * @returns {Number} Returns `collection.length` or number of own enumerable properties.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.size([1, 2]);</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.size({ &#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3 });</span>
<span class='covered'>     * // =&gt; 3</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.size(&#39;curly&#39;);</span>
<span class='covered'>     * // =&gt; 5</span>
<span class='covered'>     */</span>
<span class='covered'>    function size(collection) {</span>
<span class='uncovered'>      var length = collection ? collection.length : 0;</span>
<span class='uncovered'>      return typeof length == &#39;number&#39; ? length : keys(collection).length;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Checks if the `callback` returns a truthy value for **any** element of a</span>
<span class='covered'>     * `collection`. The function returns as soon as it finds passing value, and</span>
<span class='covered'>     * does not iterate over the entire `collection`. The `callback` is bound to</span>
<span class='covered'>     * `thisArg` and invoked with three arguments; (value, index|key, collection).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias any</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function} [callback=identity] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Boolean} Returns `true` if any element passes the callback check,</span>
<span class='covered'>     *  else `false`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.some([null, 0, &#39;yes&#39;, false]);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function some(collection, callback, thisArg) {</span>
<span class='uncovered'>      var result;</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (isArray(collection)) {</span>
<span class='uncovered'>        var index = -1,</span>
<span class='uncovered'>            length = collection.length;</span>
<span class='covered'>  </span>
<span class='uncovered'>        while (++index &lt; length) {</span>
<span class='uncovered'>          if (result = callback(collection[index], index, collection)) {</span>
<span class='covered'>            break;</span>
<span class='covered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>          return !(result = callback(value, index, collection));</span>
<span class='uncovered'>        });</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return !!result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array, stable sorted in ascending order by the results of</span>
<span class='covered'>     * running each element of `collection` through a `callback`. The `callback`</span>
<span class='covered'>     * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).</span>
<span class='covered'>     * The `callback` argument may also be the name of a property to sort by (e.g. &#39;length&#39;).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Function|String} callback|property The function called per iteration</span>
<span class='covered'>     *  or property name to sort by.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Array} Returns a new array of sorted elements.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });</span>
<span class='covered'>     * // =&gt; [3, 1, 2]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);</span>
<span class='covered'>     * // =&gt; [3, 1, 2]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.sortBy([&#39;larry&#39;, &#39;brendan&#39;, &#39;moe&#39;], &#39;length&#39;);</span>
<span class='covered'>     * // =&gt; [&#39;moe&#39;, &#39;larry&#39;, &#39;brendan&#39;]</span>
<span class='covered'>     */</span>
<span class='covered'>    function sortBy(collection, callback, thisArg) {</span>
<span class='uncovered'>      var result = [];</span>
<span class='uncovered'>      callback = createCallback(callback, thisArg);</span>
<span class='uncovered'>      forEach(collection, function(value, index, collection) {</span>
<span class='uncovered'>        result.push({</span>
<span class='uncovered'>          &#39;criteria&#39;: callback(value, index, collection),</span>
<span class='uncovered'>          &#39;index&#39;: index,</span>
<span class='uncovered'>          &#39;value&#39;: value</span>
<span class='uncovered'>        });</span>
<span class='uncovered'>      });</span>
<span class='covered'>  </span>
<span class='uncovered'>      var length = result.length;</span>
<span class='uncovered'>      result.sort(compareAscending);</span>
<span class='uncovered'>      while (length--) {</span>
<span class='uncovered'>        result[length] = result[length].value;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Converts the `collection`, to an array.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to convert.</span>
<span class='covered'>     * @returns {Array} Returns the new converted array.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);</span>
<span class='covered'>     * // =&gt; [2, 3, 4]</span>
<span class='covered'>     */</span>
<span class='covered'>    function toArray(collection) {</span>
<span class='uncovered'>      if (collection &amp;&amp; typeof collection.length == &#39;number&#39;) {</span>
<span class='uncovered'>        return (noArraySliceOnStrings ? isString(collection) : typeof collection == &#39;string&#39;)</span>
<span class='uncovered'>          ? collection.split(&#39;&#39;)</span>
<span class='uncovered'>          : slice.call(collection);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return values(collection);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Examines each element in a `collection`, returning an array of all elements</span>
<span class='covered'>     * that contain the given `properties`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Collections</span>
<span class='covered'>     * @param {Array|Object|String} collection The collection to iterate over.</span>
<span class='covered'>     * @param {Object} properties The object of property values to filter by.</span>
<span class='covered'>     * @returns {Array} Returns a new array of elements that contain the given `properties`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var stooges = [</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60 }</span>
<span class='covered'>     * ];</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.where(stooges, { &#39;age&#39;: 40 });</span>
<span class='covered'>     * // =&gt; [{ &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 }]</span>
<span class='covered'>     */</span>
<span class='covered'>    function where(collection, properties) {</span>
<span class='uncovered'>      var props = [];</span>
<span class='uncovered'>      forIn(properties, function(value, prop) {</span>
<span class='uncovered'>        props.push(prop);</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return filter(collection, function(object) {</span>
<span class='uncovered'>        var length = props.length;</span>
<span class='uncovered'>        while (length--) {</span>
<span class='uncovered'>          var result = object[props[length]] === properties[props[length]];</span>
<span class='uncovered'>          if (!result) {</span>
<span class='uncovered'>            break;</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        return !!result;</span>
<span class='uncovered'>      });</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array with all falsey values of `array` removed. The values</span>
<span class='covered'>     * `false`, `null`, `0`, `&quot;&quot;`, `undefined` and `NaN` are all falsey.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to compact.</span>
<span class='covered'>     * @returns {Array} Returns a new filtered array.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.compact([0, 1, false, 2, &#39;&#39;, 3]);</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     */</span>
<span class='covered'>    function compact(array) {</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          length = array ? array.length : 0,</span>
<span class='uncovered'>          result = [];</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        var value = array[index];</span>
<span class='covered'>        if (value) {</span>
<span class='uncovered'>          result.push(value);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array of `array` elements not present in the other arrays</span>
<span class='covered'>     * using strict equality for comparisons, i.e. `===`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to process.</span>
<span class='covered'>     * @param {Array} [array1, array2, ...] Arrays to check.</span>
<span class='covered'>     * @returns {Array} Returns a new array of `array` elements not present in the</span>
<span class='covered'>     *  other arrays.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);</span>
<span class='covered'>     * // =&gt; [1, 3, 4]</span>
<span class='covered'>     */</span>
<span class='covered'>    function difference(array) {</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          length = array ? array.length : 0,</span>
<span class='uncovered'>          flattened = concat.apply(arrayRef, arguments),</span>
<span class='uncovered'>          contains = cachedContains(flattened, length),</span>
<span class='uncovered'>          result = [];</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        var value = array[index];</span>
<span class='uncovered'>        if (!contains(value)) {</span>
<span class='uncovered'>          result.push(value);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Gets the first element of the `array`. Pass `n` to return the first `n`</span>
<span class='covered'>     * elements of the `array`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias head, take</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to query.</span>
<span class='covered'>     * @param {Number} [n] The number of elements to return.</span>
<span class='covered'>     * @param- {Object} [guard] Internally used to allow this method to work with</span>
<span class='covered'>     *  others like `_.map` without using their callback `index` argument for `n`.</span>
<span class='covered'>     * @returns {Mixed} Returns the first element or an array of the first `n`</span>
<span class='covered'>     *  elements of `array`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.first([5, 4, 3, 2, 1]);</span>
<span class='covered'>     * // =&gt; 5</span>
<span class='covered'>     */</span>
<span class='covered'>    function first(array, n, guard) {</span>
<span class='covered'>      if (array) {</span>
<span class='uncovered'>        return (n == null || guard) ? array[0] : slice.call(array, 0, n);</span>
<span class='covered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Flattens a nested array (the nesting can be to any depth). If `shallow` is</span>
<span class='covered'>     * truthy, `array` will only be flattened a single level.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to compact.</span>
<span class='covered'>     * @param {Boolean} shallow A flag to indicate only flattening a single level.</span>
<span class='covered'>     * @returns {Array} Returns a new flattened array.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.flatten([1, [2], [3, [[4]]]]);</span>
<span class='covered'>     * // =&gt; [1, 2, 3, 4];</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.flatten([1, [2], [3, [[4]]]], true);</span>
<span class='covered'>     * // =&gt; [1, 2, 3, [[4]]];</span>
<span class='covered'>     */</span>
<span class='covered'>    function flatten(array, shallow) {</span>
<span class='covered'>      var index = -1,</span>
<span class='partial'>          length = array ? array.length : <span class='partialuncovered'>0,</span></span>
<span class='covered'>          result = [];</span>
<span class='covered'>  </span>
<span class='covered'>      while (++index &lt; length) {</span>
<span class='covered'>        var value = array[index];</span>
<span class='covered'>  </span>
<span class='covered'>        // recursively flatten arrays (susceptible to call stack limits)</span>
<span class='covered'>        if (isArray(value)) {</span>
<span class='partial'>          push.apply(result, shallow ? <span class='partialuncovered'>value </span>: flatten(value));</span>
<span class='covered'>        } else {</span>
<span class='covered'>          result.push(value);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Gets the index at which the first occurrence of `value` is found using</span>
<span class='covered'>     * strict equality for comparisons, i.e. `===`. If the `array` is already</span>
<span class='covered'>     * sorted, passing `true` for `fromIndex` will run a faster binary search.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to search.</span>
<span class='covered'>     * @param {Mixed} value The value to search for.</span>
<span class='covered'>     * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to</span>
<span class='covered'>     *  perform a binary search on a sorted `array`.</span>
<span class='covered'>     * @returns {Number} Returns the index of the matched value or `-1`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.indexOf([1, 2, 3, 1, 2, 3], 2);</span>
<span class='covered'>     * // =&gt; 1</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);</span>
<span class='covered'>     * // =&gt; 4</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     */</span>
<span class='covered'>    function indexOf(array, value, fromIndex) {</span>
<span class='covered'>      var index = -1,</span>
<span class='partial'>          length = array ? array.length : <span class='partialuncovered'>0;</span></span>
<span class='covered'>  </span>
<span class='covered'>      if (typeof fromIndex == &#39;number&#39;) {</span>
<span class='uncovered'>        index = (fromIndex &lt; 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0) - 1;</span>
<span class='covered'>      } else if (fromIndex) {</span>
<span class='uncovered'>        index = sortedIndex(array, value);</span>
<span class='uncovered'>        return array[index] === value ? index : -1;</span>
<span class='covered'>      }</span>
<span class='covered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        if (array[index] === value) {</span>
<span class='uncovered'>          return index;</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      return -1;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Gets all but the last element of `array`. Pass `n` to exclude the last `n`</span>
<span class='covered'>     * elements from the result.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to query.</span>
<span class='covered'>     * @param {Number} [n=1] The number of elements to exclude.</span>
<span class='covered'>     * @param- {Object} [guard] Internally used to allow this method to work with</span>
<span class='covered'>     *  others like `_.map` without using their callback `index` argument for `n`.</span>
<span class='covered'>     * @returns {Array} Returns all but the last element or `n` elements of `array`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.initial([3, 2, 1]);</span>
<span class='covered'>     * // =&gt; [3, 2]</span>
<span class='covered'>     */</span>
<span class='covered'>    function initial(array, n, guard) {</span>
<span class='uncovered'>      return array</span>
<span class='uncovered'>        ? slice.call(array, 0, -((n == null || guard) ? 1 : n))</span>
<span class='uncovered'>        : [];</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Computes the intersection of all the passed-in arrays using strict equality</span>
<span class='covered'>     * for comparisons, i.e. `===`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} [array1, array2, ...] Arrays to process.</span>
<span class='covered'>     * @returns {Array} Returns a new array of unique elements, in order, that are</span>
<span class='covered'>     *  present in **all** of the arrays.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);</span>
<span class='covered'>     * // =&gt; [1, 2]</span>
<span class='covered'>     */</span>
<span class='covered'>    function intersection(array) {</span>
<span class='uncovered'>      var args = arguments,</span>
<span class='uncovered'>          argsLength = args.length,</span>
<span class='uncovered'>          cache = {},</span>
<span class='uncovered'>          result = [];</span>
<span class='covered'>  </span>
<span class='uncovered'>      forEach(array, function(value) {</span>
<span class='uncovered'>        if (indexOf(result, value) &lt; 0) {</span>
<span class='uncovered'>          var length = argsLength;</span>
<span class='uncovered'>          while (--length) {</span>
<span class='uncovered'>            if (!(cache[length] || (cache[length] = cachedContains(args[length])))(value)) {</span>
<span class='uncovered'>              return;</span>
<span class='uncovered'>            }</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>          result.push(value);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Gets the last element of the `array`. Pass `n` to return the last `n`</span>
<span class='covered'>     * elements of the `array`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to query.</span>
<span class='covered'>     * @param {Number} [n] The number of elements to return.</span>
<span class='covered'>     * @param- {Object} [guard] Internally used to allow this method to work with</span>
<span class='covered'>     *  others like `_.map` without using their callback `index` argument for `n`.</span>
<span class='covered'>     * @returns {Mixed} Returns the last element or an array of the last `n`</span>
<span class='covered'>     *  elements of `array`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.last([3, 2, 1]);</span>
<span class='covered'>     * // =&gt; 1</span>
<span class='covered'>     */</span>
<span class='covered'>    function last(array, n, guard) {</span>
<span class='covered'>      if (array) {</span>
<span class='uncovered'>        var length = array.length;</span>
<span class='uncovered'>        return (n == null || guard) ? array[length - 1] : slice.call(array, -n || length);</span>
<span class='covered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Gets the index at which the last occurrence of `value` is found using strict</span>
<span class='covered'>     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used</span>
<span class='covered'>     * as the offset from the end of the collection.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to search.</span>
<span class='covered'>     * @param {Mixed} value The value to search for.</span>
<span class='covered'>     * @param {Number} [fromIndex=array.length-1] The index to search from.</span>
<span class='covered'>     * @returns {Number} Returns the index of the matched value or `-1`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);</span>
<span class='covered'>     * // =&gt; 4</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);</span>
<span class='covered'>     * // =&gt; 1</span>
<span class='covered'>     */</span>
<span class='covered'>    function lastIndexOf(array, value, fromIndex) {</span>
<span class='uncovered'>      var index = array ? array.length : 0;</span>
<span class='uncovered'>      if (typeof fromIndex == &#39;number&#39;) {</span>
<span class='uncovered'>        index = (fromIndex &lt; 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      while (index--) {</span>
<span class='uncovered'>        if (array[index] === value) {</span>
<span class='uncovered'>          return index;</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return -1;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an object composed from arrays of `keys` and `values`. Pass either</span>
<span class='covered'>     * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or</span>
<span class='covered'>     * two arrays, one of `keys` and one of corresponding `values`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} keys The array of keys.</span>
<span class='covered'>     * @param {Array} [values=[]] The array of values.</span>
<span class='covered'>     * @returns {Object} Returns an object composed of the given keys and</span>
<span class='covered'>     *  corresponding values.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.object([&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;], [30, 40, 50]);</span>
<span class='covered'>     * // =&gt; { &#39;moe&#39;: 30, &#39;larry&#39;: 40, &#39;curly&#39;: 50 }</span>
<span class='covered'>     */</span>
<span class='covered'>    function object(keys, values) {</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          length = keys ? keys.length : 0,</span>
<span class='uncovered'>          result = {};</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        var key = keys[index];</span>
<span class='covered'>        if (values) {</span>
<span class='uncovered'>          result[key] = values[index];</span>
<span class='covered'>        } else {</span>
<span class='uncovered'>          result[key[0]] = key[1];</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array of numbers (positive and/or negative) progressing from</span>
<span class='covered'>     * `start` up to but not including `stop`. This method is a port of Python&#39;s</span>
<span class='covered'>     * `range()` function. See http://docs.python.org/library/functions.html#range.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Number} [start=0] The start of the range.</span>
<span class='covered'>     * @param {Number} end The end of the range.</span>
<span class='covered'>     * @param {Number} [step=1] The value to increment or descrement by.</span>
<span class='covered'>     * @returns {Array} Returns a new range array.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.range(10);</span>
<span class='covered'>     * // =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.range(1, 11);</span>
<span class='covered'>     * // =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.range(0, 30, 5);</span>
<span class='covered'>     * // =&gt; [0, 5, 10, 15, 20, 25]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.range(0, -10, -1);</span>
<span class='covered'>     * // =&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.range(0);</span>
<span class='covered'>     * // =&gt; []</span>
<span class='covered'>     */</span>
<span class='covered'>    function range(start, end, step) {</span>
<span class='uncovered'>      start = +start || 0;</span>
<span class='uncovered'>      step = +step || 1;</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (end == null) {</span>
<span class='uncovered'>        end = start;</span>
<span class='uncovered'>        start = 0;</span>
<span class='covered'>      }</span>
<span class='covered'>      // use `Array(length)` so V8 will avoid the slower &quot;dictionary&quot; mode</span>
<span class='covered'>      // http://www.youtube.com/watch?v=XAqIpGU8ZZk#t=16m27s</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          length = nativeMax(0, ceil((end - start) / step)),</span>
<span class='uncovered'>          result = Array(length);</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        result[index] = start;</span>
<span class='uncovered'>        start += step;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * The opposite of `_.initial`, this method gets all but the first value of</span>
<span class='covered'>     * `array`. Pass `n` to exclude the first `n` values from the result.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias drop, tail</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to query.</span>
<span class='covered'>     * @param {Number} [n=1] The number of elements to exclude.</span>
<span class='covered'>     * @param- {Object} [guard] Internally used to allow this method to work with</span>
<span class='covered'>     *  others like `_.map` without using their callback `index` argument for `n`.</span>
<span class='covered'>     * @returns {Array} Returns all but the first value or `n` values of `array`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.rest([3, 2, 1]);</span>
<span class='covered'>     * // =&gt; [2, 1]</span>
<span class='covered'>     */</span>
<span class='covered'>    function rest(array, n, guard) {</span>
<span class='uncovered'>      return array</span>
<span class='uncovered'>        ? slice.call(array, (n == null || guard) ? 1 : n)</span>
<span class='uncovered'>        : [];</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Uses a binary search to determine the smallest index at which the `value`</span>
<span class='covered'>     * should be inserted into `array` in order to maintain the sort order of the</span>
<span class='covered'>     * sorted `array`. If `callback` is passed, it will be executed for `value` and</span>
<span class='covered'>     * each element in `array` to compute their sort ranking. The `callback` is</span>
<span class='covered'>     * bound to `thisArg` and invoked with one argument; (value). The `callback`</span>
<span class='covered'>     * argument may also be the name of a property to order by.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to iterate over.</span>
<span class='covered'>     * @param {Mixed} value The value to evaluate.</span>
<span class='covered'>     * @param {Function|String} [callback=identity|property] The function called</span>
<span class='covered'>     *  per iteration or property name to order by.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Number} Returns the index at which the value should be inserted</span>
<span class='covered'>     *  into `array`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.sortedIndex([20, 30, 50], 40);</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.sortedIndex([{ &#39;x&#39;: 20 }, { &#39;x&#39;: 30 }, { &#39;x&#39;: 50 }], { &#39;x&#39;: 40 }, &#39;x&#39;);</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     *</span>
<span class='covered'>     * var dict = {</span>
<span class='covered'>     *   &#39;wordToNumber&#39;: { &#39;twenty&#39;: 20, &#39;thirty&#39;: 30, &#39;fourty&#39;: 40, &#39;fifty&#39;: 50 }</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.sortedIndex([&#39;twenty&#39;, &#39;thirty&#39;, &#39;fifty&#39;], &#39;fourty&#39;, function(word) {</span>
<span class='covered'>     *   return dict.wordToNumber[word];</span>
<span class='covered'>     * });</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.sortedIndex([&#39;twenty&#39;, &#39;thirty&#39;, &#39;fifty&#39;], &#39;fourty&#39;, function(word) {</span>
<span class='covered'>     *   return this.wordToNumber[word];</span>
<span class='covered'>     * }, dict);</span>
<span class='covered'>     * // =&gt; 2</span>
<span class='covered'>     */</span>
<span class='covered'>    function sortedIndex(array, value, callback, thisArg) {</span>
<span class='uncovered'>      var low = 0,</span>
<span class='uncovered'>          high = array ? array.length : low;</span>
<span class='covered'>  </span>
<span class='covered'>      // explicitly reference `identity` for better engine inlining</span>
<span class='uncovered'>      callback = callback ? createCallback(callback, thisArg) : identity;</span>
<span class='uncovered'>      value = callback(value);</span>
<span class='uncovered'>      while (low &lt; high) {</span>
<span class='uncovered'>        var mid = (low + high) &gt;&gt;&gt; 1;</span>
<span class='uncovered'>        callback(array[mid]) &lt; value</span>
<span class='uncovered'>          ? low = mid + 1</span>
<span class='uncovered'>          : high = mid;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return low;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Computes the union of the passed-in arrays using strict equality for</span>
<span class='covered'>     * comparisons, i.e. `===`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} [array1, array2, ...] Arrays to process.</span>
<span class='covered'>     * @returns {Array} Returns a new array of unique values, in order, that are</span>
<span class='covered'>     *  present in one or more of the arrays.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);</span>
<span class='covered'>     * // =&gt; [1, 2, 3, 101, 10]</span>
<span class='covered'>     */</span>
<span class='covered'>    function union() {</span>
<span class='uncovered'>      return uniq(concat.apply(arrayRef, arguments));</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a duplicate-value-free version of the `array` using strict equality</span>
<span class='covered'>     * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`</span>
<span class='covered'>     * for `isSorted` will run a faster algorithm. If `callback` is passed, each</span>
<span class='covered'>     * element of `array` is passed through a callback` before uniqueness is computed.</span>
<span class='covered'>     * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @alias unique</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to process.</span>
<span class='covered'>     * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.</span>
<span class='covered'>     * @param {Function} [callback=identity] The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Array} Returns a duplicate-value-free array.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.uniq([1, 2, 1, 3, 1]);</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.uniq([1, 1, 2, 2, 3], true);</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return Math.floor(num); });</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return this.floor(num); }, Math);</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     */</span>
<span class='covered'>    function uniq(array, isSorted, callback, thisArg) {</span>
<span class='covered'>      var index = -1,</span>
<span class='partial'>          length = array ? array.length : <span class='partialuncovered'>0,</span></span>
<span class='covered'>          result = [],</span>
<span class='covered'>          seen = result;</span>
<span class='covered'>  </span>
<span class='covered'>      // juggle arguments</span>
<span class='covered'>      if (typeof isSorted == &#39;function&#39;) {</span>
<span class='uncovered'>        thisArg = callback;</span>
<span class='uncovered'>        callback = isSorted;</span>
<span class='uncovered'>        isSorted = false;</span>
<span class='covered'>      }</span>
<span class='covered'>      // init value cache for large arrays</span>
<span class='covered'>      var isLarge = !isSorted &amp;&amp; length &gt; 74;</span>
<span class='covered'>      if (isLarge) {</span>
<span class='uncovered'>        var cache = {};</span>
<span class='covered'>      }</span>
<span class='covered'>      if (callback) {</span>
<span class='uncovered'>        seen = [];</span>
<span class='uncovered'>        callback = createCallback(callback, thisArg);</span>
<span class='covered'>      }</span>
<span class='covered'>      while (++index &lt; length) {</span>
<span class='covered'>        var value = array[index],</span>
<span class='partial'>            computed = callback ? <span class='partialuncovered'>callback(value, index, array) </span>: value;</span>
<span class='covered'>  </span>
<span class='covered'>        if (isLarge) {</span>
<span class='covered'>          // manually coerce `computed` to a string because `hasOwnProperty`, in</span>
<span class='covered'>          // some older versions of Firefox, coerces objects incorrectly</span>
<span class='uncovered'>          seen = hasOwnProperty.call(cache, computed + &#39;&#39;) ? cache[computed] : (cache[computed] = []);</span>
<span class='covered'>        }</span>
<span class='covered'>        if (isSorted</span>
<span class='uncovered'>              ? !index || seen[seen.length - 1] !== computed</span>
<span class='covered'>              : indexOf(seen, computed) &lt; 0</span>
<span class='covered'>            ) {</span>
<span class='covered'>          if (callback || isLarge) {</span>
<span class='uncovered'>            seen.push(computed);</span>
<span class='covered'>          }</span>
<span class='covered'>          result.push(value);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates an array with all occurrences of the passed values removed using</span>
<span class='covered'>     * strict equality for comparisons, i.e. `===`.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} array The array to filter.</span>
<span class='covered'>     * @param {Mixed} [value1, value2, ...] Values to remove.</span>
<span class='covered'>     * @returns {Array} Returns a new filtered array.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);</span>
<span class='covered'>     * // =&gt; [2, 3, 4]</span>
<span class='covered'>     */</span>
<span class='covered'>    function without(array) {</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          length = array ? array.length : 0,</span>
<span class='uncovered'>          contains = cachedContains(arguments, 1, 20),</span>
<span class='uncovered'>          result = [];</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        var value = array[index];</span>
<span class='uncovered'>        if (!contains(value)) {</span>
<span class='uncovered'>          result.push(value);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Groups the elements of each array at their corresponding indexes. Useful for</span>
<span class='covered'>     * separate data sources that are coordinated through matching array indexes.</span>
<span class='covered'>     * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix</span>
<span class='covered'>     * in a similar fashion.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Arrays</span>
<span class='covered'>     * @param {Array} [array1, array2, ...] Arrays to process.</span>
<span class='covered'>     * @returns {Array} Returns a new array of grouped elements.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.zip([&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;], [30, 40, 50], [true, false, false]);</span>
<span class='covered'>     * // =&gt; [[&#39;moe&#39;, 30, true], [&#39;larry&#39;, 40, false], [&#39;curly&#39;, 50, false]]</span>
<span class='covered'>     */</span>
<span class='covered'>    function zip(array) {</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          length = array ? max(pluck(arguments, &#39;length&#39;)) : 0,</span>
<span class='uncovered'>          result = Array(length);</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        result[index] = pluck(arguments, index);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that is restricted to executing `func` only after it is</span>
<span class='covered'>     * called `n` times. The `func` is executed with the `this` binding of the</span>
<span class='covered'>     * created function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Number} n The number of times the function must be called before</span>
<span class='covered'>     * it is executed.</span>
<span class='covered'>     * @param {Function} func The function to restrict.</span>
<span class='covered'>     * @returns {Function} Returns the new restricted function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var renderNotes = _.after(notes.length, render);</span>
<span class='covered'>     * _.forEach(notes, function(note) {</span>
<span class='covered'>     *   note.asyncSave({ &#39;success&#39;: renderNotes });</span>
<span class='covered'>     * });</span>
<span class='covered'>     * // `renderNotes` is run once, after all notes have saved</span>
<span class='covered'>     */</span>
<span class='covered'>    function after(n, func) {</span>
<span class='uncovered'>      if (n &lt; 1) {</span>
<span class='uncovered'>        return func();</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return function() {</span>
<span class='uncovered'>        if (--n &lt; 1) {</span>
<span class='uncovered'>          return func.apply(this, arguments);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that, when called, invokes `func` with the `this`</span>
<span class='covered'>     * binding of `thisArg` and prepends any additional `bind` arguments to those</span>
<span class='covered'>     * passed to the bound function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to bind.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `func`.</span>
<span class='covered'>     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.</span>
<span class='covered'>     * @returns {Function} Returns the new bound function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var func = function(greeting) {</span>
<span class='covered'>     *   return greeting + &#39; &#39; + this.name;</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * func = _.bind(func, { &#39;name&#39;: &#39;moe&#39; }, &#39;hi&#39;);</span>
<span class='covered'>     * func();</span>
<span class='covered'>     * // =&gt; &#39;hi moe&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function bind(func, thisArg) {</span>
<span class='covered'>      // use `Function#bind` if it exists and is fast</span>
<span class='covered'>      // (in V8 `Function#bind` is slower except when partially applied)</span>
<span class='uncovered'>      return isBindFast || (nativeBind &amp;&amp; arguments.length &gt; 2)</span>
<span class='uncovered'>        ? nativeBind.call.apply(nativeBind, arguments)</span>
<span class='uncovered'>        : createBound(func, thisArg, slice.call(arguments, 2));</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Binds methods on `object` to `object`, overwriting the existing method.</span>
<span class='covered'>     * If no method names are provided, all the function properties of `object`</span>
<span class='covered'>     * will be bound.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Object} object The object to bind and assign the bound methods to.</span>
<span class='covered'>     * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.</span>
<span class='covered'>     * @returns {Object} Returns `object`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var buttonView = {</span>
<span class='covered'>     *  &#39;label&#39;: &#39;lodash&#39;,</span>
<span class='covered'>     *  &#39;onClick&#39;: function() { alert(&#39;clicked: &#39; + this.label); }</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.bindAll(buttonView);</span>
<span class='covered'>     * jQuery(&#39;#lodash_button&#39;).on(&#39;click&#39;, buttonView.onClick);</span>
<span class='covered'>     * // =&gt; When the button is clicked, `this.label` will have the correct value</span>
<span class='covered'>     */</span>
<span class='covered'>    function bindAll(object) {</span>
<span class='uncovered'>      var funcs = arguments,</span>
<span class='uncovered'>          index = funcs.length &gt; 1 ? 0 : (funcs = functions(object), -1),</span>
<span class='uncovered'>          length = funcs.length;</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; length) {</span>
<span class='uncovered'>        var key = funcs[index];</span>
<span class='uncovered'>        object[key] = bind(object[key], object);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return object;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that is the composition of the passed functions,</span>
<span class='covered'>     * where each function consumes the return value of the function that follows.</span>
<span class='covered'>     * In math terms, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.</span>
<span class='covered'>     * Each function is executed with the `this` binding of the composed function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} [func1, func2, ...] Functions to compose.</span>
<span class='covered'>     * @returns {Function} Returns the new composed function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var greet = function(name) { return &#39;hi: &#39; + name; };</span>
<span class='covered'>     * var exclaim = function(statement) { return statement + &#39;!&#39;; };</span>
<span class='covered'>     * var welcome = _.compose(exclaim, greet);</span>
<span class='covered'>     * welcome(&#39;moe&#39;);</span>
<span class='covered'>     * // =&gt; &#39;hi: moe!&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function compose() {</span>
<span class='uncovered'>      var funcs = arguments;</span>
<span class='uncovered'>      return function() {</span>
<span class='uncovered'>        var args = arguments,</span>
<span class='uncovered'>            length = funcs.length;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        while (length--) {</span>
<span class='uncovered'>          args = [funcs[length].apply(this, args)];</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        return args[0];</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that will delay the execution of `func` until after</span>
<span class='covered'>     * `wait` milliseconds have elapsed since the last time it was invoked. Pass</span>
<span class='covered'>     * `true` for `immediate` to cause debounce to invoke `func` on the leading,</span>
<span class='covered'>     * instead of the trailing, edge of the `wait` timeout. Subsequent calls to</span>
<span class='covered'>     * the debounced function will return the result of the last `func` call.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to debounce.</span>
<span class='covered'>     * @param {Number} wait The number of milliseconds to delay.</span>
<span class='covered'>     * @param {Boolean} immediate A flag to indicate execution is on the leading</span>
<span class='covered'>     *  edge of the timeout.</span>
<span class='covered'>     * @returns {Function} Returns the new debounced function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var lazyLayout = _.debounce(calculateLayout, 300);</span>
<span class='covered'>     * jQuery(window).on(&#39;resize&#39;, lazyLayout);</span>
<span class='covered'>     */</span>
<span class='covered'>    function debounce(func, wait, immediate) {</span>
<span class='uncovered'>      var args,</span>
<span class='uncovered'>          result,</span>
<span class='uncovered'>          thisArg,</span>
<span class='uncovered'>          timeoutId;</span>
<span class='covered'>  </span>
<span class='covered'>      function delayed() {</span>
<span class='uncovered'>        timeoutId = null;</span>
<span class='covered'>        if (!immediate) {</span>
<span class='uncovered'>          result = func.apply(thisArg, args);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return function() {</span>
<span class='uncovered'>        var isImmediate = immediate &amp;&amp; !timeoutId;</span>
<span class='uncovered'>        args = arguments;</span>
<span class='uncovered'>        thisArg = this;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        clearTimeout(timeoutId);</span>
<span class='uncovered'>        timeoutId = setTimeout(delayed, wait);</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        if (isImmediate) {</span>
<span class='uncovered'>          result = func.apply(thisArg, args);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        return result;</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Executes the `func` function after `wait` milliseconds. Additional arguments</span>
<span class='covered'>     * will be passed to `func` when it is invoked.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to delay.</span>
<span class='covered'>     * @param {Number} wait The number of milliseconds to delay execution.</span>
<span class='covered'>     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.</span>
<span class='covered'>     * @returns {Number} Returns the `setTimeout` timeout id.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var log = _.bind(console.log, console);</span>
<span class='covered'>     * _.delay(log, 1000, &#39;logged later&#39;);</span>
<span class='covered'>     * // =&gt; &#39;logged later&#39; (Appears after one second.)</span>
<span class='covered'>     */</span>
<span class='covered'>    function delay(func, wait) {</span>
<span class='uncovered'>      var args = slice.call(arguments, 2);</span>
<span class='uncovered'>      return setTimeout(function() { func.apply(undefined, args); }, wait);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Defers executing the `func` function until the current call stack has cleared.</span>
<span class='covered'>     * Additional arguments will be passed to `func` when it is invoked.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to defer.</span>
<span class='covered'>     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.</span>
<span class='covered'>     * @returns {Number} Returns the `setTimeout` timeout id.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.defer(function() { alert(&#39;deferred&#39;); });</span>
<span class='covered'>     * // returns from the function before `alert` is called</span>
<span class='covered'>     */</span>
<span class='covered'>    function defer(func) {</span>
<span class='uncovered'>      var args = slice.call(arguments, 1);</span>
<span class='uncovered'>      return setTimeout(function() { func.apply(undefined, args); }, 1);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that, when called, invokes `object[methodName]` and</span>
<span class='covered'>     * prepends any additional `lateBind` arguments to those passed to the bound</span>
<span class='covered'>     * function. This method differs from `_.bind` by allowing bound functions to</span>
<span class='covered'>     * reference methods that will be redefined or don&#39;t yet exist.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Object} object The object the method belongs to.</span>
<span class='covered'>     * @param {String} methodName The method name.</span>
<span class='covered'>     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.</span>
<span class='covered'>     * @returns {Function} Returns the new bound function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var object = {</span>
<span class='covered'>     *   &#39;name&#39;: &#39;moe&#39;,</span>
<span class='covered'>     *   &#39;greet&#39;: function(greeting) {</span>
<span class='covered'>     *     return greeting + &#39; &#39; + this.name;</span>
<span class='covered'>     *   }</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * var func = _.lateBind(object, &#39;greet&#39;, &#39;hi&#39;);</span>
<span class='covered'>     * func();</span>
<span class='covered'>     * // =&gt; &#39;hi moe&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * object.greet = function(greeting) {</span>
<span class='covered'>     *   return greeting + &#39;, &#39; + this.name + &#39;!&#39;;</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * func();</span>
<span class='covered'>     * // =&gt; &#39;hi, moe!&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function lateBind(object, methodName) {</span>
<span class='uncovered'>      return createBound(methodName, object, slice.call(arguments, 2));</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that memoizes the result of `func`. If `resolver` is</span>
<span class='covered'>     * passed, it will be used to determine the cache key for storing the result</span>
<span class='covered'>     * based on the arguments passed to the memoized function. By default, the first</span>
<span class='covered'>     * argument passed to the memoized function is used as the cache key. The `func`</span>
<span class='covered'>     * is executed with the `this` binding of the memoized function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to have its output memoized.</span>
<span class='covered'>     * @param {Function} [resolver] A function used to resolve the cache key.</span>
<span class='covered'>     * @returns {Function} Returns the new memoizing function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var fibonacci = _.memoize(function(n) {</span>
<span class='covered'>     *   return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);</span>
<span class='covered'>     * });</span>
<span class='covered'>     */</span>
<span class='covered'>    function memoize(func, resolver) {</span>
<span class='uncovered'>      var cache = {};</span>
<span class='uncovered'>      return function() {</span>
<span class='uncovered'>        var key = resolver ? resolver.apply(this, arguments) : arguments[0];</span>
<span class='uncovered'>        return hasOwnProperty.call(cache, key)</span>
<span class='uncovered'>          ? cache[key]</span>
<span class='uncovered'>          : (cache[key] = func.apply(this, arguments));</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that is restricted to execute `func` once. Repeat calls to</span>
<span class='covered'>     * the function will return the value of the first call. The `func` is executed</span>
<span class='covered'>     * with the `this` binding of the created function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to restrict.</span>
<span class='covered'>     * @returns {Function} Returns the new restricted function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var initialize = _.once(createApplication);</span>
<span class='covered'>     * initialize();</span>
<span class='covered'>     * initialize();</span>
<span class='covered'>     * // Application is only created once.</span>
<span class='covered'>     */</span>
<span class='covered'>    function once(func) {</span>
<span class='uncovered'>      var result,</span>
<span class='uncovered'>          ran = false;</span>
<span class='covered'>  </span>
<span class='uncovered'>      return function() {</span>
<span class='uncovered'>        if (ran) {</span>
<span class='uncovered'>          return result;</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        ran = true;</span>
<span class='uncovered'>        result = func.apply(this, arguments);</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        // clear the `func` variable so the function may be garbage collected</span>
<span class='uncovered'>        func = null;</span>
<span class='uncovered'>        return result;</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that, when called, invokes `func` with any additional</span>
<span class='covered'>     * `partial` arguments prepended to those passed to the new function. This</span>
<span class='covered'>     * method is similar to `bind`, except it does **not** alter the `this` binding.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to partially apply arguments to.</span>
<span class='covered'>     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.</span>
<span class='covered'>     * @returns {Function} Returns the new partially applied function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var greet = function(greeting, name) { return greeting + &#39;: &#39; + name; };</span>
<span class='covered'>     * var hi = _.partial(greet, &#39;hi&#39;);</span>
<span class='covered'>     * hi(&#39;moe&#39;);</span>
<span class='covered'>     * // =&gt; &#39;hi: moe&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function partial(func) {</span>
<span class='uncovered'>      return createBound(func, slice.call(arguments, 1));</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that, when executed, will only call the `func`</span>
<span class='covered'>     * function at most once per every `wait` milliseconds. If the throttled</span>
<span class='covered'>     * function is invoked more than once during the `wait` timeout, `func` will</span>
<span class='covered'>     * also be called on the trailing edge of the timeout. Subsequent calls to the</span>
<span class='covered'>     * throttled function will return the result of the last `func` call.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Function} func The function to throttle.</span>
<span class='covered'>     * @param {Number} wait The number of milliseconds to throttle executions to.</span>
<span class='covered'>     * @returns {Function} Returns the new throttled function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var throttled = _.throttle(updatePosition, 100);</span>
<span class='covered'>     * jQuery(window).on(&#39;scroll&#39;, throttled);</span>
<span class='covered'>     */</span>
<span class='covered'>    function throttle(func, wait) {</span>
<span class='uncovered'>      var args,</span>
<span class='uncovered'>          result,</span>
<span class='uncovered'>          thisArg,</span>
<span class='uncovered'>          timeoutId,</span>
<span class='uncovered'>          lastCalled = 0;</span>
<span class='covered'>  </span>
<span class='covered'>      function trailingCall() {</span>
<span class='uncovered'>        lastCalled = new Date;</span>
<span class='uncovered'>        timeoutId = null;</span>
<span class='uncovered'>        result = func.apply(thisArg, args);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return function() {</span>
<span class='uncovered'>        var now = new Date,</span>
<span class='uncovered'>            remaining = wait - (now - lastCalled);</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        args = arguments;</span>
<span class='uncovered'>        thisArg = this;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        if (remaining &lt;= 0) {</span>
<span class='uncovered'>          clearTimeout(timeoutId);</span>
<span class='uncovered'>          lastCalled = now;</span>
<span class='uncovered'>          result = func.apply(thisArg, args);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        else if (!timeoutId) {</span>
<span class='uncovered'>          timeoutId = setTimeout(trailingCall, remaining);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        return result;</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Creates a function that passes `value` to the `wrapper` function as its</span>
<span class='covered'>     * first argument. Additional arguments passed to the function are appended</span>
<span class='covered'>     * to those passed to the `wrapper` function. The `wrapper` is executed with</span>
<span class='covered'>     * the `this` binding of the created function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Functions</span>
<span class='covered'>     * @param {Mixed} value The value to wrap.</span>
<span class='covered'>     * @param {Function} wrapper The wrapper function.</span>
<span class='covered'>     * @returns {Function} Returns the new function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var hello = function(name) { return &#39;hello &#39; + name; };</span>
<span class='covered'>     * hello = _.wrap(hello, function(func) {</span>
<span class='covered'>     *   return &#39;before, &#39; + func(&#39;moe&#39;) + &#39;, after&#39;;</span>
<span class='covered'>     * });</span>
<span class='covered'>     * hello();</span>
<span class='covered'>     * // =&gt; &#39;before, hello moe, after&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function wrap(value, wrapper) {</span>
<span class='uncovered'>      return function() {</span>
<span class='uncovered'>        var args = [value];</span>
<span class='uncovered'>        push.apply(args, arguments);</span>
<span class='uncovered'>        return wrapper.apply(this, args);</span>
<span class='uncovered'>      };</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Converts the characters `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their</span>
<span class='covered'>     * corresponding HTML entities.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {String} string The string to escape.</span>
<span class='covered'>     * @returns {String} Returns the escaped string.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.escape(&#39;Moe, Larry &amp; Curly&#39;);</span>
<span class='covered'>     * // =&gt; &quot;Moe, Larry &amp;amp; Curly&quot;</span>
<span class='covered'>     */</span>
<span class='covered'>    function escape(string) {</span>
<span class='uncovered'>      return string == null ? &#39;&#39; : (string + &#39;&#39;).replace(reUnescapedHtml, escapeHtmlChar);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * This function returns the first argument passed to it.</span>
<span class='covered'>     *</span>
<span class='covered'>     * Note: It is used throughout Lo-Dash as a default callback.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {Mixed} value Any value.</span>
<span class='covered'>     * @returns {Mixed} Returns `value`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var moe = { &#39;name&#39;: &#39;moe&#39; };</span>
<span class='covered'>     * moe === _.identity(moe);</span>
<span class='covered'>     * // =&gt; true</span>
<span class='covered'>     */</span>
<span class='covered'>    function identity(value) {</span>
<span class='uncovered'>      return value;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Adds functions properties of `object` to the `lodash` function and chainable</span>
<span class='covered'>     * wrapper.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {Object} object The object of function properties to add to `lodash`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.mixin({</span>
<span class='covered'>     *   &#39;capitalize&#39;: function(string) {</span>
<span class='covered'>     *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();</span>
<span class='covered'>     *   }</span>
<span class='covered'>     * });</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.capitalize(&#39;larry&#39;);</span>
<span class='covered'>     * // =&gt; &#39;Larry&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * _(&#39;curly&#39;).capitalize();</span>
<span class='covered'>     * // =&gt; &#39;Curly&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function mixin(object) {</span>
<span class='covered'>      forEach(functions(object), function(methodName) {</span>
<span class='covered'>        var func = lodash[methodName] = object[methodName];</span>
<span class='covered'>  </span>
<span class='covered'>        lodash.prototype[methodName] = function() {</span>
<span class='covered'>          var args = [this.__wrapped__];</span>
<span class='covered'>          push.apply(args, arguments);</span>
<span class='covered'>  </span>
<span class='covered'>          var result = func.apply(lodash, args);</span>
<span class='covered'>          if (this.__chain__) {</span>
<span class='covered'>            result = new lodash(result);</span>
<span class='covered'>            result.__chain__ = true;</span>
<span class='covered'>          }</span>
<span class='covered'>          return result;</span>
<span class='covered'>        };</span>
<span class='covered'>      });</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Reverts the &#39;_&#39; variable to its previous value and returns a reference to</span>
<span class='covered'>     * the `lodash` function.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @returns {Function} Returns the `lodash` function.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var lodash = _.noConflict();</span>
<span class='covered'>     */</span>
<span class='covered'>    function noConflict() {</span>
<span class='uncovered'>      window._ = oldDash;</span>
<span class='uncovered'>      return this;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Produces a random number between `min` and `max` (inclusive). If only one</span>
<span class='covered'>     * argument is passed, a number between `0` and the given number will be returned.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {Number} [min=0] The minimum possible value.</span>
<span class='covered'>     * @param {Number} [max=1] The maximum possible value.</span>
<span class='covered'>     * @returns {Number} Returns a random number.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.random(0, 5);</span>
<span class='covered'>     * // =&gt; a number between 1 and 5</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.random(5);</span>
<span class='covered'>     * // =&gt; also a number between 1 and 5</span>
<span class='covered'>     */</span>
<span class='covered'>    function random(min, max) {</span>
<span class='uncovered'>      if (min == null &amp;&amp; max == null) {</span>
<span class='uncovered'>        max = 1;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      min = +min || 0;</span>
<span class='uncovered'>      if (max == null) {</span>
<span class='uncovered'>        max = min;</span>
<span class='uncovered'>        min = 0;</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return min + floor(nativeRandom() * ((+max || 0) - min + 1));</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Resolves the value of `property` on `object`. If `property` is a function</span>
<span class='covered'>     * it will be invoked and its result returned, else the property value is</span>
<span class='covered'>     * returned. If `object` is falsey, then `null` is returned.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @deprecated</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {Object} object The object to inspect.</span>
<span class='covered'>     * @param {String} property The property to get the value of.</span>
<span class='covered'>     * @returns {Mixed} Returns the resolved value.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var object = {</span>
<span class='covered'>     *   &#39;cheese&#39;: &#39;crumpets&#39;,</span>
<span class='covered'>     *   &#39;stuff&#39;: function() {</span>
<span class='covered'>     *     return &#39;nonsense&#39;;</span>
<span class='covered'>     *   }</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.result(object, &#39;cheese&#39;);</span>
<span class='covered'>     * // =&gt; &#39;crumpets&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.result(object, &#39;stuff&#39;);</span>
<span class='covered'>     * // =&gt; &#39;nonsense&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function result(object, property) {</span>
<span class='covered'>      // based on Backbone&#39;s private `getValue` function</span>
<span class='covered'>      // https://github.com/documentcloud/backbone/blob/0.9.2/backbone.js#L1419-1424</span>
<span class='uncovered'>      var value = object ? object[property] : null;</span>
<span class='uncovered'>      return isFunction(value) ? object[property]() : value;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * A micro-templating method that handles arbitrary delimiters, preserves</span>
<span class='covered'>     * whitespace, and correctly escapes quotes within interpolated code.</span>
<span class='covered'>     *</span>
<span class='covered'>     * Note: In the development build `_.template` utilizes sourceURLs for easier</span>
<span class='covered'>     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl</span>
<span class='covered'>     *</span>
<span class='covered'>     * Note: Lo-Dash may be used in Chrome extensions by either creating a `lodash csp`</span>
<span class='covered'>     * build and avoiding `_.template` use, or loading Lo-Dash in a sandboxed page.</span>
<span class='covered'>     * See http://developer.chrome.com/trunk/extensions/sandboxingEval.html</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {String} text The template text.</span>
<span class='covered'>     * @param {Obect} data The data object used to populate the text.</span>
<span class='covered'>     * @param {Object} options The options object.</span>
<span class='covered'>     *  escape - The &quot;escape&quot; delimiter regexp.</span>
<span class='covered'>     *  evaluate - The &quot;evaluate&quot; delimiter regexp.</span>
<span class='covered'>     *  interpolate - The &quot;interpolate&quot; delimiter regexp.</span>
<span class='covered'>     *  sourceURL - The sourceURL of the template&#39;s compiled source.</span>
<span class='covered'>     *  variable - The data object variable name.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @returns {Function|String} Returns a compiled function when no `data` object</span>
<span class='covered'>     *  is given, else it returns the interpolated text.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using a compiled template</span>
<span class='covered'>     * var compiled = _.template(&#39;hello &lt;%= name %&gt;&#39;);</span>
<span class='covered'>     * compiled({ &#39;name&#39;: &#39;moe&#39; });</span>
<span class='covered'>     * // =&gt; &#39;hello moe&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * var list = &#39;&lt;% _.forEach(people, function(name) { %&gt;&lt;li&gt;&lt;%= name %&gt;&lt;/li&gt;&lt;% }); %&gt;&#39;;</span>
<span class='covered'>     * _.template(list, { &#39;people&#39;: [&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;] });</span>
<span class='covered'>     * // =&gt; &#39;&lt;li&gt;moe&lt;/li&gt;&lt;li&gt;larry&lt;/li&gt;&lt;li&gt;curly&lt;/li&gt;&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using the &quot;escape&quot; delimiter to escape HTML in data property values</span>
<span class='covered'>     * _.template(&#39;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&#39;, { &#39;value&#39;: &#39;&lt;script&gt;&#39; });</span>
<span class='covered'>     * // =&gt; &#39;&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using the ES6 delimiter as an alternative to the default &quot;interpolate&quot; delimiter</span>
<span class='covered'>     * _.template(&#39;hello ${ name }&#39;, { &#39;name&#39;: &#39;curly&#39; });</span>
<span class='covered'>     * // =&gt; &#39;hello curly&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using the internal `print` function in &quot;evaluate&quot; delimiters</span>
<span class='covered'>     * _.template(&#39;&lt;% print(&quot;hello &quot; + epithet); %&gt;!&#39;, { &#39;epithet&#39;: &#39;stooge&#39; });</span>
<span class='covered'>     * // =&gt; &#39;hello stooge!&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using custom template delimiters</span>
<span class='covered'>     * _.templateSettings = {</span>
<span class='covered'>     *   &#39;interpolate&#39;: /{{([\s\S]+?)}}/g</span>
<span class='covered'>     * };</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.template(&#39;hello {{ name }}!&#39;, { &#39;name&#39;: &#39;mustache&#39; });</span>
<span class='covered'>     * // =&gt; &#39;hello mustache!&#39;</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using the `sourceURL` option to specify a custom sourceURL for the template</span>
<span class='covered'>     * var compiled = _.template(&#39;hello &lt;%= name %&gt;&#39;, null, { &#39;sourceURL&#39;: &#39;/basic/greeting.jst&#39; });</span>
<span class='covered'>     * compiled(data);</span>
<span class='covered'>     * // =&gt; find the source of &quot;greeting.jst&quot; under the Sources tab or Resources panel of the web inspector</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using the `variable` option to ensure a with-statement isn&#39;t used in the compiled template</span>
<span class='covered'>     * var compiled = _.template(&#39;hello &lt;%= data.name %&gt;!&#39;, null, { &#39;variable&#39;: &#39;data&#39; });</span>
<span class='covered'>     * compiled.source;</span>
<span class='covered'>     * // =&gt; function(data) {</span>
<span class='covered'>     *   var __t, __p = &#39;&#39;, __e = _.escape;</span>
<span class='covered'>     *   __p += &#39;hello &#39; + ((__t = ( data.name )) == null ? &#39;&#39; : __t) + &#39;!&#39;;</span>
<span class='covered'>     *   return __p;</span>
<span class='covered'>     * }</span>
<span class='covered'>     *</span>
<span class='covered'>     * // using the `source` property to inline compiled templates for meaningful</span>
<span class='covered'>     * // line numbers in error messages and a stack trace</span>
<span class='covered'>     * fs.writeFileSync(path.join(cwd, &#39;jst.js&#39;), &#39;\</span>
<span class='covered'>     *   var JST = {\</span>
<span class='covered'>     *     &quot;main&quot;: &#39; + _.template(mainText).source + &#39;\</span>
<span class='covered'>     *   };\</span>
<span class='covered'>     * &#39;);</span>
<span class='covered'>     */</span>
<span class='covered'>    function template(text, data, options) {</span>
<span class='covered'>      // based on John Resig&#39;s `tmpl` implementation</span>
<span class='covered'>      // http://ejohn.org/blog/javascript-micro-templating/</span>
<span class='covered'>      // and Laura Doktorova&#39;s doT.js</span>
<span class='covered'>      // https://github.com/olado/doT</span>
<span class='covered'>      text || (text = &#39;&#39;);</span>
<span class='covered'>      options || (options = {});</span>
<span class='covered'>  </span>
<span class='covered'>      var isEvaluating,</span>
<span class='covered'>          result,</span>
<span class='covered'>          settings = lodash.templateSettings,</span>
<span class='covered'>          index = 0,</span>
<span class='covered'>          interpolate = options.interpolate || settings.interpolate || reNoMatch,</span>
<span class='covered'>          source = &quot;__p += &#39;&quot;,</span>
<span class='covered'>          variable = options.variable || settings.variable,</span>
<span class='covered'>          hasVariable = variable;</span>
<span class='covered'>  </span>
<span class='covered'>      // compile regexp to match each delimiter</span>
<span class='covered'>      var reDelimiters = RegExp(</span>
<span class='covered'>        (options.escape || settings.escape || reNoMatch).source + &#39;|&#39; +</span>
<span class='covered'>        interpolate.source + &#39;|&#39; +</span>
<span class='partial'>        (interpolate === reInterpolate ? reEsTemplate : <span class='partialuncovered'>reNoMatch)</span>.source + &#39;|&#39; +</span>
<span class='covered'>        (options.evaluate || settings.evaluate || reNoMatch).source + &#39;|$&#39;</span>
<span class='covered'>      , &#39;g&#39;);</span>
<span class='covered'>  </span>
<span class='covered'>      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {</span>
<span class='covered'>        interpolateValue || (interpolateValue = esTemplateValue);</span>
<span class='covered'>  </span>
<span class='covered'>        // escape characters that cannot be included in string literals</span>
<span class='covered'>        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);</span>
<span class='covered'>  </span>
<span class='covered'>        // replace delimiters with snippets</span>
<span class='covered'>        source +=</span>
<span class='uncovered'>          escapeValue ? &quot;&#39; +\n__e(&quot; + escapeValue + &quot;) +\n&#39;&quot; :</span>
<span class='covered'>          evaluateValue ? &quot;&#39;;\n&quot; + evaluateValue + &quot;;\n__p += &#39;&quot; :</span>
<span class='covered'>          interpolateValue ? &quot;&#39; +\n((__t = (&quot; + interpolateValue + &quot;)) == null ? &#39;&#39; : __t) +\n&#39;&quot; : &#39;&#39;;</span>
<span class='covered'>  </span>
<span class='partial'>        isEvaluating || (isEvaluating = evaluateValue || <span class='partialuncovered'>reComplexDelimiter.test(escapeValue || interpolateValue))</span><span class='partialuncovered'>escapeValue || interpolateValue)</span>);</span>
<span class='covered'>        index = offset + match.length;</span>
<span class='covered'>      });</span>
<span class='covered'>  </span>
<span class='covered'>      source += &quot;&#39;;\n&quot;;</span>
<span class='covered'>  </span>
<span class='covered'>      // if `variable` is not specified and the template contains &quot;evaluate&quot;</span>
<span class='covered'>      // delimiters, wrap a with-statement around the generated code to add the</span>
<span class='covered'>      // data object to the top of the scope chain</span>
<span class='covered'>      if (!hasVariable) {</span>
<span class='covered'>        variable = &#39;obj&#39;;</span>
<span class='covered'>        if (isEvaluating) {</span>
<span class='covered'>          source = &#39;with (&#39; + variable + &#39;) {\n&#39; + source + &#39;\n}\n&#39;;</span>
<span class='covered'>        }</span>
<span class='covered'>        else {</span>
<span class='covered'>          // avoid a with-statement by prepending data object references to property names</span>
<span class='uncovered'>          var reDoubleVariable = RegExp(&#39;(\\(\\s*)&#39; + variable + &#39;\\.&#39; + variable + &#39;\\b&#39;, &#39;g&#39;);</span>
<span class='uncovered'>          source = source</span>
<span class='uncovered'>            .replace(reInsertVariable, &#39;$&amp;&#39; + variable + &#39;.&#39;)</span>
<span class='uncovered'>            .replace(reDoubleVariable, &#39;$1__d&#39;);</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      // cleanup code by stripping empty strings</span>
<span class='partial'>      source = (isEvaluating ? source.replace(reEmptyStringLeading, &#39;&#39;) : <span class='partialuncovered'>source)</span></span>
<span class='covered'>        .replace(reEmptyStringMiddle, &#39;$1&#39;)</span>
<span class='covered'>        .replace(reEmptyStringTrailing, &#39;$1;&#39;);</span>
<span class='covered'>  </span>
<span class='covered'>      // frame code as the function body</span>
<span class='covered'>      source = &#39;function(&#39; + variable + &#39;) {\n&#39; +</span>
<span class='partial'>        (hasVariable ? <span class='partialuncovered'>&#39;&#39; </span>: variable + &#39; || (&#39; + variable + &#39; = {});\n&#39;) +</span>
<span class='covered'>        &#39;var __t, __p = \&#39;\&#39;, __e = _.escape&#39; +</span>
<span class='covered'>        (isEvaluating</span>
<span class='covered'>          ? &#39;, __j = Array.prototype.join;\n&#39; +</span>
<span class='covered'>            &#39;function print() { __p += __j.call(arguments, \&#39;\&#39;) }\n&#39;</span>
<span class='uncovered'>          : (hasVariable ? &#39;&#39; : &#39;, __d = &#39; + variable + &#39;.&#39; + variable + &#39; || &#39; + variable) + &#39;;\n&#39;</span>
<span class='covered'>        ) +</span>
<span class='covered'>        source +</span>
<span class='covered'>        &#39;return __p\n}&#39;;</span>
<span class='covered'>  </span>
<span class='covered'>      // use a sourceURL for easier debugging</span>
<span class='covered'>      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl</span>
<span class='covered'>      var sourceURL = useSourceURL</span>
<span class='covered'>        ? &#39;\n//@ sourceURL=&#39; + (options.sourceURL || &#39;/lodash/template/source[&#39; + (templateCounter++) + &#39;]&#39;)</span>
<span class='uncovered'>        : &#39;&#39;;</span>
<span class='covered'>  </span>
<span class='covered'>      try {</span>
<span class='covered'>        result = Function(&#39;_&#39;, &#39;return &#39; + source + sourceURL)(lodash);</span>
<span class='covered'>      } catch(e) {</span>
<span class='uncovered'>        e.source = source;</span>
<span class='uncovered'>        throw e;</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      if (data) {</span>
<span class='uncovered'>        return result(data);</span>
<span class='covered'>      }</span>
<span class='covered'>      // provide the compiled function&#39;s source via its `toString` method, in</span>
<span class='covered'>      // supported environments, or the `source` property as a convenience for</span>
<span class='covered'>      // inlining compiled templates during the build process</span>
<span class='covered'>      result.source = source;</span>
<span class='covered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Executes the `callback` function `n` times, returning an array of the results</span>
<span class='covered'>     * of each `callback` execution. The `callback` is bound to `thisArg` and invoked</span>
<span class='covered'>     * with one argument; (index).</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {Number} n The number of times to execute the callback.</span>
<span class='covered'>     * @param {Function} callback The function called per iteration.</span>
<span class='covered'>     * @param {Mixed} [thisArg] The `this` binding of `callback`.</span>
<span class='covered'>     * @returns {Array} Returns a new array of the results of each `callback` execution.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));</span>
<span class='covered'>     * // =&gt; [3, 6, 4]</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.times(3, function(n) { mage.castSpell(n); });</span>
<span class='covered'>     * // =&gt; calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.times(3, function(n) { this.cast(n); }, mage);</span>
<span class='covered'>     * // =&gt; also calls `mage.castSpell(n)` three times</span>
<span class='covered'>     */</span>
<span class='covered'>    function times(n, callback, thisArg) {</span>
<span class='uncovered'>      n = +n || 0;</span>
<span class='uncovered'>      var index = -1,</span>
<span class='uncovered'>          result = Array(n);</span>
<span class='covered'>  </span>
<span class='uncovered'>      while (++index &lt; n) {</span>
<span class='uncovered'>        result[index] = callback.call(thisArg, index);</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return result;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * The opposite of `_.escape`, this method converts the HTML entities</span>
<span class='covered'>     * `&amp;amp;`, `&amp;lt;`, `&amp;gt;`, `&amp;quot;`, and `&amp;#x27;` in `string` to their</span>
<span class='covered'>     * corresponding characters.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {String} string The string to unescape.</span>
<span class='covered'>     * @returns {String} Returns the unescaped string.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.unescape(&#39;Moe, Larry &amp;amp; Curly&#39;);</span>
<span class='covered'>     * // =&gt; &quot;Moe, Larry &amp; Curly&quot;</span>
<span class='covered'>     */</span>
<span class='covered'>    function unescape(string) {</span>
<span class='uncovered'>      return string == null ? &#39;&#39; : (string + &#39;&#39;).replace(reEscapedHtml, unescapeHtmlChar);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Generates a unique id. If `prefix` is passed, the id will be appended to it.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Utilities</span>
<span class='covered'>     * @param {String} [prefix] The value to prefix the id with.</span>
<span class='covered'>     * @returns {Number|String} Returns a numeric id if no prefix is passed, else</span>
<span class='covered'>     *  a string id may be returned.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.uniqueId(&#39;contact_&#39;);</span>
<span class='covered'>     * // =&gt; &#39;contact_104&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function uniqueId(prefix) {</span>
<span class='uncovered'>      var id = idCounter++;</span>
<span class='uncovered'>      return prefix ? prefix + id : id;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Wraps the value in a `lodash` wrapper object.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Chaining</span>
<span class='covered'>     * @param {Mixed} value The value to wrap.</span>
<span class='covered'>     * @returns {Object} Returns the wrapper object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * var stooges = [</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50 },</span>
<span class='covered'>     *   { &#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60 }</span>
<span class='covered'>     * ];</span>
<span class='covered'>     *</span>
<span class='covered'>     * var youngest = _.chain(stooges)</span>
<span class='covered'>     *     .sortBy(function(stooge) { return stooge.age; })</span>
<span class='covered'>     *     .map(function(stooge) { return stooge.name + &#39; is &#39; + stooge.age; })</span>
<span class='covered'>     *     .first()</span>
<span class='covered'>     *     .value();</span>
<span class='covered'>     * // =&gt; &#39;moe is 40&#39;</span>
<span class='covered'>     */</span>
<span class='covered'>    function chain(value) {</span>
<span class='covered'>      value = new lodash(value);</span>
<span class='covered'>      value.__chain__ = true;</span>
<span class='covered'>      return value;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Invokes `interceptor` with the `value` as the first argument, and then</span>
<span class='covered'>     * returns `value`. The purpose of this method is to &quot;tap into&quot; a method chain,</span>
<span class='covered'>     * in order to perform operations on intermediate results within the chain.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Chaining</span>
<span class='covered'>     * @param {Mixed} value The value to pass to `interceptor`.</span>
<span class='covered'>     * @param {Function} interceptor The function to invoke.</span>
<span class='covered'>     * @returns {Mixed} Returns `value`.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _.chain([1, 2, 3, 200])</span>
<span class='covered'>     *  .filter(function(num) { return num % 2 == 0; })</span>
<span class='covered'>     *  .tap(alert)</span>
<span class='covered'>     *  .map(function(num) { return num * num })</span>
<span class='covered'>     *  .value();</span>
<span class='covered'>     * // =&gt; // [2, 200] (alerted)</span>
<span class='covered'>     * // =&gt; [4, 40000]</span>
<span class='covered'>     */</span>
<span class='covered'>    function tap(value, interceptor) {</span>
<span class='uncovered'>      interceptor(value);</span>
<span class='uncovered'>      return value;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Enables method chaining on the wrapper object.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @name chain</span>
<span class='covered'>     * @deprecated</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Chaining</span>
<span class='covered'>     * @returns {Mixed} Returns the wrapper object.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _([1, 2, 3]).value();</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     */</span>
<span class='covered'>    function wrapperChain() {</span>
<span class='uncovered'>      this.__chain__ = true;</span>
<span class='uncovered'>      return this;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * Extracts the wrapped value.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @name value</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @category Chaining</span>
<span class='covered'>     * @returns {Mixed} Returns the wrapped value.</span>
<span class='covered'>     * @example</span>
<span class='covered'>     *</span>
<span class='covered'>     * _([1, 2, 3]).value();</span>
<span class='covered'>     * // =&gt; [1, 2, 3]</span>
<span class='covered'>     */</span>
<span class='covered'>    function wrapperValue() {</span>
<span class='covered'>      return this.__wrapped__;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    /**</span>
<span class='covered'>     * The semantic version number.</span>
<span class='covered'>     *</span>
<span class='covered'>     * @static</span>
<span class='covered'>     * @memberOf _</span>
<span class='covered'>     * @type String</span>
<span class='covered'>     */</span>
<span class='covered'>    lodash.VERSION = &#39;0.9.2&#39;;</span>
<span class='covered'>  </span>
<span class='covered'>    // assign static methods</span>
<span class='covered'>    lodash.after = after;</span>
<span class='covered'>    lodash.bind = bind;</span>
<span class='covered'>    lodash.bindAll = bindAll;</span>
<span class='covered'>    lodash.chain = chain;</span>
<span class='covered'>    lodash.clone = clone;</span>
<span class='covered'>    lodash.compact = compact;</span>
<span class='covered'>    lodash.compose = compose;</span>
<span class='covered'>    lodash.contains = contains;</span>
<span class='covered'>    lodash.countBy = countBy;</span>
<span class='covered'>    lodash.debounce = debounce;</span>
<span class='covered'>    lodash.defaults = defaults;</span>
<span class='covered'>    lodash.defer = defer;</span>
<span class='covered'>    lodash.delay = delay;</span>
<span class='covered'>    lodash.difference = difference;</span>
<span class='covered'>    lodash.escape = escape;</span>
<span class='covered'>    lodash.every = every;</span>
<span class='covered'>    lodash.extend = extend;</span>
<span class='covered'>    lodash.filter = filter;</span>
<span class='covered'>    lodash.find = find;</span>
<span class='covered'>    lodash.first = first;</span>
<span class='covered'>    lodash.flatten = flatten;</span>
<span class='covered'>    lodash.forEach = forEach;</span>
<span class='covered'>    lodash.forIn = forIn;</span>
<span class='covered'>    lodash.forOwn = forOwn;</span>
<span class='covered'>    lodash.functions = functions;</span>
<span class='covered'>    lodash.groupBy = groupBy;</span>
<span class='covered'>    lodash.has = has;</span>
<span class='covered'>    lodash.identity = identity;</span>
<span class='covered'>    lodash.indexOf = indexOf;</span>
<span class='covered'>    lodash.initial = initial;</span>
<span class='covered'>    lodash.intersection = intersection;</span>
<span class='covered'>    lodash.invert = invert;</span>
<span class='covered'>    lodash.invoke = invoke;</span>
<span class='covered'>    lodash.isArguments = isArguments;</span>
<span class='covered'>    lodash.isArray = isArray;</span>
<span class='covered'>    lodash.isBoolean = isBoolean;</span>
<span class='covered'>    lodash.isDate = isDate;</span>
<span class='covered'>    lodash.isElement = isElement;</span>
<span class='covered'>    lodash.isEmpty = isEmpty;</span>
<span class='covered'>    lodash.isEqual = isEqual;</span>
<span class='covered'>    lodash.isFinite = isFinite;</span>
<span class='covered'>    lodash.isFunction = isFunction;</span>
<span class='covered'>    lodash.isNaN = isNaN;</span>
<span class='covered'>    lodash.isNull = isNull;</span>
<span class='covered'>    lodash.isNumber = isNumber;</span>
<span class='covered'>    lodash.isObject = isObject;</span>
<span class='covered'>    lodash.isPlainObject = isPlainObject;</span>
<span class='covered'>    lodash.isRegExp = isRegExp;</span>
<span class='covered'>    lodash.isString = isString;</span>
<span class='covered'>    lodash.isUndefined = isUndefined;</span>
<span class='covered'>    lodash.keys = keys;</span>
<span class='covered'>    lodash.last = last;</span>
<span class='covered'>    lodash.lastIndexOf = lastIndexOf;</span>
<span class='covered'>    lodash.lateBind = lateBind;</span>
<span class='covered'>    lodash.map = map;</span>
<span class='covered'>    lodash.max = max;</span>
<span class='covered'>    lodash.memoize = memoize;</span>
<span class='covered'>    lodash.merge = merge;</span>
<span class='covered'>    lodash.min = min;</span>
<span class='covered'>    lodash.mixin = mixin;</span>
<span class='covered'>    lodash.noConflict = noConflict;</span>
<span class='covered'>    lodash.object = object;</span>
<span class='covered'>    lodash.omit = omit;</span>
<span class='covered'>    lodash.once = once;</span>
<span class='covered'>    lodash.pairs = pairs;</span>
<span class='covered'>    lodash.partial = partial;</span>
<span class='covered'>    lodash.pick = pick;</span>
<span class='covered'>    lodash.pluck = pluck;</span>
<span class='covered'>    lodash.random = random;</span>
<span class='covered'>    lodash.range = range;</span>
<span class='covered'>    lodash.reduce = reduce;</span>
<span class='covered'>    lodash.reduceRight = reduceRight;</span>
<span class='covered'>    lodash.reject = reject;</span>
<span class='covered'>    lodash.rest = rest;</span>
<span class='covered'>    lodash.result = result;</span>
<span class='covered'>    lodash.shuffle = shuffle;</span>
<span class='covered'>    lodash.size = size;</span>
<span class='covered'>    lodash.some = some;</span>
<span class='covered'>    lodash.sortBy = sortBy;</span>
<span class='covered'>    lodash.sortedIndex = sortedIndex;</span>
<span class='covered'>    lodash.tap = tap;</span>
<span class='covered'>    lodash.template = template;</span>
<span class='covered'>    lodash.throttle = throttle;</span>
<span class='covered'>    lodash.times = times;</span>
<span class='covered'>    lodash.toArray = toArray;</span>
<span class='covered'>    lodash.unescape = unescape;</span>
<span class='covered'>    lodash.union = union;</span>
<span class='covered'>    lodash.uniq = uniq;</span>
<span class='covered'>    lodash.uniqueId = uniqueId;</span>
<span class='covered'>    lodash.values = values;</span>
<span class='covered'>    lodash.where = where;</span>
<span class='covered'>    lodash.without = without;</span>
<span class='covered'>    lodash.wrap = wrap;</span>
<span class='covered'>    lodash.zip = zip;</span>
<span class='covered'>  </span>
<span class='covered'>    // assign aliases</span>
<span class='covered'>    lodash.all = every;</span>
<span class='covered'>    lodash.any = some;</span>
<span class='covered'>    lodash.collect = map;</span>
<span class='covered'>    lodash.detect = find;</span>
<span class='covered'>    lodash.drop = rest;</span>
<span class='covered'>    lodash.each = forEach;</span>
<span class='covered'>    lodash.foldl = reduce;</span>
<span class='covered'>    lodash.foldr = reduceRight;</span>
<span class='covered'>    lodash.head = first;</span>
<span class='covered'>    lodash.include = contains;</span>
<span class='covered'>    lodash.inject = reduce;</span>
<span class='covered'>    lodash.methods = functions;</span>
<span class='covered'>    lodash.select = filter;</span>
<span class='covered'>    lodash.tail = rest;</span>
<span class='covered'>    lodash.take = first;</span>
<span class='covered'>    lodash.unique = uniq;</span>
<span class='covered'>  </span>
<span class='covered'>    // add pseudo private property to be used and removed during the build process</span>
<span class='covered'>    lodash._iteratorTemplate = iteratorTemplate;</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    // add all static functions to `lodash.prototype`</span>
<span class='covered'>    mixin(lodash);</span>
<span class='covered'>  </span>
<span class='covered'>    // add `lodash.prototype.chain` after calling `mixin()` to avoid overwriting</span>
<span class='covered'>    // it with the wrapped `lodash.chain`</span>
<span class='covered'>    lodash.prototype.chain = wrapperChain;</span>
<span class='covered'>    lodash.prototype.value = wrapperValue;</span>
<span class='covered'>  </span>
<span class='covered'>    // add all mutator Array functions to the wrapper.</span>
<span class='covered'>    forEach([&#39;pop&#39;, &#39;push&#39;, &#39;reverse&#39;, &#39;shift&#39;, &#39;sort&#39;, &#39;splice&#39;, &#39;unshift&#39;], function(methodName) {</span>
<span class='covered'>      var func = arrayRef[methodName];</span>
<span class='covered'>  </span>
<span class='covered'>      lodash.prototype[methodName] = function() {</span>
<span class='uncovered'>        var value = this.__wrapped__;</span>
<span class='uncovered'>        func.apply(value, arguments);</span>
<span class='covered'>  </span>
<span class='covered'>        // avoid array-like object bugs with `Array#shift` and `Array#splice` in</span>
<span class='covered'>        // Firefox &lt; 10 and IE &lt; 9</span>
<span class='uncovered'>        if (hasObjectSpliceBug &amp;&amp; value.length === 0) {</span>
<span class='uncovered'>          delete value[0];</span>
<span class='covered'>        }</span>
<span class='covered'>        if (this.__chain__) {</span>
<span class='uncovered'>          value = new lodash(value);</span>
<span class='uncovered'>          value.__chain__ = true;</span>
<span class='covered'>        }</span>
<span class='uncovered'>        return value;</span>
<span class='covered'>      };</span>
<span class='covered'>    });</span>
<span class='covered'>  </span>
<span class='covered'>    // add all accessor Array functions to the wrapper.</span>
<span class='covered'>    forEach([&#39;concat&#39;, &#39;join&#39;, &#39;slice&#39;], function(methodName) {</span>
<span class='covered'>      var func = arrayRef[methodName];</span>
<span class='covered'>  </span>
<span class='covered'>      lodash.prototype[methodName] = function() {</span>
<span class='uncovered'>        var value = this.__wrapped__,</span>
<span class='uncovered'>            result = func.apply(value, arguments);</span>
<span class='covered'>  </span>
<span class='covered'>        if (this.__chain__) {</span>
<span class='uncovered'>          result = new lodash(result);</span>
<span class='uncovered'>          result.__chain__ = true;</span>
<span class='covered'>        }</span>
<span class='uncovered'>        return result;</span>
<span class='covered'>      };</span>
<span class='covered'>    });</span>
<span class='covered'>  </span>
<span class='covered'>    /*--------------------------------------------------------------------------*/</span>
<span class='covered'>  </span>
<span class='covered'>    // expose Lo-Dash</span>
<span class='covered'>    // some AMD build optimizers, like r.js, check for specific condition patterns like the following:</span>
<span class='partial'>    if (typeof define == &#39;function&#39; &amp;&amp; <span class='partialuncovered'>typeof define.amd == &#39;object&#39; </span>&amp;&amp; define.amd) {</span>
<span class='covered'>      // Expose Lo-Dash to the global object even when an AMD loader is present in</span>
<span class='covered'>      // case Lo-Dash was injected by a third-party script and not intended to be</span>
<span class='covered'>      // loaded as a module. The global assignment can be reverted in the Lo-Dash</span>
<span class='covered'>      // module via its `noConflict()` method.</span>
<span class='uncovered'>      window._ = lodash;</span>
<span class='covered'>  </span>
<span class='covered'>      // define as an anonymous module so, through path mapping, it can be</span>
<span class='covered'>      // referenced as the &quot;underscore&quot; module</span>
<span class='uncovered'>      define(function() {</span>
<span class='uncovered'>        return lodash;</span>
<span class='uncovered'>      });</span>
<span class='covered'>    }</span>
<span class='covered'>    // check for `exports` after `define` in case a build optimizer adds an `exports` object</span>
<span class='covered'>    else if (freeExports) {</span>
<span class='covered'>      // in Node.js or RingoJS v0.8.0+</span>
<span class='covered'>      if (typeof module == &#39;object&#39; &amp;&amp; module &amp;&amp; module.exports == freeExports) {</span>
<span class='covered'>        (module.exports = lodash)._ = lodash;</span>
<span class='covered'>      }</span>
<span class='covered'>      // in Narwhal or RingoJS v0.7.0-</span>
<span class='covered'>      else {</span>
<span class='uncovered'>        freeExports._ = lodash;</span>
<span class='covered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>    else {</span>
<span class='covered'>      // in a browser or Rhino</span>
<span class='uncovered'>      window._ = lodash;</span>
<span class='covered'>    }</span>
<span class='covered'>  }(this));</span></pre></td>          
            </tr>
          </tbody>
        </table>
        <a class="index" href="index.html">Â« index</a> | <a class="coverio" href="http://cover.io">cover.io</a>
      </div>
  </body>
</html>
