
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>/usr/local/lib/node_modules/grunt-cli/node_modules/glob/node_modules/minimatch/minimatch.js -- cover.io</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="bootstrap.css" rel="stylesheet">
    <link href="prettify.css" type="text/css" rel="stylesheet" />
    <style type="text/css">
      html, body {
        font-family: georgia, serif;
      }
      
      .content {
      }
      table#files-table {
        table-layout: fixed;
        width: 94%;
      }

      table#files-table td, table#files-table th {
        width: 11%;
        padding-left: 5px;
        padding-right: 5px;
      }
      
      table#files-table td:first-child, table#files-table th:first-child {
        width: 33%;
      }
      
      .partialuncovered { 
        background: #EE9; 
      }
      
      pre.prettyprint {
        padding-top: 0em;
        border: 5px;
        padding-left: 0em;
        padding-bottom: 0em;
        font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;

      }
       
      span.covered {
        border-left: 2px solid lime; 
      }
      
      span.uncovered {
        background: #FDD;
        border-left: 2px solid red; 
      }
      
      span.partial {
        border-left: 2px solid #EE9; 
        background: #FFA;
      }
      
      div.header {
        width: 100%;
        padding: 0;
        margin: 0;
        border-bottom: 1px solid #EEE;
        height: 90px;
        background: #F8F8F8;
      }
      
      div.header-content {
        padding: 1em 3em;
      }
      
      a.index {
        text-decoration: none;
        color: inherit;
        font-size: 11px;
      }
      
      a.coverio {
        text-decoration: none;
        color: inherit;
        font-size: 11px;
      }
      
      div.content > a.index {
        padding-left: 1.5em;
        padding-bottom: 2em;
      }
      
      div.header-content h3 {
        font-weight: normal;
      }
      
      span.filename {
        font-weight: bold;
      }
      
      span.percentage {
        font-weight: bold;
      }
      
      div.stats {
        font-size: 13px;
      }
      
      div.stats span.separator {
        margin-left: 10px;
        margin-right: 10px;
      }
      
      div.stats span.stat-descriptor {
        color: gray;
      }
      
      table.code td.text {
        padding-left: 0px;
        padding-right: 0px;
      }

      .linenos p {
        text-align: left;
        margin: 0;
        padding-right: 0.5em;
        color: #999999;
        font-family: verdana, sans-serif;
        font-size: 0.8em;   /* 12/16 */
        line-height: 16px;  /* 16/12 */
      }

      td.text {
        width: 100%;
        height: 16px;
      }
      
      td.text pre > span {
        padding-top: 3px;
        line-height: 16px;
      }
    
    </style>
    <script src="jquery.min.js"></script>
    <script type="text/javascript" src="prettify.js"></script>
    <script >
    
      $(function() {
        $(".linenos p").css("text-align", "right");
        setTimeout(function() {
          prettyPrint();
        });
      });
    </script>

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  </head>

  <body>

      <div class="content">
        <div class="header">
          <div class="header-content">
            <a class="index" href="index.html">Â« index</a>
            <h3>Coverage for <span class="filename">/usr/local/lib/node_modules/grunt-cli/node_modules/glob/node_modules/minimatch/minimatch.js</span> : <span class="percentage">75%</span></h3>
            <div class="stats">
              1079  <span class="stat-descriptor">lines</span>     <span class="separator">| </span> 
              820  <span class="stat-descriptor">run</span>        <span class="separator">| </span> 
              259  <span class="stat-descriptor">missing</span>    <span class="separator">| </span> 
              19  <span class="stat-descriptor">partial</span>      <span class="separator">| </span> 
              196  <span class="stat-descriptor">blocks</span>     <span class="separator">| </span> 
              37  <span class="stat-descriptor">blocks run</span>  <span class="separator">| </span> 
              159  <span class="stat-descriptor">blocks missing</span>
            </div>
          </div>
        </div>
        <table class="code" cellspacing="0" cellpadding="0">
          <tbody>
            <tr>
              <td class='linenos' valign='top'><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p><p>84</p><p>85</p><p>86</p><p>87</p><p>88</p><p>89</p><p>90</p><p>91</p><p>92</p><p>93</p><p>94</p><p>95</p><p>96</p><p>97</p><p>98</p><p>99</p><p>100</p><p>101</p><p>102</p><p>103</p><p>104</p><p>105</p><p>106</p><p>107</p><p>108</p><p>109</p><p>110</p><p>111</p><p>112</p><p>113</p><p>114</p><p>115</p><p>116</p><p>117</p><p>118</p><p>119</p><p>120</p><p>121</p><p>122</p><p>123</p><p>124</p><p>125</p><p>126</p><p>127</p><p>128</p><p>129</p><p>130</p><p>131</p><p>132</p><p>133</p><p>134</p><p>135</p><p>136</p><p>137</p><p>138</p><p>139</p><p>140</p><p>141</p><p>142</p><p>143</p><p>144</p><p>145</p><p>146</p><p>147</p><p>148</p><p>149</p><p>150</p><p>151</p><p>152</p><p>153</p><p>154</p><p>155</p><p>156</p><p>157</p><p>158</p><p>159</p><p>160</p><p>161</p><p>162</p><p>163</p><p>164</p><p>165</p><p>166</p><p>167</p><p>168</p><p>169</p><p>170</p><p>171</p><p>172</p><p>173</p><p>174</p><p>175</p><p>176</p><p>177</p><p>178</p><p>179</p><p>180</p><p>181</p><p>182</p><p>183</p><p>184</p><p>185</p><p>186</p><p>187</p><p>188</p><p>189</p><p>190</p><p>191</p><p>192</p><p>193</p><p>194</p><p>195</p><p>196</p><p>197</p><p>198</p><p>199</p><p>200</p><p>201</p><p>202</p><p>203</p><p>204</p><p>205</p><p>206</p><p>207</p><p>208</p><p>209</p><p>210</p><p>211</p><p>212</p><p>213</p><p>214</p><p>215</p><p>216</p><p>217</p><p>218</p><p>219</p><p>220</p><p>221</p><p>222</p><p>223</p><p>224</p><p>225</p><p>226</p><p>227</p><p>228</p><p>229</p><p>230</p><p>231</p><p>232</p><p>233</p><p>234</p><p>235</p><p>236</p><p>237</p><p>238</p><p>239</p><p>240</p><p>241</p><p>242</p><p>243</p><p>244</p><p>245</p><p>246</p><p>247</p><p>248</p><p>249</p><p>250</p><p>251</p><p>252</p><p>253</p><p>254</p><p>255</p><p>256</p><p>257</p><p>258</p><p>259</p><p>260</p><p>261</p><p>262</p><p>263</p><p>264</p><p>265</p><p>266</p><p>267</p><p>268</p><p>269</p><p>270</p><p>271</p><p>272</p><p>273</p><p>274</p><p>275</p><p>276</p><p>277</p><p>278</p><p>279</p><p>280</p><p>281</p><p>282</p><p>283</p><p>284</p><p>285</p><p>286</p><p>287</p><p>288</p><p>289</p><p>290</p><p>291</p><p>292</p><p>293</p><p>294</p><p>295</p><p>296</p><p>297</p><p>298</p><p>299</p><p>300</p><p>301</p><p>302</p><p>303</p><p>304</p><p>305</p><p>306</p><p>307</p><p>308</p><p>309</p><p>310</p><p>311</p><p>312</p><p>313</p><p>314</p><p>315</p><p>316</p><p>317</p><p>318</p><p>319</p><p>320</p><p>321</p><p>322</p><p>323</p><p>324</p><p>325</p><p>326</p><p>327</p><p>328</p><p>329</p><p>330</p><p>331</p><p>332</p><p>333</p><p>334</p><p>335</p><p>336</p><p>337</p><p>338</p><p>339</p><p>340</p><p>341</p><p>342</p><p>343</p><p>344</p><p>345</p><p>346</p><p>347</p><p>348</p><p>349</p><p>350</p><p>351</p><p>352</p><p>353</p><p>354</p><p>355</p><p>356</p><p>357</p><p>358</p><p>359</p><p>360</p><p>361</p><p>362</p><p>363</p><p>364</p><p>365</p><p>366</p><p>367</p><p>368</p><p>369</p><p>370</p><p>371</p><p>372</p><p>373</p><p>374</p><p>375</p><p>376</p><p>377</p><p>378</p><p>379</p><p>380</p><p>381</p><p>382</p><p>383</p><p>384</p><p>385</p><p>386</p><p>387</p><p>388</p><p>389</p><p>390</p><p>391</p><p>392</p><p>393</p><p>394</p><p>395</p><p>396</p><p>397</p><p>398</p><p>399</p><p>400</p><p>401</p><p>402</p><p>403</p><p>404</p><p>405</p><p>406</p><p>407</p><p>408</p><p>409</p><p>410</p><p>411</p><p>412</p><p>413</p><p>414</p><p>415</p><p>416</p><p>417</p><p>418</p><p>419</p><p>420</p><p>421</p><p>422</p><p>423</p><p>424</p><p>425</p><p>426</p><p>427</p><p>428</p><p>429</p><p>430</p><p>431</p><p>432</p><p>433</p><p>434</p><p>435</p><p>436</p><p>437</p><p>438</p><p>439</p><p>440</p><p>441</p><p>442</p><p>443</p><p>444</p><p>445</p><p>446</p><p>447</p><p>448</p><p>449</p><p>450</p><p>451</p><p>452</p><p>453</p><p>454</p><p>455</p><p>456</p><p>457</p><p>458</p><p>459</p><p>460</p><p>461</p><p>462</p><p>463</p><p>464</p><p>465</p><p>466</p><p>467</p><p>468</p><p>469</p><p>470</p><p>471</p><p>472</p><p>473</p><p>474</p><p>475</p><p>476</p><p>477</p><p>478</p><p>479</p><p>480</p><p>481</p><p>482</p><p>483</p><p>484</p><p>485</p><p>486</p><p>487</p><p>488</p><p>489</p><p>490</p><p>491</p><p>492</p><p>493</p><p>494</p><p>495</p><p>496</p><p>497</p><p>498</p><p>499</p><p>500</p><p>501</p><p>502</p><p>503</p><p>504</p><p>505</p><p>506</p><p>507</p><p>508</p><p>509</p><p>510</p><p>511</p><p>512</p><p>513</p><p>514</p><p>515</p><p>516</p><p>517</p><p>518</p><p>519</p><p>520</p><p>521</p><p>522</p><p>523</p><p>524</p><p>525</p><p>526</p><p>527</p><p>528</p><p>529</p><p>530</p><p>531</p><p>532</p><p>533</p><p>534</p><p>535</p><p>536</p><p>537</p><p>538</p><p>539</p><p>540</p><p>541</p><p>542</p><p>543</p><p>544</p><p>545</p><p>546</p><p>547</p><p>548</p><p>549</p><p>550</p><p>551</p><p>552</p><p>553</p><p>554</p><p>555</p><p>556</p><p>557</p><p>558</p><p>559</p><p>560</p><p>561</p><p>562</p><p>563</p><p>564</p><p>565</p><p>566</p><p>567</p><p>568</p><p>569</p><p>570</p><p>571</p><p>572</p><p>573</p><p>574</p><p>575</p><p>576</p><p>577</p><p>578</p><p>579</p><p>580</p><p>581</p><p>582</p><p>583</p><p>584</p><p>585</p><p>586</p><p>587</p><p>588</p><p>589</p><p>590</p><p>591</p><p>592</p><p>593</p><p>594</p><p>595</p><p>596</p><p>597</p><p>598</p><p>599</p><p>600</p><p>601</p><p>602</p><p>603</p><p>604</p><p>605</p><p>606</p><p>607</p><p>608</p><p>609</p><p>610</p><p>611</p><p>612</p><p>613</p><p>614</p><p>615</p><p>616</p><p>617</p><p>618</p><p>619</p><p>620</p><p>621</p><p>622</p><p>623</p><p>624</p><p>625</p><p>626</p><p>627</p><p>628</p><p>629</p><p>630</p><p>631</p><p>632</p><p>633</p><p>634</p><p>635</p><p>636</p><p>637</p><p>638</p><p>639</p><p>640</p><p>641</p><p>642</p><p>643</p><p>644</p><p>645</p><p>646</p><p>647</p><p>648</p><p>649</p><p>650</p><p>651</p><p>652</p><p>653</p><p>654</p><p>655</p><p>656</p><p>657</p><p>658</p><p>659</p><p>660</p><p>661</p><p>662</p><p>663</p><p>664</p><p>665</p><p>666</p><p>667</p><p>668</p><p>669</p><p>670</p><p>671</p><p>672</p><p>673</p><p>674</p><p>675</p><p>676</p><p>677</p><p>678</p><p>679</p><p>680</p><p>681</p><p>682</p><p>683</p><p>684</p><p>685</p><p>686</p><p>687</p><p>688</p><p>689</p><p>690</p><p>691</p><p>692</p><p>693</p><p>694</p><p>695</p><p>696</p><p>697</p><p>698</p><p>699</p><p>700</p><p>701</p><p>702</p><p>703</p><p>704</p><p>705</p><p>706</p><p>707</p><p>708</p><p>709</p><p>710</p><p>711</p><p>712</p><p>713</p><p>714</p><p>715</p><p>716</p><p>717</p><p>718</p><p>719</p><p>720</p><p>721</p><p>722</p><p>723</p><p>724</p><p>725</p><p>726</p><p>727</p><p>728</p><p>729</p><p>730</p><p>731</p><p>732</p><p>733</p><p>734</p><p>735</p><p>736</p><p>737</p><p>738</p><p>739</p><p>740</p><p>741</p><p>742</p><p>743</p><p>744</p><p>745</p><p>746</p><p>747</p><p>748</p><p>749</p><p>750</p><p>751</p><p>752</p><p>753</p><p>754</p><p>755</p><p>756</p><p>757</p><p>758</p><p>759</p><p>760</p><p>761</p><p>762</p><p>763</p><p>764</p><p>765</p><p>766</p><p>767</p><p>768</p><p>769</p><p>770</p><p>771</p><p>772</p><p>773</p><p>774</p><p>775</p><p>776</p><p>777</p><p>778</p><p>779</p><p>780</p><p>781</p><p>782</p><p>783</p><p>784</p><p>785</p><p>786</p><p>787</p><p>788</p><p>789</p><p>790</p><p>791</p><p>792</p><p>793</p><p>794</p><p>795</p><p>796</p><p>797</p><p>798</p><p>799</p><p>800</p><p>801</p><p>802</p><p>803</p><p>804</p><p>805</p><p>806</p><p>807</p><p>808</p><p>809</p><p>810</p><p>811</p><p>812</p><p>813</p><p>814</p><p>815</p><p>816</p><p>817</p><p>818</p><p>819</p><p>820</p><p>821</p><p>822</p><p>823</p><p>824</p><p>825</p><p>826</p><p>827</p><p>828</p><p>829</p><p>830</p><p>831</p><p>832</p><p>833</p><p>834</p><p>835</p><p>836</p><p>837</p><p>838</p><p>839</p><p>840</p><p>841</p><p>842</p><p>843</p><p>844</p><p>845</p><p>846</p><p>847</p><p>848</p><p>849</p><p>850</p><p>851</p><p>852</p><p>853</p><p>854</p><p>855</p><p>856</p><p>857</p><p>858</p><p>859</p><p>860</p><p>861</p><p>862</p><p>863</p><p>864</p><p>865</p><p>866</p><p>867</p><p>868</p><p>869</p><p>870</p><p>871</p><p>872</p><p>873</p><p>874</p><p>875</p><p>876</p><p>877</p><p>878</p><p>879</p><p>880</p><p>881</p><p>882</p><p>883</p><p>884</p><p>885</p><p>886</p><p>887</p><p>888</p><p>889</p><p>890</p><p>891</p><p>892</p><p>893</p><p>894</p><p>895</p><p>896</p><p>897</p><p>898</p><p>899</p><p>900</p><p>901</p><p>902</p><p>903</p><p>904</p><p>905</p><p>906</p><p>907</p><p>908</p><p>909</p><p>910</p><p>911</p><p>912</p><p>913</p><p>914</p><p>915</p><p>916</p><p>917</p><p>918</p><p>919</p><p>920</p><p>921</p><p>922</p><p>923</p><p>924</p><p>925</p><p>926</p><p>927</p><p>928</p><p>929</p><p>930</p><p>931</p><p>932</p><p>933</p><p>934</p><p>935</p><p>936</p><p>937</p><p>938</p><p>939</p><p>940</p><p>941</p><p>942</p><p>943</p><p>944</p><p>945</p><p>946</p><p>947</p><p>948</p><p>949</p><p>950</p><p>951</p><p>952</p><p>953</p><p>954</p><p>955</p><p>956</p><p>957</p><p>958</p><p>959</p><p>960</p><p>961</p><p>962</p><p>963</p><p>964</p><p>965</p><p>966</p><p>967</p><p>968</p><p>969</p><p>970</p><p>971</p><p>972</p><p>973</p><p>974</p><p>975</p><p>976</p><p>977</p><p>978</p><p>979</p><p>980</p><p>981</p><p>982</p><p>983</p><p>984</p><p>985</p><p>986</p><p>987</p><p>988</p><p>989</p><p>990</p><p>991</p><p>992</p><p>993</p><p>994</p><p>995</p><p>996</p><p>997</p><p>998</p><p>999</p><p>1000</p><p>1001</p><p>1002</p><p>1003</p><p>1004</p><p>1005</p><p>1006</p><p>1007</p><p>1008</p><p>1009</p><p>1010</p><p>1011</p><p>1012</p><p>1013</p><p>1014</p><p>1015</p><p>1016</p><p>1017</p><p>1018</p><p>1019</p><p>1020</p><p>1021</p><p>1022</p><p>1023</p><p>1024</p><p>1025</p><p>1026</p><p>1027</p><p>1028</p><p>1029</p><p>1030</p><p>1031</p><p>1032</p><p>1033</p><p>1034</p><p>1035</p><p>1036</p><p>1037</p><p>1038</p><p>1039</p><p>1040</p><p>1041</p><p>1042</p><p>1043</p><p>1044</p><p>1045</p><p>1046</p><p>1047</p><p>1048</p><p>1049</p><p>1050</p><p>1051</p><p>1052</p><p>1053</p><p>1054</p><p>1055</p><p>1056</p><p>1057</p><p>1058</p><p>1059</p><p>1060</p><p>1061</p><p>1062</p><p>1063</p><p>1064</p><p>1065</p><p>1066</p><p>1067</p><p>1068</p><p>1069</p><p>1070</p><p>1071</p><p>1072</p><p>1073</p><p>1074</p><p>1075</p><p>1076</p><p>1077</p><p>1078</p><p>1079</p></td><td class='text' valign='top'><pre class='prettyprint lang-js'><span class='covered'>  ;(function (require, exports, module, platform) {</span>
<span class='covered'>  </span>
<span class='covered'>  if (module) module.exports = minimatch</span>
<span class='uncovered'>  else exports.minimatch = minimatch</span>
<span class='uncovered'>  </span>
<span class='uncovered'>  if (!require) {</span>
<span class='uncovered'>    require = function (id) {</span>
<span class='uncovered'>      switch (id) {</span>
<span class='uncovered'>        case &quot;sigmund&quot;: return function sigmund (obj) {</span>
<span class='uncovered'>          return JSON.stringify(obj)</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        case &quot;path&quot;: return { basename: function (f) {</span>
<span class='uncovered'>          f = f.split(/[\/\\]/)</span>
<span class='uncovered'>          var e = f.pop()</span>
<span class='uncovered'>          if (!e) e = f.pop()</span>
<span class='uncovered'>          return e</span>
<span class='uncovered'>        }}</span>
<span class='uncovered'>        case &quot;lru-cache&quot;: return function LRUCache () {</span>
<span class='uncovered'>          // not quite an LRU, but still space-limited.</span>
<span class='uncovered'>          var cache = {}</span>
<span class='uncovered'>          var cnt = 0</span>
<span class='uncovered'>          this.set = function (k, v) {</span>
<span class='uncovered'>            cnt ++</span>
<span class='uncovered'>            if (cnt &gt;= 100) cache = {}</span>
<span class='uncovered'>            cache[k] = v</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>          this.get = function (k) { return cache[k] }</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>    }</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  minimatch.Minimatch = Minimatch</span>
<span class='covered'>  </span>
<span class='covered'>  var LRU = require(&quot;lru-cache&quot;)</span>
<span class='covered'>    , cache = minimatch.cache = new LRU({max: 100})</span>
<span class='covered'>    , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}</span>
<span class='covered'>    , sigmund = require(&quot;sigmund&quot;)</span>
<span class='covered'>  </span>
<span class='covered'>  var path = require(&quot;path&quot;)</span>
<span class='covered'>    // any single thing other than /</span>
<span class='covered'>    // don&#39;t need to escape / when using new RegExp()</span>
<span class='covered'>    , qmark = &quot;[^/]&quot;</span>
<span class='covered'>  </span>
<span class='covered'>    // * =&gt; any number of characters</span>
<span class='covered'>    , star = qmark + &quot;*?&quot;</span>
<span class='covered'>  </span>
<span class='covered'>    // ** when dots are allowed.  Anything goes, except .. and .</span>
<span class='covered'>    // not (^ or / followed by one or two dots followed by $ or /),</span>
<span class='covered'>    // followed by anything, any number of times.</span>
<span class='covered'>    , twoStarDot = &quot;(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?&quot;</span>
<span class='covered'>  </span>
<span class='covered'>    // not a ^ or / followed by a dot,</span>
<span class='covered'>    // followed by anything, any number of times.</span>
<span class='covered'>    , twoStarNoDot = &quot;(?:(?!(?:\\\/|^)\\.).)*?&quot;</span>
<span class='covered'>  </span>
<span class='covered'>    // characters that need to be escaped in RegExp.</span>
<span class='covered'>    , reSpecials = charSet(&quot;().*{}+?[]^$\\!&quot;)</span>
<span class='covered'>  </span>
<span class='covered'>  // &quot;abc&quot; -&gt; { a:true, b:true, c:true }</span>
<span class='covered'>  function charSet (s) {</span>
<span class='covered'>    return s.split(&quot;&quot;).reduce(function (set, c) {</span>
<span class='covered'>      set[c] = true</span>
<span class='covered'>      return set</span>
<span class='covered'>    }, {})</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  // normalizes slashes.</span>
<span class='covered'>  var slashSplit = /\/+/</span>
<span class='covered'>  </span>
<span class='covered'>  minimatch.monkeyPatch = monkeyPatch</span>
<span class='covered'>  function monkeyPatch () {</span>
<span class='uncovered'>    var desc = Object.getOwnPropertyDescriptor(String.prototype, &quot;match&quot;)</span>
<span class='uncovered'>    var orig = desc.value</span>
<span class='uncovered'>    desc.value = function (p) {</span>
<span class='uncovered'>      if (p instanceof Minimatch) return p.match(this)</span>
<span class='uncovered'>      return orig.call(this, p)</span>
<span class='uncovered'>    }</span>
<span class='uncovered'>    Object.defineProperty(String.prototype, desc)</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  minimatch.filter = filter</span>
<span class='covered'>  function filter (pattern, options) {</span>
<span class='uncovered'>    options = options || {}</span>
<span class='uncovered'>    return function (p, i, list) {</span>
<span class='uncovered'>      return minimatch(p, pattern, options)</span>
<span class='uncovered'>    }</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  function ext (a, b) {</span>
<span class='uncovered'>    a = a || {}</span>
<span class='uncovered'>    b = b || {}</span>
<span class='uncovered'>    var t = {}</span>
<span class='uncovered'>    Object.keys(b).forEach(function (k) {</span>
<span class='uncovered'>      t[k] = b[k]</span>
<span class='uncovered'>    })</span>
<span class='uncovered'>    Object.keys(a).forEach(function (k) {</span>
<span class='uncovered'>      t[k] = a[k]</span>
<span class='uncovered'>    })</span>
<span class='uncovered'>    return t</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  minimatch.defaults = function (def) {</span>
<span class='uncovered'>    if (!def || !Object.keys(def).length) return minimatch</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    var orig = minimatch</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    var m = function minimatch (p, pattern, options) {</span>
<span class='uncovered'>      return orig.minimatch(p, pattern, ext(def, options))</span>
<span class='uncovered'>    }</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    m.Minimatch = function Minimatch (pattern, options) {</span>
<span class='uncovered'>      return new orig.Minimatch(pattern, ext(def, options))</span>
<span class='uncovered'>    }</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    return m</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  Minimatch.defaults = function (def) {</span>
<span class='uncovered'>    if (!def || !Object.keys(def).length) return Minimatch</span>
<span class='uncovered'>    return minimatch.defaults(def).Minimatch</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  </span>
<span class='covered'>  function minimatch (p, pattern, options) {</span>
<span class='uncovered'>    if (typeof pattern !== &quot;string&quot;) {</span>
<span class='uncovered'>      throw new TypeError(&quot;glob pattern string required&quot;)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (!options) options = {}</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // shortcut: comments match nothing.</span>
<span class='uncovered'>    if (!options.nocomment &amp;&amp; pattern.charAt(0) === &quot;#&quot;) {</span>
<span class='uncovered'>      return false</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // &quot;&quot; only matches &quot;&quot;</span>
<span class='uncovered'>    if (pattern.trim() === &quot;&quot;) return p === &quot;&quot;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    return new Minimatch(pattern, options).match(p)</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  function Minimatch (pattern, options) {</span>
<span class='covered'>    if (!(this instanceof Minimatch)) {</span>
<span class='uncovered'>      return new Minimatch(pattern, options, cache)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    if (typeof pattern !== &quot;string&quot;) {</span>
<span class='uncovered'>      throw new TypeError(&quot;glob pattern string required&quot;)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (!options) options = {}</span>
<span class='partial'>    pattern = pattern.trim()<span class='partialuncovered'></span>  pattern = pattern.trim()</span>
<span class='covered'>  </span>
<span class='covered'>    // windows: need to use /, not \</span>
<span class='covered'>    // On other platforms, \ is a valid (albeit bad) filename char.</span>
<span class='covered'>    if (platform === &quot;win32&quot;) {</span>
<span class='uncovered'>      pattern = pattern.split(&quot;\\&quot;).join(&quot;/&quot;)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // lru storage.</span>
<span class='covered'>    // these things aren&#39;t particularly big, but walking down the string</span>
<span class='covered'>    // and turning it into a regexp can get pretty costly.</span>
<span class='covered'>    var cacheKey = pattern + &quot;\n&quot; + sigmund(options)</span>
<span class='covered'>    var cached = minimatch.cache.get(cacheKey)</span>
<span class='uncovered'>    if (cached) return cached</span>
<span class='partial'>    minimatch.cache.set(cacheKey, this)<span class='partialuncovered'></span>  minimatch.cache.set(cacheKey, this)</span>
<span class='covered'>  </span>
<span class='covered'>    this.options = options</span>
<span class='covered'>    this.set = []</span>
<span class='covered'>    this.pattern = pattern</span>
<span class='covered'>    this.regexp = null</span>
<span class='covered'>    this.negate = false</span>
<span class='covered'>    this.comment = false</span>
<span class='covered'>    this.empty = false</span>
<span class='covered'>  </span>
<span class='covered'>    // make the set of regexps etc.</span>
<span class='covered'>    this.make()</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  Minimatch.prototype.make = make</span>
<span class='covered'>  function make () {</span>
<span class='covered'>    // don&#39;t do it more than once.</span>
<span class='uncovered'>    if (this._made) return</span>
<span class='covered'>  </span>
<span class='covered'>    var pattern = this.pattern</span>
<span class='covered'>    var options = this.options</span>
<span class='covered'>  </span>
<span class='covered'>    // empty patterns and comments match nothing.</span>
<span class='covered'>    if (!options.nocomment &amp;&amp; pattern.charAt(0) === &quot;#&quot;) {</span>
<span class='uncovered'>      this.comment = true</span>
<span class='uncovered'>      return</span>
<span class='covered'>    }</span>
<span class='covered'>    if (!pattern) {</span>
<span class='uncovered'>      this.empty = true</span>
<span class='uncovered'>      return</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // step 1: figure out negation, etc.</span>
<span class='covered'>    this.parseNegate()</span>
<span class='covered'>  </span>
<span class='covered'>    // step 2: expand braces</span>
<span class='covered'>    var set = this.globSet = this.braceExpand()</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (options.debug) console.error(this.pattern, set)</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // step 3: now we have a set, so turn each one into a series of path-portion</span>
<span class='uncovered'>    // matching patterns.</span>
<span class='uncovered'>    // These will be regexps, except in the case of &quot;**&quot;, which is</span>
<span class='uncovered'>    // set to the GLOBSTAR object for globstar behavior,</span>
<span class='uncovered'>    // and will not contain any / characters</span>
<span class='partial'>    set = this.globParts = set.map(function (s) {<span class='partialuncovered'></span>  set = this.globParts = set.map(function (s) {</span>
<span class='covered'>      return s.split(slashSplit)</span>
<span class='covered'>    })</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (options.debug) console.error(this.pattern, set)</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // glob --&gt; regexps</span>
<span class='partial'>    set = set.map(function (s, si, set) {<span class='partialuncovered'></span>  set = set.map(function (s, si, set) {</span>
<span class='covered'>      return s.map(this.parse, this)</span>
<span class='covered'>    }, this)</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (options.debug) console.error(this.pattern, set)</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // filter out everything that didn&#39;t compile properly.</span>
<span class='partial'>    set = set.filter(function (s) {<span class='partialuncovered'></span>  set = set.filter(function (s) {</span>
<span class='covered'>      return -1 === s.indexOf(false)</span>
<span class='covered'>    })</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (options.debug) console.error(this.pattern, set)</span>
<span class='uncovered'>  </span>
<span class='partial'>    this.set = set<span class='partialuncovered'></span>  this.set = set</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  Minimatch.prototype.parseNegate = parseNegate</span>
<span class='covered'>  function parseNegate () {</span>
<span class='covered'>    var pattern = this.pattern</span>
<span class='covered'>      , negate = false</span>
<span class='covered'>      , options = this.options</span>
<span class='covered'>      , negateOffset = 0</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (options.nonegate) return</span>
<span class='covered'>  </span>
<span class='covered'>    for ( var i = 0, l = pattern.length</span>
<span class='covered'>        ; i &lt; l &amp;&amp; pattern.charAt(i) === &quot;!&quot;</span>
<span class='uncovered'>        ; i ++) {</span>
<span class='uncovered'>      negate = !negate</span>
<span class='uncovered'>      negateOffset ++</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (negateOffset) this.pattern = pattern.substr(negateOffset)</span>
<span class='partial'>    this.negate = negate<span class='partialuncovered'></span>  this.negate = negate</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  // Brace expansion:</span>
<span class='covered'>  // a{b,c}d -&gt; abd acd</span>
<span class='covered'>  // a{b,}c -&gt; abc ac</span>
<span class='covered'>  // a{0..3}d -&gt; a0d a1d a2d a3d</span>
<span class='covered'>  // a{b,c{d,e}f}g -&gt; abg acdfg acefg</span>
<span class='covered'>  // a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg</span>
<span class='covered'>  //</span>
<span class='covered'>  // Invalid sets are not expanded.</span>
<span class='covered'>  // a{2..}b -&gt; a{2..}b</span>
<span class='covered'>  // a{b}c -&gt; a{b}c</span>
<span class='covered'>  minimatch.braceExpand = function (pattern, options) {</span>
<span class='uncovered'>    return new Minimatch(pattern, options).braceExpand()</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  Minimatch.prototype.braceExpand = braceExpand</span>
<span class='covered'>  function braceExpand (pattern, options) {</span>
<span class='covered'>    options = options || this.options</span>
<span class='covered'>    pattern = typeof pattern === &quot;undefined&quot;</span>
<span class='covered'>      ? this.pattern : pattern</span>
<span class='covered'>  </span>
<span class='covered'>    if (typeof pattern === &quot;undefined&quot;) {</span>
<span class='uncovered'>      throw new Error(&quot;undefined pattern&quot;)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    if (options.nobrace ||</span>
<span class='covered'>        !pattern.match(/\{.*\}/)) {</span>
<span class='covered'>      // shortcut. no need to expand.</span>
<span class='covered'>      return [pattern]</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    var escaping = false</span>
<span class='covered'>  </span>
<span class='covered'>    // examples and comments refer to this crazy pattern:</span>
<span class='covered'>    // a{b,c{d,e},{f,g}h}x{y,z}</span>
<span class='covered'>    // expected:</span>
<span class='covered'>    // abxy</span>
<span class='covered'>    // abxz</span>
<span class='covered'>    // acdxy</span>
<span class='covered'>    // acdxz</span>
<span class='covered'>    // acexy</span>
<span class='covered'>    // acexz</span>
<span class='covered'>    // afhxy</span>
<span class='covered'>    // afhxz</span>
<span class='covered'>    // aghxy</span>
<span class='covered'>    // aghxz</span>
<span class='covered'>  </span>
<span class='covered'>    // everything before the first \{ is just a prefix.</span>
<span class='covered'>    // So, we pluck that off, and work with the rest,</span>
<span class='covered'>    // and then prepend it to everything we find.</span>
<span class='covered'>    if (pattern.charAt(0) !== &quot;{&quot;) {</span>
<span class='covered'>      // console.error(pattern)</span>
<span class='covered'>      var prefix = null</span>
<span class='covered'>      for (var i = 0, l = pattern.length; i &lt; l; i ++) {</span>
<span class='covered'>        var c = pattern.charAt(i)</span>
<span class='covered'>        // console.error(i, c)</span>
<span class='covered'>        if (c === &quot;\\&quot;) {</span>
<span class='uncovered'>          escaping = !escaping</span>
<span class='partial'>        } else if (c === &quot;{&quot; &amp;&amp; !escaping) {<span class='partialuncovered'></span>      } else if (c === &quot;{&quot; &amp;&amp; !escaping) {</span>
<span class='covered'>          prefix = pattern.substr(0, i)</span>
<span class='covered'>          break</span>
<span class='covered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      // actually no sets, all { were escaped.</span>
<span class='covered'>      if (prefix === null) {</span>
<span class='covered'>        // console.error(&quot;no sets&quot;)</span>
<span class='uncovered'>        return [pattern]</span>
<span class='uncovered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      var tail = braceExpand(pattern.substr(i), options)</span>
<span class='covered'>      return tail.map(function (t) {</span>
<span class='covered'>        return prefix + t</span>
<span class='covered'>      })</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // now we have something like:</span>
<span class='covered'>    // {b,c{d,e},{f,g}h}x{y,z}</span>
<span class='covered'>    // walk through the set, expanding each part, until</span>
<span class='covered'>    // the set ends.  then, we&#39;ll expand the suffix.</span>
<span class='covered'>    // If the set only has a single member, then&#39;ll put the {} back</span>
<span class='covered'>  </span>
<span class='covered'>    // first, handle numeric sets, since they&#39;re easier</span>
<span class='covered'>    var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)</span>
<span class='covered'>    if (numset) {</span>
<span class='covered'>      // console.error(&quot;numset&quot;, numset[1], numset[2])</span>
<span class='uncovered'>      var suf = braceExpand(pattern.substr(numset[0].length), options)</span>
<span class='uncovered'>        , start = +numset[1]</span>
<span class='uncovered'>        , end = +numset[2]</span>
<span class='uncovered'>        , inc = start &gt; end ? -1 : 1</span>
<span class='uncovered'>        , set = []</span>
<span class='uncovered'>      for (var i = start; i != (end + inc); i += inc) {</span>
<span class='covered'>        // append all the suffixes</span>
<span class='uncovered'>        for (var ii = 0, ll = suf.length; ii &lt; ll; ii ++) {</span>
<span class='uncovered'>          set.push(i + suf[ii])</span>
<span class='uncovered'>        }</span>
<span class='covered'>      }</span>
<span class='uncovered'>      return set</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // ok, walk through the set</span>
<span class='covered'>    // We hope, somewhat optimistically, that there</span>
<span class='covered'>    // will be a } at the end.</span>
<span class='covered'>    // If the closing brace isn&#39;t found, then the pattern is</span>
<span class='covered'>    // interpreted as braceExpand(&quot;\\&quot; + pattern) so that</span>
<span class='covered'>    // the leading \{ will be interpreted literally.</span>
<span class='covered'>    var i = 1 // skip the \{</span>
<span class='covered'>      , depth = 1</span>
<span class='covered'>      , set = []</span>
<span class='covered'>      , member = &quot;&quot;</span>
<span class='covered'>      , sawEnd = false</span>
<span class='covered'>      , escaping = false</span>
<span class='covered'>  </span>
<span class='covered'>    function addMember () {</span>
<span class='covered'>      set.push(member)</span>
<span class='covered'>      member = &quot;&quot;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // console.error(&quot;Entering for&quot;)</span>
<span class='covered'>    FOR: for (i = 1, l = pattern.length; i &lt; l; i ++) {</span>
<span class='covered'>      var c = pattern.charAt(i)</span>
<span class='covered'>      // console.error(&quot;&quot;, i, c)</span>
<span class='covered'>  </span>
<span class='covered'>      if (escaping) {</span>
<span class='uncovered'>        escaping = false</span>
<span class='uncovered'>        member += &quot;\\&quot; + c</span>
<span class='uncovered'>      } else {</span>
<span class='covered'>        switch (c) {</span>
<span class='covered'>          case &quot;\\&quot;:</span>
<span class='uncovered'>            escaping = true</span>
<span class='uncovered'>            continue</span>
<span class='covered'>  </span>
<span class='covered'>          case &quot;{&quot;:</span>
<span class='uncovered'>            depth ++</span>
<span class='uncovered'>            member += &quot;{&quot;</span>
<span class='uncovered'>            continue</span>
<span class='covered'>  </span>
<span class='covered'>          case &quot;}&quot;:</span>
<span class='covered'>            depth --</span>
<span class='covered'>            // if this closes the actual set, then we&#39;re done</span>
<span class='covered'>            if (depth === 0) {</span>
<span class='covered'>              addMember()</span>
<span class='covered'>              // pluck off the close-brace</span>
<span class='covered'>              i ++</span>
<span class='covered'>              break FOR</span>
<span class='covered'>            } else {</span>
<span class='uncovered'>              member += c</span>
<span class='uncovered'>              continue</span>
<span class='covered'>            }</span>
<span class='covered'>  </span>
<span class='covered'>          case &quot;,&quot;:</span>
<span class='covered'>            if (depth === 1) {</span>
<span class='covered'>              addMember()</span>
<span class='covered'>            } else {</span>
<span class='uncovered'>              member += c</span>
<span class='uncovered'>            }</span>
<span class='covered'>            continue</span>
<span class='covered'>  </span>
<span class='covered'>          default:</span>
<span class='covered'>            member += c</span>
<span class='covered'>            continue</span>
<span class='covered'>        } // switch</span>
<span class='covered'>      } // else</span>
<span class='covered'>    } // for</span>
<span class='covered'>  </span>
<span class='covered'>    // now we&#39;ve either finished the set, and the suffix is</span>
<span class='covered'>    // pattern.substr(i), or we have *not* closed the set,</span>
<span class='covered'>    // and need to escape the leading brace</span>
<span class='covered'>    if (depth !== 0) {</span>
<span class='covered'>      // console.error(&quot;didn&#39;t close&quot;, pattern)</span>
<span class='uncovered'>      return braceExpand(&quot;\\&quot; + pattern, options)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // x{y,z} -&gt; [&quot;xy&quot;, &quot;xz&quot;]</span>
<span class='covered'>    // console.error(&quot;set&quot;, set)</span>
<span class='covered'>    // console.error(&quot;suffix&quot;, pattern.substr(i))</span>
<span class='covered'>    var suf = braceExpand(pattern.substr(i), options)</span>
<span class='covered'>    // [&quot;b&quot;, &quot;c{d,e}&quot;,&quot;{f,g}h&quot;] -&gt;</span>
<span class='covered'>    //   [[&quot;b&quot;], [&quot;cd&quot;, &quot;ce&quot;], [&quot;fh&quot;, &quot;gh&quot;]]</span>
<span class='covered'>    var addBraces = set.length === 1</span>
<span class='covered'>    // console.error(&quot;set pre-expanded&quot;, set)</span>
<span class='covered'>    set = set.map(function (p) {</span>
<span class='covered'>      return braceExpand(p, options)</span>
<span class='covered'>    })</span>
<span class='covered'>    // console.error(&quot;set expanded&quot;, set)</span>
<span class='covered'>  </span>
<span class='covered'>  </span>
<span class='covered'>    // [[&quot;b&quot;], [&quot;cd&quot;, &quot;ce&quot;], [&quot;fh&quot;, &quot;gh&quot;]] -&gt;</span>
<span class='covered'>    //   [&quot;b&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;fh&quot;, &quot;gh&quot;]</span>
<span class='covered'>    set = set.reduce(function (l, r) {</span>
<span class='covered'>      return l.concat(r)</span>
<span class='covered'>    })</span>
<span class='covered'>  </span>
<span class='covered'>    if (addBraces) {</span>
<span class='uncovered'>      set = set.map(function (s) {</span>
<span class='uncovered'>        return &quot;{&quot; + s + &quot;}&quot;</span>
<span class='uncovered'>      })</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // now attach the suffixes.</span>
<span class='covered'>    var ret = []</span>
<span class='covered'>    for (var i = 0, l = set.length; i &lt; l; i ++) {</span>
<span class='covered'>      for (var ii = 0, ll = suf.length; ii &lt; ll; ii ++) {</span>
<span class='covered'>        ret.push(set[i] + suf[ii])</span>
<span class='covered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>    return ret</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  // parse a component of the expanded set.</span>
<span class='covered'>  // At this point, no pattern may contain &quot;/&quot; in it</span>
<span class='covered'>  // so we&#39;re going to return a 2d array, where each entry is the full</span>
<span class='covered'>  // pattern, split on &#39;/&#39;, and then turned into a regular expression.</span>
<span class='covered'>  // A regexp is made at the end which joins each array with an</span>
<span class='covered'>  // escaped /, and another full one which joins each regexp with |.</span>
<span class='covered'>  //</span>
<span class='covered'>  // Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning</span>
<span class='covered'>  // when it is the *only* thing in a path portion.  Otherwise, any series</span>
<span class='covered'>  // of * is equivalent to a single *.  Globstar behavior is enabled by</span>
<span class='covered'>  // default, and can be disabled by setting options.noglobstar.</span>
<span class='covered'>  Minimatch.prototype.parse = parse</span>
<span class='covered'>  var SUBPARSE = {}</span>
<span class='covered'>  function parse (pattern, isSub) {</span>
<span class='covered'>    var options = this.options</span>
<span class='covered'>  </span>
<span class='covered'>    // shortcuts</span>
<span class='partial'>    if (!options.noglobstar &amp;&amp; pattern === &quot;**&quot;) return GLOBSTAR<span class='partialuncovered'></span>  if (!options.noglobstar &amp;&amp; pattern === &quot;**&quot;) return GLOBSTAR</span>
<span class='partial'>    if (pattern === &quot;&quot;) return &quot;&quot;<span class='partialuncovered'></span>  if (pattern === &quot;&quot;) return &quot;&quot;</span>
<span class='uncovered'>  </span>
<span class='partial'>    var re = &quot;&quot;<span class='partialuncovered'></span>  var re = &quot;&quot;</span>
<span class='covered'>      , hasMagic = false</span>
<span class='covered'>      , escaping = false</span>
<span class='covered'>      // ? =&gt; one single character</span>
<span class='covered'>      , patternListStack = []</span>
<span class='covered'>      , plType</span>
<span class='covered'>      , stateChar</span>
<span class='covered'>      , inClass = false</span>
<span class='covered'>      , reClassStart = -1</span>
<span class='covered'>      , classStart = -1</span>
<span class='covered'>      // . and .. never match anything that doesn&#39;t start with .,</span>
<span class='covered'>      // even when options.dot is set.</span>
<span class='partial'>      , patternStart = pattern.charAt(0) === &quot;.&quot; ? <span class='partialuncovered'>&quot;&quot; </span>// anything</span>
<span class='covered'>        // not (start or / followed by . or .. followed by / or end)</span>
<span class='partial'>        : options.dot ? <span class='partialuncovered'>&quot;(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))&quot;</span></span>
<span class='covered'>        : &quot;(?!\\.)&quot;</span>
<span class='covered'>  </span>
<span class='covered'>    function clearStateChar () {</span>
<span class='covered'>      if (stateChar) {</span>
<span class='covered'>        // we had some state-tracking character</span>
<span class='covered'>        // that wasn&#39;t consumed by this pass.</span>
<span class='covered'>        switch (stateChar) {</span>
<span class='covered'>          case &quot;*&quot;:</span>
<span class='uncovered'>            re += star</span>
<span class='uncovered'>            hasMagic = true</span>
<span class='uncovered'>            break</span>
<span class='covered'>          case &quot;?&quot;:</span>
<span class='uncovered'>            re += qmark</span>
<span class='uncovered'>            hasMagic = true</span>
<span class='uncovered'>            break</span>
<span class='covered'>          default:</span>
<span class='uncovered'>            re += &quot;\\&quot;+stateChar</span>
<span class='uncovered'>            break</span>
<span class='covered'>        }</span>
<span class='uncovered'>        stateChar = false</span>
<span class='uncovered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    for ( var i = 0, len = pattern.length, c</span>
<span class='covered'>        ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))</span>
<span class='covered'>        ; i ++ ) {</span>
<span class='covered'>  </span>
<span class='covered'>      if (options.debug) {</span>
<span class='uncovered'>        console.error(&quot;%s\t%s %s %j&quot;, pattern, i, re, c)</span>
<span class='uncovered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      // skip over any that are escaped.</span>
<span class='covered'>      if (escaping &amp;&amp; reSpecials[c]) {</span>
<span class='uncovered'>        re += &quot;\\&quot; + c</span>
<span class='uncovered'>        escaping = false</span>
<span class='uncovered'>        continue</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      SWITCH: switch (c) {</span>
<span class='covered'>        case &quot;/&quot;:</span>
<span class='covered'>          // completely not allowed, even escaped.</span>
<span class='covered'>          // Should already be path-split by now.</span>
<span class='uncovered'>          return false</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        case &quot;\\&quot;:</span>
<span class='uncovered'>          clearStateChar()</span>
<span class='uncovered'>          escaping = true</span>
<span class='uncovered'>          continue</span>
<span class='covered'>  </span>
<span class='covered'>        // the various stateChar values</span>
<span class='covered'>        // for the &quot;extglob&quot; stuff.</span>
<span class='covered'>        case &quot;?&quot;:</span>
<span class='covered'>        case &quot;*&quot;:</span>
<span class='covered'>        case &quot;+&quot;:</span>
<span class='covered'>        case &quot;@&quot;:</span>
<span class='covered'>        case &quot;!&quot;:</span>
<span class='covered'>          if (options.debug) {</span>
<span class='uncovered'>            console.error(&quot;%s\t%s %s %j &lt;-- stateChar&quot;, pattern, i, re, c)</span>
<span class='uncovered'>          }</span>
<span class='covered'>  </span>
<span class='covered'>          // all of those are literals inside a class, except that</span>
<span class='covered'>          // the glob [!a] means [^a] in regexp</span>
<span class='covered'>          if (inClass) {</span>
<span class='uncovered'>            if (c === &quot;!&quot; &amp;&amp; i === classStart + 1) c = &quot;^&quot;</span>
<span class='uncovered'>            re += c</span>
<span class='uncovered'>            continue</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='covered'>          // if we already have a stateChar, then it means</span>
<span class='covered'>          // that there was something like ** or +? in there.</span>
<span class='covered'>          // Handle the stateChar, then proceed with this one.</span>
<span class='uncovered'>          clearStateChar()</span>
<span class='uncovered'>          stateChar = c</span>
<span class='uncovered'>          // if extglob is disabled, then +(asdf|foo) isn&#39;t a thing.</span>
<span class='uncovered'>          // just clear the statechar *now*, rather than even diving into</span>
<span class='uncovered'>          // the patternList stuff.</span>
<span class='uncovered'>          if (options.noext) clearStateChar()</span>
<span class='uncovered'>          continue</span>
<span class='covered'>  </span>
<span class='covered'>        case &quot;(&quot;:</span>
<span class='covered'>          if (inClass) {</span>
<span class='uncovered'>            re += &quot;(&quot;</span>
<span class='uncovered'>            continue</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='covered'>          if (!stateChar) {</span>
<span class='uncovered'>            re += &quot;\\(&quot;</span>
<span class='uncovered'>            continue</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='uncovered'>          plType = stateChar</span>
<span class='uncovered'>          patternListStack.push({ type: plType</span>
<span class='uncovered'>                                , start: i - 1</span>
<span class='uncovered'>                                , reStart: re.length })</span>
<span class='uncovered'>          // negation is (?:(?!js)[^/]*)</span>
<span class='uncovered'>          re += stateChar === &quot;!&quot; ? &quot;(?:(?!&quot; : &quot;(?:&quot;</span>
<span class='uncovered'>          stateChar = false</span>
<span class='uncovered'>          continue</span>
<span class='covered'>  </span>
<span class='covered'>        case &quot;)&quot;:</span>
<span class='uncovered'>          if (inClass || !patternListStack.length) {</span>
<span class='uncovered'>            re += &quot;\\)&quot;</span>
<span class='uncovered'>            continue</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='uncovered'>          hasMagic = true</span>
<span class='uncovered'>          re += &quot;)&quot;</span>
<span class='uncovered'>          plType = patternListStack.pop().type</span>
<span class='uncovered'>          // negation is (?:(?!js)[^/]*)</span>
<span class='uncovered'>          // The others are (?:&lt;pattern&gt;)&lt;type&gt;</span>
<span class='uncovered'>          switch (plType) {</span>
<span class='covered'>            case &quot;!&quot;:</span>
<span class='uncovered'>              re += &quot;[^/]*?)&quot;</span>
<span class='uncovered'>              break</span>
<span class='covered'>            case &quot;?&quot;:</span>
<span class='covered'>            case &quot;+&quot;:</span>
<span class='uncovered'>            case &quot;*&quot;: re += plType</span>
<span class='uncovered'>            case &quot;@&quot;: break // the default anyway</span>
<span class='covered'>          }</span>
<span class='covered'>          continue</span>
<span class='covered'>  </span>
<span class='covered'>        case &quot;|&quot;:</span>
<span class='uncovered'>          if (inClass || !patternListStack.length || escaping) {</span>
<span class='uncovered'>            re += &quot;\\|&quot;</span>
<span class='uncovered'>            escaping = false</span>
<span class='uncovered'>            continue</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='uncovered'>          re += &quot;|&quot;</span>
<span class='uncovered'>          continue</span>
<span class='covered'>  </span>
<span class='covered'>        // these are mostly the same in regexp and glob</span>
<span class='covered'>        case &quot;[&quot;:</span>
<span class='covered'>          // swallow any state-tracking char before the [</span>
<span class='uncovered'>          clearStateChar()</span>
<span class='uncovered'>  </span>
<span class='uncovered'>          if (inClass) {</span>
<span class='uncovered'>            re += &quot;\\&quot; + c</span>
<span class='uncovered'>            continue</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='uncovered'>          inClass = true</span>
<span class='uncovered'>          classStart = i</span>
<span class='uncovered'>          reClassStart = re.length</span>
<span class='uncovered'>          re += c</span>
<span class='uncovered'>          continue</span>
<span class='covered'>  </span>
<span class='covered'>        case &quot;]&quot;:</span>
<span class='covered'>          //  a right bracket shall lose its special</span>
<span class='covered'>          //  meaning and represent itself in</span>
<span class='covered'>          //  a bracket expression if it occurs</span>
<span class='covered'>          //  first in the list.  -- POSIX.2 2.8.3.2</span>
<span class='uncovered'>          if (i === classStart + 1 || !inClass) {</span>
<span class='uncovered'>            re += &quot;\\&quot; + c</span>
<span class='uncovered'>            escaping = false</span>
<span class='uncovered'>            continue</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='covered'>          // finish up the class.</span>
<span class='uncovered'>          hasMagic = true</span>
<span class='uncovered'>          inClass = false</span>
<span class='uncovered'>          re += c</span>
<span class='uncovered'>          continue</span>
<span class='covered'>  </span>
<span class='covered'>        default:</span>
<span class='covered'>          // swallow any state char that wasn&#39;t consumed</span>
<span class='covered'>          clearStateChar()</span>
<span class='covered'>  </span>
<span class='covered'>          if (escaping) {</span>
<span class='covered'>            // no need</span>
<span class='uncovered'>            escaping = false</span>
<span class='partial'>          } else if (reSpecials[c]<span class='partialuncovered'></span>        } else if (reSpecials[c]</span>
<span class='covered'>                     &amp;&amp; !(c === &quot;^&quot; &amp;&amp; inClass)) {</span>
<span class='covered'>            re += &quot;\\&quot;</span>
<span class='covered'>          }</span>
<span class='covered'>  </span>
<span class='covered'>          re += c</span>
<span class='covered'>  </span>
<span class='covered'>      } // switch</span>
<span class='covered'>    } // for</span>
<span class='covered'>  </span>
<span class='covered'>  </span>
<span class='covered'>    // handle the case where we left a class open.</span>
<span class='covered'>    // &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;</span>
<span class='covered'>    if (inClass) {</span>
<span class='covered'>      // split where the last [ was, and escape it</span>
<span class='covered'>      // this is a huge pita.  We now have to re-walk</span>
<span class='covered'>      // the contents of the would-be class to re-translate</span>
<span class='covered'>      // any characters that were passed through as-is</span>
<span class='uncovered'>      var cs = pattern.substr(classStart + 1)</span>
<span class='uncovered'>        , sp = this.parse(cs, SUBPARSE)</span>
<span class='uncovered'>      re = re.substr(0, reClassStart) + &quot;\\[&quot; + sp[0]</span>
<span class='uncovered'>      hasMagic = hasMagic || sp[1]</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // handle the case where we had a +( thing at the *end*</span>
<span class='covered'>    // of the pattern.</span>
<span class='covered'>    // each pattern list stack adds 3 chars, and we need to go through</span>
<span class='covered'>    // and escape any | chars that were passed through as-is for the regexp.</span>
<span class='covered'>    // Go through and escape them, taking care not to double-escape any</span>
<span class='covered'>    // | chars that were already escaped.</span>
<span class='covered'>    var pl</span>
<span class='covered'>    while (pl = patternListStack.pop()) {</span>
<span class='uncovered'>      var tail = re.slice(pl.reStart + 3)</span>
<span class='uncovered'>      // maybe some even number of \, then maybe 1 \, followed by a |</span>
<span class='uncovered'>      tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {</span>
<span class='uncovered'>        if (!$2) {</span>
<span class='uncovered'>          // the | isn&#39;t already escaped, so escape it.</span>
<span class='uncovered'>          $2 = &quot;\\&quot;</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        // need to escape all those slashes *again*, without escaping the</span>
<span class='uncovered'>        // one that we need for escaping the | character.  As it works out,</span>
<span class='uncovered'>        // escaping an even number of slashes can be done by simply repeating</span>
<span class='uncovered'>        // it exactly after itself.  That&#39;s why this trick works.</span>
<span class='uncovered'>        //</span>
<span class='uncovered'>        // I am sorry that you have to see this.</span>
<span class='uncovered'>        return $1 + $1 + $2 + &quot;|&quot;</span>
<span class='uncovered'>      })</span>
<span class='uncovered'>  </span>
<span class='uncovered'>      // console.error(&quot;tail=%j\n   %s&quot;, tail, tail)</span>
<span class='uncovered'>      var t = pl.type === &quot;*&quot; ? star</span>
<span class='uncovered'>            : pl.type === &quot;?&quot; ? qmark</span>
<span class='uncovered'>            : &quot;\\&quot; + pl.type</span>
<span class='uncovered'>  </span>
<span class='uncovered'>      hasMagic = true</span>
<span class='uncovered'>      re = re.slice(0, pl.reStart)</span>
<span class='uncovered'>         + t + &quot;\\(&quot;</span>
<span class='uncovered'>         + tail</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // handle trailing things that only matter at the very end.</span>
<span class='covered'>    clearStateChar()</span>
<span class='covered'>    if (escaping) {</span>
<span class='covered'>      // trailing \\</span>
<span class='uncovered'>      re += &quot;\\\\&quot;</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // only need to apply the nodot start if the re starts with</span>
<span class='covered'>    // something that could conceivably capture a dot</span>
<span class='covered'>    var addPatternStart = false</span>
<span class='covered'>    switch (re.charAt(0)) {</span>
<span class='covered'>      case &quot;.&quot;:</span>
<span class='covered'>      case &quot;[&quot;:</span>
<span class='uncovered'>      case &quot;(&quot;: addPatternStart = true</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // if the re is not &quot;&quot; at this point, then we need to make sure</span>
<span class='covered'>    // it doesn&#39;t match against an empty path part.</span>
<span class='covered'>    // Otherwise a/* will match a/, which it should not.</span>
<span class='partial'>    if (re !== &quot;&quot; &amp;&amp; hasMagic) re = &quot;(?=.)&quot; + re<span class='partialuncovered'></span>  if (re !== &quot;&quot; &amp;&amp; hasMagic) re = <span class='partialuncovered'>&quot;(?=.)&quot; + re</span></span>
<span class='uncovered'>  </span>
<span class='uncovered'>    if (addPatternStart) re = patternStart + re</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // parsing just a piece of a larger pattern.</span>
<span class='partial'>    if (isSub === SUBPARSE) {<span class='partialuncovered'></span>  if (isSub === SUBPARSE) {</span>
<span class='uncovered'>      return [ re, hasMagic ]</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // skip the regexp for non-magical patterns</span>
<span class='covered'>    // unescape anything in it, though, so that it&#39;ll be</span>
<span class='covered'>    // an exact match against a file etc.</span>
<span class='covered'>    if (!hasMagic) {</span>
<span class='covered'>      return globUnescape(pattern)</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    var flags = options.nocase ? &quot;i&quot; : &quot;&quot;</span>
<span class='uncovered'>      , regExp = new RegExp(&quot;^&quot; + re + &quot;$&quot;, flags)</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    regExp._glob = pattern</span>
<span class='uncovered'>    regExp._src = re</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    return regExp</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  minimatch.makeRe = function (pattern, options) {</span>
<span class='uncovered'>    return new Minimatch(pattern, options || {}).makeRe()</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  Minimatch.prototype.makeRe = makeRe</span>
<span class='covered'>  function makeRe () {</span>
<span class='uncovered'>    if (this.regexp || this.regexp === false) return this.regexp</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // at this point, this.set is a 2d array of partial</span>
<span class='uncovered'>    // pattern strings, or &quot;**&quot;.</span>
<span class='uncovered'>    //</span>
<span class='uncovered'>    // It&#39;s better to use .match().  This function shouldn&#39;t</span>
<span class='uncovered'>    // be used, really, but it&#39;s pretty convenient sometimes,</span>
<span class='uncovered'>    // when you just want to work with a regex.</span>
<span class='uncovered'>    var set = this.set</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    if (!set.length) return this.regexp = false</span>
<span class='uncovered'>    var options = this.options</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    var twoStar = options.noglobstar ? star</span>
<span class='uncovered'>        : options.dot ? twoStarDot</span>
<span class='uncovered'>        : twoStarNoDot</span>
<span class='uncovered'>      , flags = options.nocase ? &quot;i&quot; : &quot;&quot;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    var re = set.map(function (pattern) {</span>
<span class='uncovered'>      return pattern.map(function (p) {</span>
<span class='uncovered'>        return (p === GLOBSTAR) ? twoStar</span>
<span class='uncovered'>             : (typeof p === &quot;string&quot;) ? regExpEscape(p)</span>
<span class='uncovered'>             : p._src</span>
<span class='uncovered'>      }).join(&quot;\\\/&quot;)</span>
<span class='uncovered'>    }).join(&quot;|&quot;)</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // must match entire pattern</span>
<span class='uncovered'>    // ending in a * or ** will make it less strict.</span>
<span class='uncovered'>    re = &quot;^&quot; + re + &quot;$&quot;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // can match anything, as long as it&#39;s not this.</span>
<span class='uncovered'>    if (this.negate) re = &quot;^(?!&quot; + re + &quot;).*$&quot;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    try {</span>
<span class='uncovered'>      return this.regexp = new RegExp(re, flags)</span>
<span class='uncovered'>    } catch (ex) {</span>
<span class='uncovered'>      return this.regexp = false</span>
<span class='uncovered'>    }</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  minimatch.match = function (list, pattern, options) {</span>
<span class='uncovered'>    var mm = new Minimatch(pattern, options)</span>
<span class='uncovered'>    list = list.filter(function (f) {</span>
<span class='uncovered'>      return mm.match(f)</span>
<span class='uncovered'>    })</span>
<span class='uncovered'>    if (options.nonull &amp;&amp; !list.length) {</span>
<span class='uncovered'>      list.push(pattern)</span>
<span class='uncovered'>    }</span>
<span class='uncovered'>    return list</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  Minimatch.prototype.match = match</span>
<span class='covered'>  function match (f, partial) {</span>
<span class='covered'>    // console.error(&quot;match&quot;, f, this.pattern)</span>
<span class='covered'>    // short-circuit in the case of busted things.</span>
<span class='covered'>    // comments, etc.</span>
<span class='uncovered'>    if (this.comment) return false</span>
<span class='uncovered'>    if (this.empty) return f === &quot;&quot;</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    if (f === &quot;/&quot; &amp;&amp; partial) return true</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    var options = this.options</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    // windows: need to use /, not \</span>
<span class='uncovered'>    // On other platforms, \ is a valid (albeit bad) filename char.</span>
<span class='uncovered'>    if (platform === &quot;win32&quot;) {</span>
<span class='uncovered'>      f = f.split(&quot;\\&quot;).join(&quot;/&quot;)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // treat the test path as a set of pathparts.</span>
<span class='uncovered'>    f = f.split(slashSplit)</span>
<span class='uncovered'>    if (options.debug) {</span>
<span class='uncovered'>      console.error(this.pattern, &quot;split&quot;, f)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // just ONE of the pattern sets in this.set needs to match</span>
<span class='covered'>    // in order for it to be valid.  If negating, then just one</span>
<span class='covered'>    // match means that we have failed.</span>
<span class='covered'>    // Either way, return on the first hit.</span>
<span class='covered'>  </span>
<span class='uncovered'>    var set = this.set</span>
<span class='uncovered'>    // console.error(this.pattern, &quot;set&quot;, set)</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    for (var i = 0, l = set.length; i &lt; l; i ++) {</span>
<span class='uncovered'>      var pattern = set[i]</span>
<span class='uncovered'>      var hit = this.matchOne(f, pattern, partial)</span>
<span class='uncovered'>      if (hit) {</span>
<span class='uncovered'>        if (options.flipNegate) return true</span>
<span class='uncovered'>        return !this.negate</span>
<span class='uncovered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // didn&#39;t get any hits.  this is success if it&#39;s a negative</span>
<span class='covered'>    // pattern, failure otherwise.</span>
<span class='uncovered'>    if (options.flipNegate) return false</span>
<span class='uncovered'>    return this.negate</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  // set partial to true to test if, for example,</span>
<span class='covered'>  // &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;</span>
<span class='covered'>  // Partial means, if you run out of file before you run</span>
<span class='covered'>  // out of pattern, then that&#39;s fine, as long as all</span>
<span class='covered'>  // the parts match.</span>
<span class='covered'>  Minimatch.prototype.matchOne = function (file, pattern, partial) {</span>
<span class='uncovered'>    var options = this.options</span>
<span class='uncovered'>  </span>
<span class='uncovered'>    if (options.debug) {</span>
<span class='uncovered'>      console.error(&quot;matchOne&quot;,</span>
<span class='uncovered'>                    { &quot;this&quot;: this</span>
<span class='uncovered'>                    , file: file</span>
<span class='uncovered'>                    , pattern: pattern })</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    if (options.matchBase &amp;&amp; pattern.length === 1) {</span>
<span class='uncovered'>      file = path.basename(file.join(&quot;/&quot;)).split(&quot;/&quot;)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    if (options.debug) {</span>
<span class='uncovered'>      console.error(&quot;matchOne&quot;, file.length, pattern.length)</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    for ( var fi = 0</span>
<span class='covered'>            , pi = 0</span>
<span class='covered'>            , fl = file.length</span>
<span class='covered'>            , pl = pattern.length</span>
<span class='uncovered'>        ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)</span>
<span class='uncovered'>        ; fi ++, pi ++ ) {</span>
<span class='covered'>  </span>
<span class='covered'>      if (options.debug) {</span>
<span class='uncovered'>        console.error(&quot;matchOne loop&quot;)</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>      var p = pattern[pi]</span>
<span class='uncovered'>        , f = file[fi]</span>
<span class='uncovered'>  </span>
<span class='uncovered'>      if (options.debug) {</span>
<span class='uncovered'>        console.error(pattern, p, f)</span>
<span class='uncovered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      // should be impossible.</span>
<span class='covered'>      // some invalid regexp stuff in the set.</span>
<span class='uncovered'>      if (p === false) return false</span>
<span class='uncovered'>  </span>
<span class='uncovered'>      if (p === GLOBSTAR) {</span>
<span class='covered'>        if (options.debug)</span>
<span class='uncovered'>          console.error(&#39;GLOBSTAR&#39;, [pattern, p, f])</span>
<span class='uncovered'>  </span>
<span class='uncovered'>        // &quot;**&quot;</span>
<span class='uncovered'>        // a/**/b/**/c would match the following:</span>
<span class='uncovered'>        // a/b/x/y/z/c</span>
<span class='uncovered'>        // a/x/y/z/b/c</span>
<span class='uncovered'>        // a/b/x/b/x/c</span>
<span class='uncovered'>        // a/b/c</span>
<span class='uncovered'>        // To do this, take the rest of the pattern after</span>
<span class='uncovered'>        // the **, and see if it would match the file remainder.</span>
<span class='uncovered'>        // If so, return success.</span>
<span class='uncovered'>        // If not, the ** &quot;swallows&quot; a segment, and try again.</span>
<span class='uncovered'>        // This is recursively awful.</span>
<span class='uncovered'>        //</span>
<span class='uncovered'>        // a/**/b/**/c matching a/b/x/y/z/c</span>
<span class='uncovered'>        // - a matches a</span>
<span class='uncovered'>        // - doublestar</span>
<span class='uncovered'>        //   - matchOne(b/x/y/z/c, b/**/c)</span>
<span class='uncovered'>        //     - b matches b</span>
<span class='uncovered'>        //     - doublestar</span>
<span class='uncovered'>        //       - matchOne(x/y/z/c, c) -&gt; no</span>
<span class='uncovered'>        //       - matchOne(y/z/c, c) -&gt; no</span>
<span class='uncovered'>        //       - matchOne(z/c, c) -&gt; no</span>
<span class='uncovered'>        //       - matchOne(c, c) yes, hit</span>
<span class='uncovered'>        var fr = fi</span>
<span class='uncovered'>          , pr = pi + 1</span>
<span class='uncovered'>        if (pr === pl) {</span>
<span class='covered'>          if (options.debug)</span>
<span class='uncovered'>            console.error(&#39;** at the end&#39;)</span>
<span class='uncovered'>          // a ** at the end will just swallow the rest.</span>
<span class='uncovered'>          // We have found a match.</span>
<span class='uncovered'>          // however, it will not swallow /.x, unless</span>
<span class='uncovered'>          // options.dot is set.</span>
<span class='uncovered'>          // . and .. are *never* matched by **, for explosively</span>
<span class='uncovered'>          // exponential reasons.</span>
<span class='uncovered'>          for ( ; fi &lt; fl; fi ++) {</span>
<span class='uncovered'>            if (file[fi] === &quot;.&quot; || file[fi] === &quot;..&quot; ||</span>
<span class='uncovered'>                (!options.dot &amp;&amp; file[fi].charAt(0) === &quot;.&quot;)) return false</span>
<span class='uncovered'>          }</span>
<span class='uncovered'>          return true</span>
<span class='uncovered'>        }</span>
<span class='covered'>  </span>
<span class='covered'>        // ok, let&#39;s see if we can swallow whatever we can.</span>
<span class='uncovered'>        WHILE: while (fr &lt; fl) {</span>
<span class='uncovered'>          var swallowee = file[fr]</span>
<span class='uncovered'>  </span>
<span class='uncovered'>          if (options.debug) {</span>
<span class='uncovered'>            console.error(&#39;\nglobstar while&#39;,</span>
<span class='uncovered'>                          file, fr, pattern, pr, swallowee)</span>
<span class='uncovered'>          }</span>
<span class='covered'>  </span>
<span class='covered'>          // XXX remove this slice.  Just pass the start index.</span>
<span class='uncovered'>          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {</span>
<span class='covered'>            if (options.debug)</span>
<span class='uncovered'>              console.error(&#39;globstar found match!&#39;, fr, fl, swallowee)</span>
<span class='uncovered'>            // found a match.</span>
<span class='uncovered'>            return true</span>
<span class='uncovered'>          } else {</span>
<span class='covered'>            // can&#39;t swallow &quot;.&quot; or &quot;..&quot; ever.</span>
<span class='covered'>            // can only swallow &quot;.foo&quot; when explicitly asked.</span>
<span class='uncovered'>            if (swallowee === &quot;.&quot; || swallowee === &quot;..&quot; ||</span>
<span class='uncovered'>                (!options.dot &amp;&amp; swallowee.charAt(0) === &quot;.&quot;)) {</span>
<span class='covered'>              if (options.debug)</span>
<span class='uncovered'>                console.error(&quot;dot detected!&quot;, file, fr, pattern, pr)</span>
<span class='uncovered'>              break WHILE</span>
<span class='covered'>            }</span>
<span class='covered'>  </span>
<span class='covered'>            // ** swallows a segment, and continue.</span>
<span class='covered'>            if (options.debug)</span>
<span class='uncovered'>              console.error(&#39;globstar swallow a segment, and continue&#39;)</span>
<span class='uncovered'>            fr ++</span>
<span class='uncovered'>          }</span>
<span class='covered'>        }</span>
<span class='covered'>        // no match was found.</span>
<span class='covered'>        // However, in partial mode, we can&#39;t say this is necessarily over.</span>
<span class='covered'>        // If there&#39;s more *pattern* left, then </span>
<span class='covered'>        if (partial) {</span>
<span class='covered'>          // ran out of file</span>
<span class='covered'>          // console.error(&quot;\n&gt;&gt;&gt; no match, partial?&quot;, file, fr, pattern, pr)</span>
<span class='uncovered'>          if (fr === fl) return true</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>        return false</span>
<span class='uncovered'>      }</span>
<span class='covered'>  </span>
<span class='covered'>      // something other than **</span>
<span class='covered'>      // non-magic patterns just have to match exactly</span>
<span class='covered'>      // patterns with magic have been turned into regexps.</span>
<span class='uncovered'>      var hit</span>
<span class='uncovered'>      if (typeof p === &quot;string&quot;) {</span>
<span class='covered'>        if (options.nocase) {</span>
<span class='uncovered'>          hit = f.toLowerCase() === p.toLowerCase()</span>
<span class='uncovered'>        } else {</span>
<span class='uncovered'>          hit = f === p</span>
<span class='uncovered'>        }</span>
<span class='covered'>        if (options.debug) {</span>
<span class='uncovered'>          console.error(&quot;string match&quot;, p, f, hit)</span>
<span class='uncovered'>        }</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        hit = f.match(p)</span>
<span class='uncovered'>        if (options.debug) {</span>
<span class='uncovered'>          console.error(&quot;pattern match&quot;, p, f, hit)</span>
<span class='uncovered'>        }</span>
<span class='covered'>      }</span>
<span class='covered'>  </span>
<span class='uncovered'>      if (!hit) return false</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // Note: ending in / means that we&#39;ll get a final &quot;&quot;</span>
<span class='covered'>    // at the end of the pattern.  This can only match a</span>
<span class='covered'>    // corresponding &quot;&quot; at the end of the file.</span>
<span class='covered'>    // If the file ends in /, then it can only match a</span>
<span class='covered'>    // a pattern that ends in /, unless the pattern just</span>
<span class='covered'>    // doesn&#39;t have any more for it. But, a/b/ should *not*</span>
<span class='covered'>    // match &quot;a/b/*&quot;, even though &quot;&quot; matches against the</span>
<span class='covered'>    // [^/]*? pattern, except in partial mode, where it might</span>
<span class='covered'>    // simply not be reached yet.</span>
<span class='covered'>    // However, a/b/ should still satisfy a/*</span>
<span class='covered'>  </span>
<span class='covered'>    // now either we fell off the end of the pattern, or we&#39;re done.</span>
<span class='uncovered'>    if (fi === fl &amp;&amp; pi === pl) {</span>
<span class='covered'>      // ran out of pattern and filename at the same time.</span>
<span class='covered'>      // an exact hit!</span>
<span class='uncovered'>      return true</span>
<span class='uncovered'>    } else if (fi === fl) {</span>
<span class='covered'>      // ran out of file, but still had pattern left.</span>
<span class='covered'>      // this is ok if we&#39;re doing the match as part of</span>
<span class='covered'>      // a glob fs traversal.</span>
<span class='uncovered'>      return partial</span>
<span class='uncovered'>    } else if (pi === pl) {</span>
<span class='covered'>      // ran out of pattern, still have file left.</span>
<span class='covered'>      // this is only acceptable if we&#39;re on the very last</span>
<span class='covered'>      // empty segment of a file with a trailing slash.</span>
<span class='covered'>      // a/* should match a/b/</span>
<span class='uncovered'>      var emptyFileEnd = (fi === fl - 1) &amp;&amp; (file[fi] === &quot;&quot;)</span>
<span class='uncovered'>      return emptyFileEnd</span>
<span class='uncovered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // should be unreachable.</span>
<span class='uncovered'>    throw new Error(&quot;wtf?&quot;)</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  </span>
<span class='covered'>  // replace stuff like \* with *</span>
<span class='covered'>  function globUnescape (s) {</span>
<span class='covered'>    return s.replace(/\\(.)/g, &quot;$1&quot;)</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  </span>
<span class='covered'>  function regExpEscape (s) {</span>
<span class='uncovered'>    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &quot;\\$&amp;&quot;)</span>
<span class='uncovered'>  }</span>
<span class='covered'>  </span>
<span class='partial'>  })( typeof require === &quot;function&quot; ? require : <span class='partialuncovered'>null,</span></span>
<span class='covered'>      this,</span>
<span class='partial'>      typeof module === &quot;object&quot; ? module : <span class='partialuncovered'>null,</span></span>
<span class='partial'>      typeof process === &quot;object&quot; ? process.platform : <span class='partialuncovered'>&quot;win32&quot;</span></span>
<span class='covered'>    )</span></pre></td>          
            </tr>
          </tbody>
        </table>
        <a class="index" href="index.html">Â« index</a> | <a class="coverio" href="http://cover.io">cover.io</a>
      </div>
  </body>
</html>
